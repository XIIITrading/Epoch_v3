================================================================================
STEP 2: MIGRATE 04_DOW_AI
================================================================================

Location: C:\XIIITradingSystems\Epoch\04_dow_ai\
Complexity: MEDIUM - Keep class wrappers, delegate core calculations

NOTE: This module uses pandas DataFrames. Keep the class structure but
delegate the actual calculation logic to the shared library.

================================================================================
2.1 UPDATE: calculations/vwap.py
================================================================================

This file has unique session-based VWAP anchoring (9:30 AM ET).
Keep that logic but use shared calculation for the core formula.

STEP 1: Add imports at the top (after existing imports):

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "03_indicators" / "python"))
from core.vwap import calculate_vwap as _shared_calculate_vwap


STEP 2: Replace the calculation section in calculate_vwap() method.

FIND THIS SECTION (approximately lines 99-128):

        # Filter to current session
        session_df = df[df['timestamp'] >= session_start].copy()

        if session_df.empty:
            if self.verbose:
                debug_print("No data in current session for VWAP")
            return 0.0

        # Calculate typical price
        session_df['typical_price'] = (
            session_df['high'] + session_df['low'] + session_df['close']
        ) / 3

        # Calculate VWAP
        session_df['tp_volume'] = session_df['typical_price'] * session_df['volume']

        total_tp_volume = session_df['tp_volume'].sum()
        total_volume = session_df['volume'].sum()

        if total_volume == 0:
            if self.verbose:
                debug_print("Zero volume in session")
            return 0.0

        vwap = total_tp_volume / total_volume

        if self.verbose:
            debug_print(f"VWAP: ${vwap:.2f} (from {len(session_df)} bars)")

        return float(vwap)


REPLACE WITH:

        # Filter to current session
        session_df = df[df['timestamp'] >= session_start].copy()

        if session_df.empty:
            if self.verbose:
                debug_print("No data in current session for VWAP")
            return 0.0

        # Convert DataFrame to list of dicts for shared library
        bars = session_df.to_dict('records')

        # Use shared library calculation
        vwap = _shared_calculate_vwap(bars)

        if vwap is None:
            return 0.0

        if self.verbose:
            debug_print(f"VWAP: ${vwap:.2f} (from {len(session_df)} bars)")

        return float(vwap)


================================================================================
2.2 UPDATE: calculations/moving_averages.py
================================================================================

STEP 1: Add imports at the top (after existing imports):

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "03_indicators" / "python"))
from core.sma import calculate_sma_spread as _shared_sma_spread, calculate_sma_momentum as _shared_sma_momentum


STEP 2: Replace the calculate_smas() method body.

FIND THE METHOD (approximately lines 51-122) AND REPLACE THE BODY WITH:

    def calculate_smas(self, df: pd.DataFrame) -> SMAResult:
        """
        Calculate SMA9, SMA21, spread, and trends.

        Args:
            df: DataFrame with 'close' column

        Returns:
            SMAResult with all calculations
        """
        if df is None or len(df) < 21:
            if self.verbose:
                debug_print(f"Insufficient data for SMA: {len(df) if df is not None else 0} bars")
            return SMAResult(
                sma9=0.0,
                sma21=0.0,
                spread=0.0,
                spread_trend='FLAT',
                alignment='NEUTRAL',
                cross_price_estimate=None
            )

        # Convert DataFrame to list of dicts for shared library
        bars = df.to_dict('records')

        # Use shared library for spread calculation
        spread_result = _shared_sma_spread(bars)
        momentum_result = _shared_sma_momentum(bars)

        # Map momentum to spread_trend
        spread_trend = momentum_result.momentum  # WIDENING, NARROWING, FLAT

        if self.verbose:
            debug_print(f"SMA9: ${spread_result.sma9:.2f} | SMA21: ${spread_result.sma21:.2f} | {spread_result.alignment} | {spread_trend}")

        return SMAResult(
            sma9=spread_result.sma9 or 0.0,
            sma21=spread_result.sma21 or 0.0,
            spread=spread_result.spread or 0.0,
            spread_trend=spread_trend,
            alignment=spread_result.alignment or 'NEUTRAL',
            cross_price_estimate=spread_result.cross_estimate
        )


================================================================================
2.3 UPDATE: calculations/volume_analysis.py
================================================================================

STEP 1: Add imports at the top (after existing imports):

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "03_indicators" / "python"))
from core.volume_delta import calculate_bar_delta as _shared_bar_delta
from core.volume_roc import calculate_volume_roc as _shared_volume_roc
from core.cvd import calculate_cvd_slope as _shared_cvd_slope


STEP 2: Replace calculate_bar_delta() method (approximately lines 68-99):

    def calculate_bar_delta(self, row: pd.Series) -> float:
        """
        Calculate volume delta for a single bar using shared library.

        Args:
            row: Series with open, high, low, close, volume

        Returns:
            Volume delta (positive = buying, negative = selling)
        """
        result = _shared_bar_delta(
            open_price=row['open'],
            high=row['high'],
            low=row['low'],
            close=row['close'],
            volume=int(row['volume'])
        )
        return result.bar_delta


STEP 3: Replace calculate_volume_roc() method (approximately lines 118-141):

    def calculate_volume_roc(self, df: pd.DataFrame) -> Tuple[float, float]:
        """
        Calculate volume rate of change using shared library.

        Args:
            df: DataFrame with OHLCV data

        Returns:
            Tuple of (roc_percent, baseline_avg)
        """
        if len(df) < self.roc_baseline + 1:
            return 0.0, 0.0

        bars = df.to_dict('records')
        result = _shared_volume_roc(bars, baseline_period=self.roc_baseline)

        return result.roc or 0.0, result.baseline_avg or 0.0


STEP 4: Replace determine_cvd_trend() method (approximately lines 156-193):

    def determine_cvd_trend(self, df: pd.DataFrame) -> str:
        """
        Determine CVD trend using shared library.

        Args:
            df: DataFrame with OHLCV data

        Returns:
            'Rising', 'Falling', or 'Flat'
        """
        if len(df) < self.cvd_window:
            return 'Flat'

        bars = df.to_dict('records')
        result = _shared_cvd_slope(bars, window=self.cvd_window)

        return result.trend


================================================================================
2.4 UPDATE: calculations/market_structure.py
================================================================================

STEP 1: Add imports at the top (after existing imports):

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "03_indicators" / "python"))
from structure.swing_detection import find_swing_highs as _shared_swing_highs, find_swing_lows as _shared_swing_lows


STEP 2: Replace _detect_fractals() method (approximately lines 51-92):

    def _detect_fractals(self, df: pd.DataFrame) -> Tuple[pd.Series, pd.Series]:
        """
        Detect bullish and bearish fractals using shared library.

        Args:
            df: DataFrame with 'high' and 'low' columns

        Returns:
            Tuple of (bullish_fractals, bearish_fractals) as boolean Series
        """
        n = len(df)
        p = self.p

        bullish_fractals = pd.Series([False] * n, index=df.index)
        bearish_fractals = pd.Series([False] * n, index=df.index)

        if n < self.fractal_length:
            return bullish_fractals, bearish_fractals

        # Convert to list of dicts for shared library
        bars = df.to_dict('records')

        # Get swing points from shared library
        swing_high_values = _shared_swing_highs(bars, n - 1, self.fractal_length)
        swing_low_values = _shared_swing_lows(bars, n - 1, self.fractal_length)

        # Mark fractal positions in the series
        # Note: shared library returns values, not indices
        # We need to find which bars match these values
        for i in range(p, n - p):
            if df.iloc[i]['high'] in swing_high_values:
                bearish_fractals.iloc[i] = True
            if df.iloc[i]['low'] in swing_low_values:
                bullish_fractals.iloc[i] = True

        return bullish_fractals, bearish_fractals


================================================================================
TESTING AFTER MIGRATION
================================================================================

Run from: C:\XIIITradingSystems\Epoch\04_dow_ai\

Test commands:
python -c "from calculations.vwap import VWAPCalculator; print('vwap OK')"
python -c "from calculations.moving_averages import MovingAverageAnalyzer; print('moving_averages OK')"
python -c "from calculations.volume_analysis import VolumeAnalyzer; print('volume_analysis OK')"
python -c "from calculations.market_structure import MarketStructureCalculator; print('market_structure OK')"

Full integration test (requires API key):
python calculations/vwap.py
python calculations/moving_averages.py
python calculations/volume_analysis.py
python calculations/market_structure.py

================================================================================
