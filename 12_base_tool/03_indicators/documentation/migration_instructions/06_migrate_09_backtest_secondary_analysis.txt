================================================================================
STEP 6: MIGRATE 09_BACKTEST SECONDARY ANALYSIS
================================================================================

Location: C:\XIIITradingSystems\Epoch\02_zone_system\09_backtest\processor\secondary_analysis\entry_indicators\
Complexity: MEDIUM - Pure functions, delegate to shared library

This file uses pure functions (no classes). We can delegate directly
to the shared library functions.

================================================================================
6.1 UPDATE: indicators.py
================================================================================

STEP 1: Replace the config imports and add shared library imports.

FIND (at the top of the file, after standard imports):
from config import (
    SMA_FAST_PERIOD,
    SMA_SLOW_PERIOD,
    SMA_MOMENTUM_LOOKBACK,
    SMA_WIDENING_THRESHOLD,
    VOLUME_ROC_BASELINE_PERIOD,
    VOLUME_ROC_ABOVE_AVG_THRESHOLD,
    VOLUME_DELTA_ROLLING_PERIOD,
    CVD_WINDOW
)

REPLACE WITH:
import sys
from pathlib import Path
_SHARED_LIB = Path(__file__).parent.parent.parent.parent.parent.parent / "03_indicators" / "python"
sys.path.insert(0, str(_SHARED_LIB))

from indicator_types import SMAResult as _SMAResult, SMAMomentumResult as _SMAMomentumResult
from indicator_types import VWAPResult as _VWAPResult, VolumeROCResult as _VolumeROCResult
from indicator_types import VolumeDeltaResult as _VolumeDeltaResult, CVDResult as _CVDResult
from core.sma import calculate_sma as _calc_sma, calculate_sma_spread as _calc_spread, calculate_sma_momentum as _calc_momentum
from core.vwap import calculate_vwap as _calc_vwap, calculate_vwap_metrics as _calc_vwap_metrics
from core.volume_roc import calculate_volume_roc as _calc_vol_roc
from core.volume_delta import calculate_bar_delta as _calc_bar_delta, calculate_rolling_delta as _calc_rolling_delta
from core.cvd import calculate_cvd_slope as _calc_cvd


STEP 2: Replace the calculate_sma() function:

FIND:
def calculate_sma(bars: List[Dict], index: int = -1) -> Optional[SMAResult]:
    """
    Calculate SMA9 and SMA21 at a given bar index.
    ...
    """
    # ... existing implementation

REPLACE WITH:
def calculate_sma(bars: List[Dict], index: int = -1) -> Optional[SMAResult]:
    """
    Calculate SMA9 and SMA21 at a given bar index using shared library.

    Args:
        bars: List of bar dictionaries with 'close' key
        index: Bar index to calculate at (-1 for last bar)

    Returns:
        SMAResult or None if insufficient data
    """
    if index == -1:
        index = len(bars) - 1
    result = _calc_spread(bars, up_to_index=index)
    if result.sma9 is None:
        return None
    return SMAResult(
        sma9=result.sma9,
        sma21=result.sma21,
        spread=result.spread,
        alignment='BULL' if result.alignment == 'BULLISH' else 'BEAR'
    )


STEP 3: Replace the calculate_sma_momentum() function:

FIND:
def calculate_sma_momentum(bars: List[Dict], index: int = -1) -> Optional[SMAMomentumResult]:
    """
    Calculate SMA spread momentum.
    ...
    """
    # ... existing implementation

REPLACE WITH:
def calculate_sma_momentum(bars: List[Dict], index: int = -1) -> Optional[SMAMomentumResult]:
    """
    Calculate SMA spread momentum using shared library.

    Args:
        bars: List of bar dictionaries
        index: Bar index to calculate at (-1 for last bar)

    Returns:
        SMAMomentumResult or None if insufficient data
    """
    if index == -1:
        index = len(bars) - 1
    result = _calc_momentum(bars, up_to_index=index)
    if result.spread_now is None:
        return None
    # Map WIDENING/NARROWING/FLAT to WIDENING/NARROWING/STABLE
    momentum = result.momentum if result.momentum != 'FLAT' else 'STABLE'
    return SMAMomentumResult(
        current_spread=result.spread_now,
        previous_spread=result.spread_prev,
        ratio=result.ratio,
        momentum=momentum
    )


STEP 4: Replace the calculate_vwap() function:

FIND:
def calculate_vwap(bars: List[Dict], index: int = -1, price: float = None) -> Optional[VWAPResult]:
    """
    Calculate VWAP at a given bar index.
    ...
    """
    # ... existing implementation

REPLACE WITH:
def calculate_vwap(bars: List[Dict], index: int = -1, price: float = None) -> Optional[VWAPResult]:
    """
    Calculate VWAP using shared library.

    Args:
        bars: List of bar dictionaries with OHLCV data
        index: Bar index to calculate at (-1 for last bar)
        price: Current price (uses close if None)

    Returns:
        VWAPResult or None if insufficient data
    """
    if index == -1:
        index = len(bars) - 1
    if price is None:
        price = bars[index].get('close', 0)
    result = _calc_vwap_metrics(bars, price, up_to_index=index)
    if result.vwap is None:
        return None
    return VWAPResult(
        vwap=result.vwap,
        price=price,
        side=result.side
    )


STEP 5: Replace the calculate_volume_roc() function:

FIND:
def calculate_volume_roc(bars: List[Dict], index: int = -1) -> Optional[VolumeROCResult]:
    """
    Calculate Volume ROC.
    ...
    """
    # ... existing implementation

REPLACE WITH:
def calculate_volume_roc(bars: List[Dict], index: int = -1) -> Optional[VolumeROCResult]:
    """
    Calculate Volume ROC using shared library.

    Args:
        bars: List of bar dictionaries with 'volume' key
        index: Bar index to calculate at (-1 for last bar)

    Returns:
        VolumeROCResult or None if insufficient data
    """
    if index == -1:
        index = len(bars) - 1
    result = _calc_vol_roc(bars, up_to_index=index)
    if result.roc is None:
        return None
    return VolumeROCResult(
        current_volume=result.current_volume,
        baseline_avg=result.baseline_avg,
        roc=result.roc
    )


STEP 6: Replace the calculate_bar_delta() function:

FIND:
def calculate_bar_delta(bar: Dict) -> float:
    """
    Calculate volume delta for a single bar.
    ...
    """
    # ... existing implementation

REPLACE WITH:
def calculate_bar_delta(bar: Dict) -> float:
    """
    Calculate volume delta for a single bar using shared library.

    Args:
        bar: Bar dictionary with open, high, low, close, volume

    Returns:
        Volume delta value
    """
    result = _calc_bar_delta(
        bar.get('open', 0),
        bar.get('high', 0),
        bar.get('low', 0),
        bar.get('close', 0),
        int(bar.get('volume', 0))
    )
    return result.bar_delta


STEP 7: Replace the calculate_volume_delta() function:

FIND:
def calculate_volume_delta(bars: List[Dict], index: int = -1) -> Optional[VolumeDeltaResult]:
    """
    Calculate rolling volume delta.
    ...
    """
    # ... existing implementation

REPLACE WITH:
def calculate_volume_delta(bars: List[Dict], index: int = -1) -> Optional[VolumeDeltaResult]:
    """
    Calculate rolling volume delta using shared library.

    Args:
        bars: List of bar dictionaries
        index: Bar index to calculate at (-1 for last bar)

    Returns:
        VolumeDeltaResult
    """
    if index == -1:
        index = len(bars) - 1
    result = _calc_rolling_delta(bars, up_to_index=index)
    return VolumeDeltaResult(
        bar_delta=calculate_bar_delta(bars[index]),
        rolling_delta=result.rolling_delta
    )


STEP 8: Replace the calculate_cvd_slope() function:

FIND:
def calculate_cvd_slope(bars: List[Dict], index: int = -1) -> Optional[CVDResult]:
    """
    Calculate CVD slope.
    ...
    """
    # ... existing implementation

REPLACE WITH:
def calculate_cvd_slope(bars: List[Dict], index: int = -1) -> Optional[CVDResult]:
    """
    Calculate CVD slope using shared library.

    Args:
        bars: List of bar dictionaries
        index: Bar index to calculate at (-1 for last bar)

    Returns:
        CVDResult
    """
    if index == -1:
        index = len(bars) - 1
    result = _calc_cvd(bars, up_to_index=index)
    return CVDResult(
        cvd_values=result.cvd_values,
        slope=result.slope
    )


STEP 9: Remove the helper functions that are now unused:

DELETE THESE FUNCTIONS (they are now handled by the shared library):
- _get_closes()
- _get_volumes()
- _get_highs()
- _get_lows()
- _simple_moving_average()
- _linear_regression_slope()


================================================================================
TESTING AFTER MIGRATION
================================================================================

Run from: C:\XIIITradingSystems\Epoch\02_zone_system\09_backtest\

Test commands:
python -c "from processor.secondary_analysis.entry_indicators.indicators import calculate_sma, calculate_vwap; print('secondary_analysis indicators OK')"

Integration test:
python -c "
from processor.secondary_analysis.entry_indicators.indicators import (
    calculate_sma, calculate_sma_momentum, calculate_vwap,
    calculate_volume_roc, calculate_bar_delta, calculate_volume_delta,
    calculate_cvd_slope
)

# Test data
bars = [
    {'open': 100.0, 'high': 101.0, 'low': 99.0, 'close': 100.5, 'volume': 1000},
    {'open': 100.5, 'high': 102.0, 'low': 100.0, 'close': 101.5, 'volume': 1200},
    {'open': 101.5, 'high': 103.0, 'low': 101.0, 'close': 102.5, 'volume': 1100},
] * 20  # 60 bars

# Test each function
print('Testing SMA...')
sma = calculate_sma(bars)
print(f'  SMA9: {sma.sma9:.2f}, SMA21: {sma.sma21:.2f}')

print('Testing VWAP...')
vwap = calculate_vwap(bars)
print(f'  VWAP: {vwap.vwap:.2f}, Side: {vwap.side}')

print('Testing Volume ROC...')
roc = calculate_volume_roc(bars)
print(f'  ROC: {roc.roc:.2f}%')

print('Testing Bar Delta...')
delta = calculate_bar_delta(bars[-1])
print(f'  Delta: {delta:.2f}')

print('Testing CVD Slope...')
cvd = calculate_cvd_slope(bars)
print(f'  Slope: {cvd.slope:.4f}')

print('All tests OK!')
"

================================================================================
