================================================================================
STEP 3: MIGRATE 09_BACKTEST ENTRY EVENTS
================================================================================

Location: C:\XIIITradingSystems\Epoch\02_zone_system\09_backtest\processor\entry_events\
Complexity: MEDIUM - Keep class structure, delegate calculations

This module uses class-based patterns with pre-computation for efficiency.
Keep the IndicatorCalculator class structure but delegate core calculations.

================================================================================
3.1 UPDATE: indicator_calc.py
================================================================================

STEP 1: Add imports at the top of the file (after existing imports):

import sys
from pathlib import Path
_SHARED_LIB = Path(__file__).parent.parent.parent.parent.parent / "03_indicators" / "python"
sys.path.insert(0, str(_SHARED_LIB))
from core.vwap import calculate_vwap as _shared_vwap
from core.sma import calculate_sma as _shared_sma, calculate_sma_spread as _shared_sma_spread, calculate_sma_momentum as _shared_sma_momentum
from core.volume_delta import calculate_bar_delta as _shared_bar_delta
from core.volume_roc import calculate_volume_roc as _shared_volume_roc
from core.cvd import calculate_cvd_slope as _shared_cvd_slope
from config import SMA_CONFIG, VOLUME_ROC_CONFIG, VOLUME_DELTA_CONFIG, CVD_CONFIG


STEP 2: Replace the _precompute_bar_deltas() method:

FIND:
    def _precompute_bar_deltas(self):
        """Pre-compute bar deltas for CVD calculation."""
        # ... existing implementation

REPLACE WITH:
    def _precompute_bar_deltas(self):
        """Pre-compute bar deltas using shared library."""
        self.bar_deltas = []
        for bar in self.bars:
            result = _shared_bar_delta(bar.open, bar.high, bar.low, bar.close, bar.volume)
            self.bar_deltas.append(result.bar_delta)


STEP 3: Replace the calculate_vwap() method:

FIND:
    def calculate_vwap(self, bar_index: int) -> Optional[float]:
        """Calculate VWAP up to and including the specified bar index."""
        # ... existing implementation

REPLACE WITH:
    def calculate_vwap(self, bar_index: int) -> Optional[float]:
        """Calculate VWAP using shared library."""
        if bar_index < 0:
            return None
        bars = [{'high': b.high, 'low': b.low, 'close': b.close, 'volume': b.volume}
                for b in self.bars[:bar_index + 1]]
        return _shared_vwap(bars)


STEP 4: Replace the calculate_sma() method:

FIND:
    def calculate_sma(self, bar_index: int, period: int) -> Optional[float]:
        """Calculate SMA for the specified period."""
        # ... existing implementation

REPLACE WITH:
    def calculate_sma(self, bar_index: int, period: int) -> Optional[float]:
        """Calculate SMA using shared library."""
        if bar_index < period - 1:
            return None
        bars = [{'close': b.close} for b in self.bars[:bar_index + 1]]
        return _shared_sma(bars, period)


STEP 5: Replace the calculate_sma_spread_momentum() method:

FIND:
    def calculate_sma_spread_momentum(self, bar_index: int) -> dict:
        """Calculate SMA spread and momentum."""
        # ... existing implementation

REPLACE WITH:
    def calculate_sma_spread_momentum(self, bar_index: int) -> dict:
        """Calculate SMA spread and momentum using shared library."""
        bars = [{'close': b.close} for b in self.bars[:bar_index + 1]]
        spread_result = _shared_sma_spread(bars)
        momentum_result = _shared_sma_momentum(bars)

        return {
            'sma9': spread_result.sma9,
            'sma21': spread_result.sma21,
            'spread': spread_result.spread,
            'alignment': spread_result.alignment,
            'momentum': momentum_result.momentum,
            'momentum_ratio': momentum_result.ratio
        }


STEP 6: Replace the calculate_volume_roc() method:

FIND:
    def calculate_volume_roc(self, bar_index: int) -> dict:
        """Calculate Volume ROC."""
        # ... existing implementation

REPLACE WITH:
    def calculate_volume_roc(self, bar_index: int) -> dict:
        """Calculate Volume ROC using shared library."""
        bars = [{'volume': b.volume} for b in self.bars[:bar_index + 1]]
        result = _shared_volume_roc(bars, baseline_period=VOLUME_ROC_CONFIG['baseline_period'])

        # Map to existing signal format
        signal = VolumeROCSignal.AVERAGE
        if result.signal == "Above Avg":
            signal = VolumeROCSignal.ABOVE_AVG
        elif result.signal == "Below Avg":
            signal = VolumeROCSignal.BELOW_AVG

        return {
            'roc': result.roc,
            'signal': signal,
            'current_volume': result.current_volume,
            'baseline_avg': result.baseline_avg
        }


STEP 7: Replace the calculate_rolling_delta() method:

FIND:
    def calculate_rolling_delta(self, bar_index: int) -> dict:
        """Calculate rolling delta."""
        # ... existing implementation

REPLACE WITH:
    def calculate_rolling_delta(self, bar_index: int) -> dict:
        """Calculate rolling delta using pre-computed deltas for efficiency."""
        # Use pre-computed deltas for efficiency
        start_idx = max(0, bar_index - VOLUME_DELTA_CONFIG['rolling_period'] + 1)
        rolling_delta = sum(self.bar_deltas[start_idx:bar_index + 1])

        signal = VolumeDelta.NEUTRAL
        if rolling_delta > 0:
            signal = VolumeDelta.BULLISH
        elif rolling_delta < 0:
            signal = VolumeDelta.BEARISH

        return {
            'rolling_delta': rolling_delta,
            'signal': signal,
            'bar_count': bar_index - start_idx + 1
        }


STEP 8: Replace the calculate_cvd_direction() method:

FIND:
    def calculate_cvd_direction(self, bar_index: int) -> dict:
        """Calculate CVD direction."""
        # ... existing implementation

REPLACE WITH:
    def calculate_cvd_direction(self, bar_index: int) -> dict:
        """Calculate CVD direction using shared library."""
        bars = [{'open': b.open, 'high': b.high, 'low': b.low, 'close': b.close, 'volume': b.volume}
                for b in self.bars[:bar_index + 1]]
        result = _shared_cvd_slope(bars, window=CVD_CONFIG['window'])

        # Map to existing trend format
        trend = CVDTrend.FLAT
        if result.trend == "Rising":
            trend = CVDTrend.RISING
        elif result.trend == "Falling":
            trend = CVDTrend.FALLING

        return {
            'slope': result.slope,
            'trend': trend,
            'cvd_values': result.cvd_values,
            'window_size': result.window_size
        }


================================================================================
TESTING AFTER MIGRATION
================================================================================

Run from: C:\XIIITradingSystems\Epoch\02_zone_system\09_backtest\

Test commands:
python -c "from processor.entry_events.indicator_calc import IndicatorCalculator; print('entry_events indicator_calc OK')"

Integration test (if you have test data):
python -c "
from processor.entry_events.indicator_calc import IndicatorCalculator
from dataclasses import dataclass

@dataclass
class MockBar:
    open: float
    high: float
    low: float
    close: float
    volume: int
    bar_time: None = None

bars = [MockBar(100, 101, 99, 100.5, 1000) for _ in range(50)]
calc = IndicatorCalculator(bars)
print('VWAP:', calc.calculate_vwap(49))
print('SMA9:', calc.calculate_sma(49, 9))
print('OK')
"

================================================================================
