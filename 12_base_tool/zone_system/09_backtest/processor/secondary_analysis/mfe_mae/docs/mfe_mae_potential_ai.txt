================================================================================
EPOCH TRADING SYSTEM - MFE/MAE POTENTIAL CALCULATOR
AI-Readable Documentation (Complete Context for Future Conversations)
================================================================================

DOCUMENT PURPOSE:
This document provides complete context for AI assistants to understand and
work with the MFE/MAE Potential Calculator module without needing access to
the full script directory.

================================================================================
1. MODULE OVERVIEW
================================================================================

LOCATION:
C:\XIIITradingSystems\Epoch\02_zone_system\09_backtest\processor\secondary_analysis\mfe_mae\

PURPOSE:
Calculates POTENTIAL MFE (Maximum Favorable Excursion) and MAE (Maximum Adverse
Excursion) for all trades, measuring from entry time to end-of-day (15:30 ET).

KEY DISTINCTION:
- REALIZED MFE/MAE (stored in optimal_trade table): Entry to Exit
  Answers: "What happened during the trade?"

- POTENTIAL MFE/MAE (this module, stored in mfe_mae_potential table): Entry to 15:30 ET
  Answers: "What was possible in the market?"

USE CASE:
Evaluate exit timing effectiveness and identify if traders are leaving money
on the table by comparing potential vs realized profit.

================================================================================
2. FILE STRUCTURE
================================================================================

mfe_mae/
├── __init__.py                  # Package exports
├── config.py                    # Supabase + Polygon credentials, parameters
├── m1_fetcher.py               # 1-minute bar fetcher (Polygon API)
├── mfe_mae_potential_calc.py   # Core MFEMAEPotentialCalculator class
├── mfe_mae_potential_runner.py # CLI runner script
├── schema/
│   └── mfe_mae_potential.sql   # Database table schema
└── docs/
    ├── mfe_mae_potential_ai.txt    # This file
    └── mfe_mae_potential_human.txt # Human-readable documentation

================================================================================
3. DATA FLOW
================================================================================

INPUT:
- Source Table: `trades` (Supabase)
  - Required columns: trade_id, date, ticker, direction, entry_time,
                      entry_price, stop_price, pnl_r, is_winner

- External API: Polygon.io (1-minute bars)
  - Endpoint: /v2/aggs/ticker/{ticker}/range/1/minute/{date}/{date}

OUTPUT:
- Target Table: `mfe_mae_potential` (Supabase)
  - One row per trade with potential MFE/MAE metrics

PROCESS:
1. Query trades not yet in mfe_mae_potential (by trade_id)
2. Group trades by (ticker, date) to minimize API calls
3. For each group: fetch 1-minute bars from Polygon
4. Filter bars: entry_time <= bar_time <= 15:30 ET
5. Calculate MFE/MAE based on direction:
   - LONG: MFE = highest high, MAE = lowest low
   - SHORT: MFE = lowest low, MAE = highest high
6. Convert to R-multiples: (price - entry_price) / stop_distance
7. Insert results to mfe_mae_potential table

================================================================================
4. KEY CLASSES AND FUNCTIONS
================================================================================

M1Fetcher (m1_fetcher.py):
--------------------------
class M1Fetcher:
    """Fetches 1-minute bar data from Polygon.io API."""

    def __init__(self, api_key=None, rate_limit_delay=None)
    def fetch_trading_day(ticker, trade_date, start_time=None, end_time=None) -> pd.DataFrame
    def get_bars_for_trade(ticker, trade_date, entry_time, eod_time) -> pd.DataFrame
    def clear_cache()
    def get_cache_stats() -> Dict

    # Returns DataFrame with columns: timestamp, open, high, low, close, volume, vwap
    # Timestamps are in Eastern Time (ET)
    # Caches results by ticker-date to minimize API calls


MFEMAEPotentialCalculator (mfe_mae_potential_calc.py):
------------------------------------------------------
class MFEMAEPotentialCalculator:
    """Main calculator class for MFE/MAE potential."""

    def __init__(self, fetcher=None, eod_time=None, verbose=True)
    def run_batch_calculation(limit=None, dry_run=False) -> Dict[str, Any]

    # Internal methods:
    def get_trades_needing_calculation(conn, limit=None) -> pd.DataFrame
    def get_realized_mfe_mae(conn, trade_ids) -> Dict
    def calculate_single_trade(trade, bars_df) -> MFEMAEPotentialResult
    def insert_results(conn, results) -> int

    # Returns dict with: trades_processed, trades_skipped, api_calls_made,
    #                    errors, execution_time_seconds


MFEMAEPotentialResult (dataclass):
----------------------------------
@dataclass
class MFEMAEPotentialResult:
    trade_id: str
    date: date
    ticker: str
    direction: str
    model: str
    entry_time: time
    entry_price: float
    stop_price: float
    stop_distance: float
    mfe_r_potential: float
    mfe_potential_price: float
    mfe_potential_time: time
    mae_r_potential: float
    mae_potential_price: float
    mae_potential_time: time
    bars_analyzed: int
    eod_cutoff: time
    pnl_r: Optional[float]
    is_winner: Optional[bool]
    mfe_r_realized: Optional[float]
    mae_r_realized: Optional[float]

================================================================================
5. DATABASE SCHEMA
================================================================================

Table: mfe_mae_potential
------------------------
CREATE TABLE mfe_mae_potential (
    -- Primary Key
    trade_id VARCHAR(50) PRIMARY KEY,

    -- Trade Identification
    date DATE NOT NULL,
    ticker VARCHAR(10) NOT NULL,
    direction VARCHAR(10) NOT NULL,
    model VARCHAR(10),

    -- Entry Reference
    entry_time TIME NOT NULL,
    entry_price DECIMAL(12, 4) NOT NULL,
    stop_price DECIMAL(12, 4) NOT NULL,
    stop_distance DECIMAL(12, 4) NOT NULL,

    -- Potential MFE
    mfe_r_potential DECIMAL(10, 4),
    mfe_potential_price DECIMAL(12, 4),
    mfe_potential_time TIME,

    -- Potential MAE
    mae_r_potential DECIMAL(10, 4),
    mae_potential_price DECIMAL(12, 4),
    mae_potential_time TIME,

    -- Metadata
    bars_analyzed INTEGER,
    eod_cutoff TIME DEFAULT '15:30:00',

    -- Comparison
    mfe_r_realized DECIMAL(10, 4),
    mae_r_realized DECIMAL(10, 4),
    pnl_r DECIMAL(10, 4),
    is_winner BOOLEAN,

    -- System
    calculated_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    FOREIGN KEY (trade_id) REFERENCES trades(trade_id) ON DELETE CASCADE
);

================================================================================
6. CALCULATION LOGIC
================================================================================

R-MULTIPLE CALCULATION:
-----------------------
stop_distance = abs(entry_price - stop_price)  # This is 1R

For LONG trades:
    mfe_r = (highest_high - entry_price) / stop_distance
    mae_r = (entry_price - lowest_low) / stop_distance

For SHORT trades:
    mfe_r = (entry_price - lowest_low) / stop_distance
    mae_r = (highest_high - entry_price) / stop_distance

Both MFE and MAE are returned as POSITIVE values.


EXAMPLE CALCULATION:
--------------------
Trade: LONG SPY
Entry Price: $100.00
Stop Price: $99.00
Stop Distance: $1.00 (this is 1R)

Bars from entry to 15:30:
- Highest High: $102.50
- Lowest Low: $98.50

MFE Calculation:
    mfe_r = ($102.50 - $100.00) / $1.00 = +2.5R
    (Trade could have made 2.5R if held to the high)

MAE Calculation:
    mae_r = ($100.00 - $98.50) / $1.00 = +1.5R
    (Trade experienced 1.5R of heat at the worst point)


EDGE CASES HANDLED:
-------------------
1. Entry time after 15:30 ET → Skipped with warning
2. No bar data available → Skipped with warning
3. Stop distance < $0.01 → Skipped (avoids division issues)
4. Invalid direction → Skipped with warning
5. No bars in time range → Skipped with warning

================================================================================
7. CLI USAGE
================================================================================

# Create the database table (run once)
python mfe_mae_potential_runner.py --schema

# Full batch run (process all trades)
python mfe_mae_potential_runner.py

# Dry run (calculate but don't save)
python mfe_mae_potential_runner.py --dry-run

# Limited test run
python mfe_mae_potential_runner.py --limit 50

# Verbose logging
python mfe_mae_potential_runner.py --verbose

================================================================================
8. PROGRAMMATIC USAGE
================================================================================

from mfe_mae import MFEMAEPotentialCalculator, M1Fetcher

# Basic usage
calculator = MFEMAEPotentialCalculator()
results = calculator.run_batch_calculation()

# With custom options
fetcher = M1Fetcher()
calculator = MFEMAEPotentialCalculator(
    fetcher=fetcher,
    eod_time=time(15, 30),
    verbose=True
)
results = calculator.run_batch_calculation(limit=100, dry_run=False)

# Access results
print(f"Processed: {results['trades_processed']}")
print(f"Skipped: {results['trades_skipped']}")
print(f"API calls: {results['api_calls_made']}")

================================================================================
9. CONFIGURATION (config.py)
================================================================================

# Supabase
SUPABASE_HOST = "db.pdbmcskznoaiybdiobje.supabase.co"
SUPABASE_PORT = 5432
SUPABASE_DATABASE = "postgres"
SUPABASE_USER = "postgres"
SUPABASE_PASSWORD = "guid-saltation-covet"

# Polygon
POLYGON_API_KEY = "f4vzZl0gWXkv9hiKJprpsVRqbwrydf4_"
API_DELAY = 0.0  # Unlimited tier

# Trading Times (ET)
MARKET_OPEN = time(9, 30)
EOD_CUTOFF = time(15, 30)
MARKET_CLOSE = time(16, 0)

# Tables
SOURCE_TABLE = "trades"
TARGET_TABLE = "mfe_mae_potential"

================================================================================
10. INTEGRATION WITH TRADE MANAGEMENT ANALYSIS
================================================================================

The mfe_mae_potential table is designed to feed into the trade management
analysis at:
C:\XIIITradingSystems\Epoch\02_zone_system\12_indicator_analysis\calculations\trade_management\

QUERY EXAMPLES:

-- Compare potential vs realized MFE by model
SELECT
    model,
    COUNT(*) as trades,
    ROUND(AVG(mfe_r_potential), 2) as avg_mfe_potential,
    ROUND(AVG(mfe_r_realized), 2) as avg_mfe_realized,
    ROUND(AVG(mfe_r_potential - COALESCE(mfe_r_realized, 0)), 2) as avg_missed_r
FROM mfe_mae_potential
WHERE mfe_r_potential IS NOT NULL
GROUP BY model;

-- Find trades where we left significant money on the table
SELECT
    trade_id, ticker, date, model, pnl_r, mfe_r_potential,
    ROUND(mfe_r_potential - pnl_r, 2) as left_on_table
FROM mfe_mae_potential
WHERE is_winner = TRUE
  AND mfe_r_potential > pnl_r + 1.0
ORDER BY (mfe_r_potential - pnl_r) DESC;

-- MFE capture efficiency by model
SELECT
    model,
    is_winner,
    COUNT(*) as trades,
    ROUND(AVG(pnl_r / NULLIF(mfe_r_potential, 0)) * 100, 1) as pct_mfe_captured
FROM mfe_mae_potential
WHERE mfe_r_potential > 0
GROUP BY model, is_winner;

================================================================================
11. DEPENDENCIES
================================================================================

Python Packages:
- psycopg2 (PostgreSQL adapter)
- pandas (DataFrame operations)
- requests (HTTP client for Polygon API)
- pytz (Timezone handling)

External Services:
- Supabase (PostgreSQL database)
- Polygon.io (Market data API - max tier)

Related Epoch Modules:
- 09_backtest: Provides trade data in Supabase
- 12_indicator_analysis: Consumes mfe_mae_potential for analysis

================================================================================
12. VERSION HISTORY
================================================================================

v1.0.0 (2026-01-01):
- Initial implementation
- 1-minute bar fetching from Polygon
- MFE/MAE potential calculation (entry to 15:30 ET)
- Batch processing with caching
- Incremental run support (skip existing trade_ids)

================================================================================
END OF DOCUMENT
================================================================================
