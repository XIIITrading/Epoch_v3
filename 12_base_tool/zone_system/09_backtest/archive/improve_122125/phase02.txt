================================================================================
PHASE 2: UPDATE EXIT EVENTS HEALTH CALCULATION
Epoch Trading System - 10-Factor Health Score Implementation
================================================================================

OBJECTIVE:
Update the exit_events health calculation to use the same 10-factor DOW_AI 
methodology as entry_events. This ensures consistent health scoring throughout 
the trade lifecycle.

PRIORITY: Critical
EFFORT: Medium
DEPENDENCIES: Phase 1 (Column Mappings)

================================================================================
BACKGROUND
================================================================================

Current Problem:
- Entry events calculates health using 10 factors (0-10 scale)
- Exit events calculates health using 7 factors (0-7 scale)
- health_delta becomes meaningless when comparing different scales

10-Factor DOW_AI Methodology:
| Step | Factor              | Condition for Point (LONG)        |
|------|---------------------|-----------------------------------|
| 1    | H4 Structure        | H4 = BULL                         |
| 2    | H1 Structure        | H1 = BULL                         |
| 3    | M15 Structure       | M15 = BULL                        |
| 4    | M5 Structure        | M5 = BULL                         |
| 5    | Volume ROC          | > +20% vs 20-bar baseline         |
| 6    | Volume Delta        | Positive (bar_position method)    |
| 7    | CVD Direction       | Rising (slope > 0.1)              |
| 8    | SMA Alignment       | SMA9 > SMA21                      |
| 9    | SMA Spread Momentum | WIDENING                          |
| 10   | VWAP Location       | Price > VWAP                      |

================================================================================
STEP 1: CREATE HEALTH CALCULATOR V2 MODULE
================================================================================

FILE TO CREATE:
  02_zone_system/09_backtest/processor/exit_events/health_calculator_v2.py

This module provides the 10-factor health calculation for exit events,
matching the DOW_AI methodology used in entry_events.

--------------------------------------------------------------------------------
FILE: health_calculator_v2.py
--------------------------------------------------------------------------------

"""
================================================================================
EPOCH TRADING SYSTEM - HEALTH CALCULATOR V2
10-Factor DOW_AI Health Score for Exit Events
XIII Trading LLC
Version: 2.0.0
================================================================================

Calculates health score using the same 10-factor methodology as entry_events.
This ensures consistent health scoring throughout the trade lifecycle.

FACTORS (10 total):
1-4:  Multi-timeframe structure (H4, H1, M15, M5)
5-7:  Volume analysis (ROC, Delta, CVD)
8-9:  SMA analysis (Alignment, Spread Momentum)
10:   VWAP location

================================================================================
"""

from dataclasses import dataclass
from typing import Optional, List
from enum import Enum


class HealthLabel(Enum):
    """Health score classifications"""
    STRONG = "STRONG"      # 8-10
    MODERATE = "MODERATE"  # 6-7
    WEAK = "WEAK"          # 4-5
    CRITICAL = "CRITICAL"  # 0-3


@dataclass
class HealthScoreV2:
    """
    10-factor health score result.
    """
    # Overall score
    score: int                    # 0-10
    max_score: int = 10
    
    # Individual factor results (True = healthy/aligned)
    h4_structure_healthy: bool = False
    h1_structure_healthy: bool = False
    m15_structure_healthy: bool = False
    m5_structure_healthy: bool = False
    volume_roc_healthy: bool = False
    volume_delta_healthy: bool = False
    cvd_healthy: bool = False
    sma_alignment_healthy: bool = False
    sma_momentum_healthy: bool = False
    vwap_healthy: bool = False
    
    # Alignment groups
    htf_aligned: bool = False     # H4 + H1 both healthy
    mtf_aligned: bool = False     # M15 + M5 both healthy
    volume_aligned: bool = False  # All 3 volume factors healthy
    indicator_aligned: bool = False  # SMA + VWAP healthy
    
    @property
    def score_pct(self) -> float:
        """Score as percentage"""
        return (self.score / self.max_score) * 100
    
    @property
    def label(self) -> str:
        """Get health label based on score"""
        if self.score >= 8:
            return HealthLabel.STRONG.value
        elif self.score >= 6:
            return HealthLabel.MODERATE.value
        elif self.score >= 4:
            return HealthLabel.WEAK.value
        else:
            return HealthLabel.CRITICAL.value


class HealthCalculatorV2:
    """
    Calculates 10-factor health score aligned with DOW_AI methodology.
    """
    
    # Thresholds matching entry_events
    VOLUME_ROC_THRESHOLD = 20.0       # +20% = Above Avg
    CVD_SLOPE_THRESHOLD = 0.1         # Normalized slope threshold
    SMA_MOMENTUM_RATIO = 1.1          # 10% increase = WIDENING
    
    def __init__(self, verbose: bool = False):
        self.verbose = verbose
    
    def calculate(
        self,
        direction: str,
        price: float,
        # Structure (Steps 1-4)
        h4_structure: str,
        h1_structure: str,
        m15_structure: str,
        m5_structure: str,
        # Volume (Steps 5-7)
        volume: float,
        volume_baseline: float,
        bar_delta: float,
        cvd_slope: float,
        # SMA (Steps 8-9)
        sma9: Optional[float],
        sma21: Optional[float],
        sma_spread_prev: Optional[float],
        # VWAP (Step 10)
        vwap: Optional[float],
    ) -> HealthScoreV2:
        """
        Calculate 10-factor health score.
        
        Args:
            direction: "LONG" or "SHORT"
            price: Current close price
            h4_structure: H4 direction ("BULL", "BEAR", "NEUTRAL")
            h1_structure: H1 direction
            m15_structure: M15 direction
            m5_structure: M5 direction
            volume: Current bar volume
            volume_baseline: 20-bar average volume
            bar_delta: Volume delta using bar_position method
            cvd_slope: Normalized CVD slope
            sma9: 9-period SMA value
            sma21: 21-period SMA value
            sma_spread_prev: SMA spread from N bars ago (for momentum)
            vwap: VWAP value
            
        Returns:
            HealthScoreV2 with all factor results
        """
        is_long = direction.upper() == "LONG"
        target_structure = "BULL" if is_long else "BEAR"
        
        # Initialize result
        result = HealthScoreV2(score=0)
        
        # =================================================================
        # STEPS 1-4: MULTI-TIMEFRAME STRUCTURE (4 points)
        # =================================================================
        
        # Step 1: H4 Structure
        result.h4_structure_healthy = (h4_structure == target_structure)
        if result.h4_structure_healthy:
            result.score += 1
        
        # Step 2: H1 Structure
        result.h1_structure_healthy = (h1_structure == target_structure)
        if result.h1_structure_healthy:
            result.score += 1
        
        # Step 3: M15 Structure
        result.m15_structure_healthy = (m15_structure == target_structure)
        if result.m15_structure_healthy:
            result.score += 1
        
        # Step 4: M5 Structure
        result.m5_structure_healthy = (m5_structure == target_structure)
        if result.m5_structure_healthy:
            result.score += 1
        
        # =================================================================
        # STEPS 5-7: VOLUME ANALYSIS (3 points)
        # =================================================================
        
        # Step 5: Volume ROC
        vol_roc = 0.0
        if volume_baseline and volume_baseline > 0:
            vol_roc = ((volume - volume_baseline) / volume_baseline) * 100
        
        result.volume_roc_healthy = (vol_roc > self.VOLUME_ROC_THRESHOLD)
        if result.volume_roc_healthy:
            result.score += 1
        
        # Step 6: Volume Delta (using bar_position method)
        # For LONG: positive delta is healthy
        # For SHORT: negative delta is healthy
        if is_long:
            result.volume_delta_healthy = (bar_delta > 0)
        else:
            result.volume_delta_healthy = (bar_delta < 0)
        
        if result.volume_delta_healthy:
            result.score += 1
        
        # Step 7: CVD Direction
        # For LONG: rising CVD (slope > 0.1) is healthy
        # For SHORT: falling CVD (slope < -0.1) is healthy
        if is_long:
            result.cvd_healthy = (cvd_slope > self.CVD_SLOPE_THRESHOLD)
        else:
            result.cvd_healthy = (cvd_slope < -self.CVD_SLOPE_THRESHOLD)
        
        if result.cvd_healthy:
            result.score += 1
        
        # =================================================================
        # STEPS 8-9: SMA ANALYSIS (2 points)
        # =================================================================
        
        # Step 8: SMA Alignment
        if sma9 is not None and sma21 is not None:
            if is_long:
                result.sma_alignment_healthy = (sma9 > sma21)
            else:
                result.sma_alignment_healthy = (sma9 < sma21)
            
            if result.sma_alignment_healthy:
                result.score += 1
        
        # Step 9: SMA Spread Momentum
        if sma9 is not None and sma21 is not None and sma_spread_prev is not None:
            current_spread = abs(sma9 - sma21)
            prev_spread = abs(sma_spread_prev)
            
            # WIDENING = current spread > prev spread * 1.1
            if prev_spread > 0:
                result.sma_momentum_healthy = (current_spread > prev_spread * self.SMA_MOMENTUM_RATIO)
            else:
                result.sma_momentum_healthy = (current_spread > 0)
            
            if result.sma_momentum_healthy:
                result.score += 1
        
        # =================================================================
        # STEP 10: VWAP LOCATION (1 point)
        # =================================================================
        
        if vwap is not None:
            if is_long:
                result.vwap_healthy = (price > vwap)
            else:
                result.vwap_healthy = (price < vwap)
            
            if result.vwap_healthy:
                result.score += 1
        
        # =================================================================
        # ALIGNMENT GROUPS
        # =================================================================
        
        result.htf_aligned = result.h4_structure_healthy and result.h1_structure_healthy
        result.mtf_aligned = result.m15_structure_healthy and result.m5_structure_healthy
        result.volume_aligned = (result.volume_roc_healthy and 
                                 result.volume_delta_healthy and 
                                 result.cvd_healthy)
        result.indicator_aligned = (result.sma_alignment_healthy and 
                                    result.vwap_healthy)
        
        if self.verbose:
            self._print_breakdown(result, direction)
        
        return result
    
    def _print_breakdown(self, result: HealthScoreV2, direction: str):
        """Print health score breakdown for debugging."""
        print(f"\n  Health Score Breakdown ({direction}):")
        print(f"  {'─' * 40}")
        print(f"  H4 Structure:    {'✓' if result.h4_structure_healthy else '✗'}")
        print(f"  H1 Structure:    {'✓' if result.h1_structure_healthy else '✗'}")
        print(f"  M15 Structure:   {'✓' if result.m15_structure_healthy else '✗'}")
        print(f"  M5 Structure:    {'✓' if result.m5_structure_healthy else '✗'}")
        print(f"  Volume ROC:      {'✓' if result.volume_roc_healthy else '✗'}")
        print(f"  Volume Delta:    {'✓' if result.volume_delta_healthy else '✗'}")
        print(f"  CVD Direction:   {'✓' if result.cvd_healthy else '✗'}")
        print(f"  SMA Alignment:   {'✓' if result.sma_alignment_healthy else '✗'}")
        print(f"  SMA Momentum:    {'✓' if result.sma_momentum_healthy else '✗'}")
        print(f"  VWAP Location:   {'✓' if result.vwap_healthy else '✗'}")
        print(f"  {'─' * 40}")
        print(f"  TOTAL: {result.score}/10 ({result.label})")
    
    @staticmethod
    def calculate_bar_delta(open_price: float, high: float, low: float, 
                           close: float, volume: float) -> float:
        """
        Calculate volume delta using bar_position method.
        
        bar_position = (close - low) / (high - low)  # 0 to 1
        delta_multiplier = (2 * bar_position) - 1     # -1 to 1
        bar_delta = volume * delta_multiplier
        
        Args:
            open_price: Bar open
            high: Bar high
            low: Bar low
            close: Bar close
            volume: Bar volume
            
        Returns:
            Bar delta (positive = bullish, negative = bearish)
        """
        bar_range = high - low
        if bar_range == 0:
            return 0.0
        
        bar_position = (close - low) / bar_range
        delta_multiplier = (2 * bar_position) - 1
        return volume * delta_multiplier
    
    @staticmethod
    def calculate_cvd_slope(bar_deltas: List[float], window: int = 15) -> float:
        """
        Calculate normalized CVD slope.
        
        Args:
            bar_deltas: List of recent bar deltas
            window: Number of bars for slope calculation
            
        Returns:
            Normalized slope (-1 to 1 range)
        """
        if len(bar_deltas) < 2:
            return 0.0
        
        # Take last N values
        recent = bar_deltas[-window:] if len(bar_deltas) >= window else bar_deltas
        
        # Calculate cumulative volume delta
        cvd = []
        cumsum = 0
        for delta in recent:
            cumsum += delta
            cvd.append(cumsum)
        
        if len(cvd) < 2:
            return 0.0
        
        # Simple linear regression slope
        n = len(cvd)
        x_mean = (n - 1) / 2
        y_mean = sum(cvd) / n
        
        numerator = sum((i - x_mean) * (cvd[i] - y_mean) for i in range(n))
        denominator = sum((i - x_mean) ** 2 for i in range(n))
        
        if denominator == 0:
            return 0.0
        
        slope = numerator / denominator
        
        # Normalize by CVD range
        cvd_range = max(cvd) - min(cvd) if cvd else 1
        if cvd_range == 0:
            return 0.0
        
        normalized_slope = slope / cvd_range
        
        # Clamp to -1 to 1
        return max(-1.0, min(1.0, normalized_slope))


if __name__ == "__main__":
    print("Health Calculator V2 - 10-Factor DOW_AI Methodology")
    print("\nFactors:")
    print("  1. H4 Structure")
    print("  2. H1 Structure")
    print("  3. M15 Structure")
    print("  4. M5 Structure")
    print("  5. Volume ROC (>+20%)")
    print("  6. Volume Delta (bar_position method)")
    print("  7. CVD Direction (slope threshold ±0.1)")
    print("  8. SMA Alignment (SMA9 vs SMA21)")
    print("  9. SMA Spread Momentum (WIDENING)")
    print("  10. VWAP Location")
    print("\nHealth Labels:")
    print("  STRONG:   8-10")
    print("  MODERATE: 6-7")
    print("  WEAK:     4-5")
    print("  CRITICAL: 0-3")


================================================================================
STEP 2: UPDATE exit_event_tracker.py TO USE NEW CALCULATOR
================================================================================

FILE TO MODIFY:
  02_zone_system/09_backtest/processor/exit_events/exit_event_tracker.py

--------------------------------------------------------------------------------
ADD IMPORT at top of file (after other imports):
--------------------------------------------------------------------------------

from health_calculator_v2 import HealthCalculatorV2, HealthScoreV2

--------------------------------------------------------------------------------
FIND the __init__ method of ExitEventTracker class (around line 180):
--------------------------------------------------------------------------------

    def __init__(self, 
                 api_key: str,
                 m5_fetcher=None,
                 entry_events_lookup: Optional[EntryEventsLookup] = None,
                 confirmation_bars: int = 2,
                 verbose: bool = True,
                 api_delay: float = 0.25):
        ...
        # Health calculator for bar-by-bar updates (uses same logic as entry_events)
        self.health_calc = HealthScoreCalculator(verbose=False)

--------------------------------------------------------------------------------
REPLACE health calculator initialization with:
--------------------------------------------------------------------------------

        # Health calculator V2 for bar-by-bar updates (10-factor DOW_AI methodology)
        self.health_calc = HealthCalculatorV2(verbose=False)
        
        # Track bar deltas for CVD calculation
        self._bar_deltas: List[float] = []
        self._sma_spread_history: List[float] = []

--------------------------------------------------------------------------------
FIND the _calculate_health_at_bar method (around line 230):
--------------------------------------------------------------------------------

    def _calculate_health_at_bar(self, direction: str, price: float,
                                  vwap: float, sma9: float, sma21: float,
                                  m5_structure: str, m15_structure: str,
                                  volume_trend: str) -> int:
        """
        Calculate health score at a specific bar using the same logic as entry_events.
        """
        m5_dir = self._structure_to_direction(m5_structure)
        m15_dir = self._structure_to_direction(m15_structure)
        
        vol_trend = volume_trend
        if volume_trend == "NORMAL":
            vol_trend = "FLAT"
        
        health = self.health_calc.calculate(
            direction=direction,
            entry_price=price,
            vwap=vwap,
            sma9=sma9,
            sma21=sma21,
            m5_structure=m5_dir,
            m15_structure=m15_dir,
            volume_trend=vol_trend
        )
        
        return health.score

--------------------------------------------------------------------------------
REPLACE WITH (complete new method):
--------------------------------------------------------------------------------

    def _calculate_health_at_bar(
        self, 
        direction: str, 
        price: float,
        # Indicators
        vwap: float, 
        sma9: float, 
        sma21: float,
        # Volume
        volume: float,
        volume_baseline: float,
        bar: object,  # M5 bar object with OHLC
        # Structure
        m5_structure: str, 
        m15_structure: str,
        h1_structure: str,
        h4_structure: str,
    ) -> int:
        """
        Calculate 10-factor health score at a specific bar.
        Uses the same DOW_AI methodology as entry_events.
        
        Args:
            direction: Trade direction ("LONG" or "SHORT")
            price: Current close price
            vwap: VWAP value
            sma9: 9-period SMA
            sma21: 21-period SMA
            volume: Current bar volume
            volume_baseline: 20-bar average volume
            bar: M5 bar object with OHLC data
            m5_structure: M5 structure direction
            m15_structure: M15 structure direction
            h1_structure: H1 structure direction
            h4_structure: H4 structure direction
            
        Returns:
            Health score (0-10)
        """
        # Calculate bar delta using bar_position method
        bar_delta = HealthCalculatorV2.calculate_bar_delta(
            open_price=bar.open,
            high=bar.high,
            low=bar.low,
            close=bar.close,
            volume=bar.volume
        )
        
        # Track bar deltas for CVD
        self._bar_deltas.append(bar_delta)
        
        # Calculate CVD slope
        cvd_slope = HealthCalculatorV2.calculate_cvd_slope(self._bar_deltas, window=15)
        
        # Calculate SMA spread for momentum
        current_spread = (sma9 - sma21) if sma9 and sma21 else 0
        self._sma_spread_history.append(current_spread)
        
        # Get previous spread (10 bars ago)
        sma_spread_prev = None
        if len(self._sma_spread_history) > 10:
            sma_spread_prev = self._sma_spread_history[-11]
        
        # Calculate health using V2 calculator
        health_result = self.health_calc.calculate(
            direction=direction,
            price=price,
            # Structure
            h4_structure=h4_structure,
            h1_structure=h1_structure,
            m15_structure=m15_structure,
            m5_structure=m5_structure,
            # Volume
            volume=volume,
            volume_baseline=volume_baseline,
            bar_delta=bar_delta,
            cvd_slope=cvd_slope,
            # SMA
            sma9=sma9,
            sma21=sma21,
            sma_spread_prev=sma_spread_prev,
            # VWAP
            vwap=vwap,
        )
        
        return health_result.score
    
    def _reset_health_tracking(self):
        """Reset bar delta and SMA spread history for new trade."""
        self._bar_deltas = []
        self._sma_spread_history = []


================================================================================
STEP 3: UPDATE process_trade METHOD TO PASS NEW PARAMETERS
================================================================================

In the process_trade method, find where _calculate_health_at_bar is called
and update it to pass the new parameters.

--------------------------------------------------------------------------------
FIND this section in process_trade (around line 380-400):
--------------------------------------------------------------------------------

            # Calculate health score at this bar
            health = self._calculate_health_at_bar(
                direction, bar.close,
                vwap, sma9, sma21,
                structure_states['m5'],
                structure_states['m15'],
                volume_state
            )

--------------------------------------------------------------------------------
REPLACE WITH:
--------------------------------------------------------------------------------

            # Get volume baseline (20-bar average)
            if bar_idx >= 20:
                volume_baseline = sum(bars[i].volume for i in range(bar_idx - 19, bar_idx + 1)) / 20
            else:
                volume_baseline = sum(bars[i].volume for i in range(0, bar_idx + 1)) / (bar_idx + 1)
            
            # Calculate health score at this bar (10-factor DOW_AI)
            health = self._calculate_health_at_bar(
                direction=direction, 
                price=bar.close,
                vwap=vwap, 
                sma9=sma9, 
                sma21=sma21,
                volume=bar.volume,
                volume_baseline=volume_baseline,
                bar=bar,
                m5_structure=structure_states['m5'],
                m15_structure=structure_states['m15'],
                h1_structure=structure_states.get('h1', 'NEUTRAL'),
                h4_structure=structure_states.get('h4', 'NEUTRAL'),
            )

--------------------------------------------------------------------------------
ALSO: Add reset call at the start of process_trade (after getting trade data):
--------------------------------------------------------------------------------

    def process_trade(self, trade_data: Dict) -> List[ExitEvent]:
        """
        Process a single trade and generate all exit events.
        """
        events = []
        
        # Reset health tracking for new trade
        self._reset_health_tracking()
        
        ticker = trade_data['ticker']
        ...


================================================================================
STEP 4: UPDATE MultiTimeframeSwingDetector TO TRACK H4
================================================================================

The current swing_detector.py aggregates M5 into M15 and H1, but doesn't 
track H4. We need to either:
A) Fetch H4 structure from the entry_events lookup, or
B) Add H4 aggregation to the swing detector

RECOMMENDED: Use H4 from entry_events (simpler, H4 rarely changes intraday)

--------------------------------------------------------------------------------
UPDATE process_trade to get H4 from entry_events:
--------------------------------------------------------------------------------

    def process_trade(self, trade_data: Dict) -> List[ExitEvent]:
        ...
        # Get H4 structure from entry_events (doesn't change during trade)
        entry_data = self.entry_lookup.get_entry_data(trade_id)
        h4_structure = entry_data.get('h4_structure', 'NEUTRAL') if entry_data else 'NEUTRAL'
        h1_structure_entry = entry_data.get('h1_structure', 'NEUTRAL') if entry_data else 'NEUTRAL'
        
        # Use entry H4/H1 as baseline (these rarely change intraday)
        ...


================================================================================
STEP 5: UPDATE __init__.py TO EXPORT NEW CLASSES
================================================================================

FILE TO MODIFY:
  02_zone_system/09_backtest/processor/exit_events/__init__.py

--------------------------------------------------------------------------------
ADD to imports:
--------------------------------------------------------------------------------

from .health_calculator_v2 import (
    HealthCalculatorV2,
    HealthScoreV2,
    HealthLabel,
)

--------------------------------------------------------------------------------
ADD to __all__ list:
--------------------------------------------------------------------------------

__all__ = [
    # ... existing exports ...
    
    # Health Calculator V2
    'HealthCalculatorV2',
    'HealthScoreV2',
    'HealthLabel',
]


================================================================================
VERIFICATION
================================================================================

After implementing these changes:

1. Test health calculation:
   python -c "from health_calculator_v2 import HealthCalculatorV2; print('OK')"

2. Run exit_runner.py and verify:
   - Health scores now range 0-10 (not 0-7)
   - health_delta is meaningful (both entry and bar health on same scale)

3. Check a few trades manually:
   - Entry health from entry_events: e.g., 7/10
   - Bar health during trade: e.g., 5/10
   - health_delta should be: -2 (5 - 7)

================================================================================
END OF PHASE 2
================================================================================