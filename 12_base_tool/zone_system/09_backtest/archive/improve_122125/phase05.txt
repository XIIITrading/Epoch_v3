================================================================================
PHASE 5: UPDATE OPTIMAL TRADE FOR DECAY ANALYSIS
Epoch Trading System - Post-MFE Trade Deterioration Analysis
================================================================================

OBJECTIVE:
Enhance the optimal_trade module to specifically analyze trade decay after
Maximum Favorable Excursion (MFE). The goal is to identify:
1. When does the trade start losing traction?
2. Which indicator changes first after MFE?
3. What's the optimal exit signal to capture the most R?

PRIORITY: High
EFFORT: High
DEPENDENCIES: Phases 1-4

================================================================================
CONCEPT: POST-MFE DECAY ANALYSIS
================================================================================

KEY INSIGHT:
Every trade that doesn't exit at MFE "gives back" some profit. We want to know:
- HOW MUCH did we give back? (R at MFE - R at exit)
- WHEN did decay start? (first negative event after MFE)
- WHICH indicator signaled decay first?
- Would exiting on that signal have been better?

ANALYSIS FOCUS:
Only bars AFTER MFE are relevant for exit optimization.
Bars before MFE are "the trade working" - not interesting for exit analysis.

NEW COLUMNS FOR DECAY ANALYSIS:
| Col | Name                | Description                            |
|-----|---------------------|----------------------------------------|
| -   | is_post_mfe         | 1 if this bar is after MFE             |
| -   | bars_after_mfe      | How many bars since MFE (0 at MFE)     |
| -   | r_given_back        | MFE_R - R_at_this_bar                  |
| -   | health_at_mfe       | What was health when MFE occurred      |
| -   | health_decay        | health_at_mfe - health_at_bar          |
| -   | first_flip_event    | Event type of first negative change    |
| -   | first_flip_bar      | Bars after MFE when first flip         |
| -   | r_at_first_flip     | What R was at first flip point         |
| -   | would_be_better     | 1 if exiting at flip > actual exit     |

================================================================================
STEP 1: CREATE DECAY ANALYZER MODULE
================================================================================

FILE TO CREATE:
  02_zone_system/09_backtest/processor/optimal_trade/decay_analyzer.py

This module analyzes post-MFE trade decay patterns.

--------------------------------------------------------------------------------
FILE: decay_analyzer.py
--------------------------------------------------------------------------------

"""
================================================================================
EPOCH TRADING SYSTEM - DECAY ANALYZER
Post-MFE Trade Deterioration Analysis
XIII Trading LLC
Version: 1.0.0
================================================================================

Analyzes trade behavior after Maximum Favorable Excursion (MFE).
Identifies which indicators flip first and calculates optimal exit points.

KEY CONCEPTS:
- "Decay" = Giving back profit after MFE
- "First Flip" = First indicator to change unfavorably after MFE
- "Would Be Better" = Exiting at flip would capture more R than actual exit

================================================================================
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple
from enum import Enum


class DecaySignal(Enum):
    """
    Indicators that can signal trade decay.
    Ordered by typical significance (most to least).
    """
    # Structure signals (most significant)
    M5_STRUCTURE_FLIP = "M5_STRUCTURE_FLIP"
    M15_STRUCTURE_FLIP = "M15_STRUCTURE_FLIP"
    H1_STRUCTURE_FLIP = "H1_STRUCTURE_FLIP"
    
    # Swing signals
    LOWER_HIGH = "LOWER_HIGH"         # For longs
    HIGHER_LOW = "HIGHER_LOW"         # For shorts
    LOWER_LOW = "LOWER_LOW"           # For longs (worse)
    HIGHER_HIGH = "HIGHER_HIGH"       # For shorts (worse)
    
    # Indicator signals
    VWAP_LOST = "VWAP_LOST"
    SMA9_LOST = "SMA9_LOST"
    SMA21_LOST = "SMA21_LOST"
    SMA_CROSS_AGAINST = "SMA_CROSS_AGAINST"
    SMA_SPREAD_NARROW = "SMA_SPREAD_NARROW"
    
    # Volume signals
    VOL_DELTA_FLIP = "VOL_DELTA_FLIP"
    CVD_FLIP = "CVD_FLIP"
    VOL_ROC_DROP = "VOL_ROC_DROP"
    
    # Health threshold signals
    HEALTH_DROP_1 = "HEALTH_DROP_1"
    HEALTH_DROP_2 = "HEALTH_DROP_2"
    HEALTH_DROP_3 = "HEALTH_DROP_3"


@dataclass
class DecayEvent:
    """Single decay event after MFE."""
    bars_after_mfe: int
    event_type: str
    r_at_event: float
    health_at_event: int
    health_delta: int  # vs MFE health
    r_given_back: float  # MFE_R - r_at_event
    is_negative_for_trade: bool  # True if this hurts the trade


@dataclass
class TradeDecayAnalysis:
    """
    Complete decay analysis for a single trade.
    """
    trade_id: str
    direction: str
    
    # MFE reference point
    mfe_bar_seq: int
    mfe_r: float
    mfe_health: int
    
    # Actual exit
    actual_exit_bar: int
    actual_r: float
    actual_health: int
    total_bars_in_trade: int
    
    # Decay metrics
    r_given_back: float           # MFE_R - actual_R
    pct_captured: float           # actual_R / MFE_R * 100
    bars_from_mfe_to_exit: int
    
    # First flip analysis
    first_flip_event: Optional[str] = None
    first_flip_bar: Optional[int] = None  # Bars after MFE
    first_flip_r: Optional[float] = None
    first_flip_health: Optional[int] = None
    
    # Would exiting at first flip be better?
    first_flip_r_given_back: Optional[float] = None  # MFE_R - first_flip_R
    would_be_better: bool = False
    r_improvement: float = 0.0  # first_flip_R - actual_R
    
    # All decay events
    decay_events: List[DecayEvent] = field(default_factory=list)
    
    # Summary flags
    had_warning_before_exit: bool = False
    warnings_ignored: int = 0


class DecayAnalyzer:
    """
    Analyzes post-MFE trade decay to identify optimal exit signals.
    """
    
    # Events that are negative for LONG trades
    LONG_NEGATIVE_EVENTS = {
        'LOWER_HIGH', 'LOWER_LOW',
        'M5_FLIP_BEAR', 'M15_FLIP_BEAR', 'H1_FLIP_BEAR', 'H4_FLIP_BEAR',
        'VWAP_LOST', 'SMA9_LOST', 'SMA21_LOST', 'SMA_CROSS_BEAR',
        'SMA_SPREAD_NARROW',
        'VOL_DELTA_BEAR', 'CVD_FALLING', 'VOL_ROC_BELOW',
    }
    
    # Events that are negative for SHORT trades
    SHORT_NEGATIVE_EVENTS = {
        'HIGHER_LOW', 'HIGHER_HIGH',
        'M5_FLIP_BULL', 'M15_FLIP_BULL', 'H1_FLIP_BULL', 'H4_FLIP_BULL',
        'VWAP_LOST', 'SMA9_LOST', 'SMA21_LOST', 'SMA_CROSS_BULL',
        'SMA_SPREAD_NARROW',
        'VOL_DELTA_BULL', 'CVD_RISING', 'VOL_ROC_BELOW',
    }
    
    def __init__(self, verbose: bool = False):
        self.verbose = verbose
    
    def analyze_trade(
        self,
        trade_id: str,
        direction: str,
        exit_events: List[Dict],
        mfe_r: float,
        actual_r: float,
    ) -> TradeDecayAnalysis:
        """
        Analyze decay pattern for a single trade.
        
        Args:
            trade_id: Trade identifier
            direction: "LONG" or "SHORT"
            exit_events: List of exit event dicts (sorted by event_seq)
            mfe_r: R at MFE
            actual_r: Final R at exit
            
        Returns:
            TradeDecayAnalysis with complete breakdown
        """
        is_long = direction.upper() == "LONG"
        negative_events = self.LONG_NEGATIVE_EVENTS if is_long else self.SHORT_NEGATIVE_EVENTS
        
        # Find MFE and EXIT events
        mfe_event = None
        exit_event = None
        
        for event in exit_events:
            if event.get('event_type') == 'MFE':
                mfe_event = event
            elif event.get('event_type') == 'EXIT':
                exit_event = event
        
        if mfe_event is None:
            # No MFE found - trade never went positive
            return self._create_no_mfe_analysis(trade_id, direction, exit_events, actual_r)
        
        mfe_bar_seq = mfe_event.get('event_seq', 0)
        mfe_health = mfe_event.get('health_score', 0)
        
        exit_bar_seq = exit_event.get('event_seq', 0) if exit_event else len(exit_events)
        actual_health = exit_event.get('health_score', 0) if exit_event else 0
        
        # Collect post-MFE events
        post_mfe_events = [e for e in exit_events if e.get('event_seq', 0) > mfe_bar_seq]
        
        # Identify decay events (negative for trade direction)
        decay_events = []
        first_flip_event = None
        
        for event in post_mfe_events:
            event_type = event.get('event_type', '')
            
            if event_type in negative_events:
                bars_after_mfe = event.get('event_seq', 0) - mfe_bar_seq
                r_at_event = event.get('r_at_event', 0)
                health = event.get('health_score', 0)
                
                decay_event = DecayEvent(
                    bars_after_mfe=bars_after_mfe,
                    event_type=event_type,
                    r_at_event=r_at_event,
                    health_at_event=health,
                    health_delta=health - mfe_health,
                    r_given_back=mfe_r - r_at_event,
                    is_negative_for_trade=True
                )
                decay_events.append(decay_event)
                
                # Track first flip
                if first_flip_event is None:
                    first_flip_event = decay_event
        
        # Calculate metrics
        r_given_back = mfe_r - actual_r
        pct_captured = (actual_r / mfe_r * 100) if mfe_r > 0 else 0
        bars_from_mfe_to_exit = exit_bar_seq - mfe_bar_seq
        
        # First flip analysis
        first_flip_r_given_back = None
        would_be_better = False
        r_improvement = 0.0
        
        if first_flip_event:
            first_flip_r_given_back = mfe_r - first_flip_event.r_at_event
            
            # Would exiting at first flip capture more R?
            if first_flip_event.r_at_event > actual_r:
                would_be_better = True
                r_improvement = first_flip_event.r_at_event - actual_r
        
        analysis = TradeDecayAnalysis(
            trade_id=trade_id,
            direction=direction,
            mfe_bar_seq=mfe_bar_seq,
            mfe_r=mfe_r,
            mfe_health=mfe_health,
            actual_exit_bar=exit_bar_seq,
            actual_r=actual_r,
            actual_health=actual_health,
            total_bars_in_trade=exit_bar_seq,
            r_given_back=r_given_back,
            pct_captured=pct_captured,
            bars_from_mfe_to_exit=bars_from_mfe_to_exit,
            first_flip_event=first_flip_event.event_type if first_flip_event else None,
            first_flip_bar=first_flip_event.bars_after_mfe if first_flip_event else None,
            first_flip_r=first_flip_event.r_at_event if first_flip_event else None,
            first_flip_health=first_flip_event.health_at_event if first_flip_event else None,
            first_flip_r_given_back=first_flip_r_given_back,
            would_be_better=would_be_better,
            r_improvement=r_improvement,
            decay_events=decay_events,
            had_warning_before_exit=len(decay_events) > 0,
            warnings_ignored=len(decay_events),
        )
        
        if self.verbose:
            self._print_analysis(analysis)
        
        return analysis
    
    def _create_no_mfe_analysis(
        self,
        trade_id: str,
        direction: str,
        exit_events: List[Dict],
        actual_r: float,
    ) -> TradeDecayAnalysis:
        """Create analysis for trade that never had positive MFE."""
        exit_event = None
        for event in exit_events:
            if event.get('event_type') == 'EXIT':
                exit_event = event
                break
        
        return TradeDecayAnalysis(
            trade_id=trade_id,
            direction=direction,
            mfe_bar_seq=0,
            mfe_r=0,
            mfe_health=0,
            actual_exit_bar=exit_event.get('event_seq', 0) if exit_event else 0,
            actual_r=actual_r,
            actual_health=exit_event.get('health_score', 0) if exit_event else 0,
            total_bars_in_trade=len(exit_events),
            r_given_back=0,
            pct_captured=0,
            bars_from_mfe_to_exit=0,
            decay_events=[],
            had_warning_before_exit=False,
            warnings_ignored=0,
        )
    
    def _print_analysis(self, analysis: TradeDecayAnalysis):
        """Print analysis summary."""
        print(f"\n  Decay Analysis: {analysis.trade_id}")
        print(f"  {'─' * 50}")
        print(f"  MFE: {analysis.mfe_r:.2f}R at bar {analysis.mfe_bar_seq}")
        print(f"  Exit: {analysis.actual_r:.2f}R at bar {analysis.actual_exit_bar}")
        print(f"  R Given Back: {analysis.r_given_back:.2f}R ({100 - analysis.pct_captured:.1f}%)")
        
        if analysis.first_flip_event:
            print(f"\n  First Warning: {analysis.first_flip_event}")
            print(f"    Bars after MFE: {analysis.first_flip_bar}")
            print(f"    R at warning: {analysis.first_flip_r:.2f}R")
            if analysis.would_be_better:
                print(f"    ✓ Would have saved: {analysis.r_improvement:.2f}R")
            else:
                print(f"    ✗ Exit was better than warning")
        
        print(f"\n  Total Warnings Ignored: {analysis.warnings_ignored}")
    
    def get_best_exit_signal(
        self,
        analyses: List[TradeDecayAnalysis],
    ) -> Dict:
        """
        Determine which exit signal would perform best across all trades.
        
        Args:
            analyses: List of TradeDecayAnalysis objects
            
        Returns:
            Dict with signal performance rankings
        """
        signal_stats = {}
        
        for analysis in analyses:
            for event in analysis.decay_events:
                event_type = event.event_type
                
                if event_type not in signal_stats:
                    signal_stats[event_type] = {
                        'count': 0,
                        'total_r_saved': 0.0,
                        'would_be_better_count': 0,
                        'avg_bars_after_mfe': 0.0,
                    }
                
                stats = signal_stats[event_type]
                stats['count'] += 1
                
                # Calculate R saved if exited at this signal
                r_at_signal = event.r_at_event
                actual_r = analysis.actual_r
                
                if r_at_signal > actual_r:
                    stats['would_be_better_count'] += 1
                    stats['total_r_saved'] += (r_at_signal - actual_r)
                
                stats['avg_bars_after_mfe'] += event.bars_after_mfe
        
        # Calculate averages
        for event_type, stats in signal_stats.items():
            if stats['count'] > 0:
                stats['avg_bars_after_mfe'] /= stats['count']
                stats['avg_r_saved'] = stats['total_r_saved'] / stats['count']
                stats['improvement_rate'] = stats['would_be_better_count'] / stats['count'] * 100
        
        # Sort by improvement rate
        ranked = sorted(
            signal_stats.items(),
            key=lambda x: x[1].get('improvement_rate', 0),
            reverse=True
        )
        
        return {
            'ranked_signals': ranked,
            'total_trades_analyzed': len(analyses),
        }


if __name__ == "__main__":
    print("Decay Analyzer Module")
    print("\nNegative events for LONG trades:")
    for event in sorted(DecayAnalyzer.LONG_NEGATIVE_EVENTS):
        print(f"  - {event}")
    print("\nNegative events for SHORT trades:")
    for event in sorted(DecayAnalyzer.SHORT_NEGATIVE_EVENTS):
        print(f"  - {event}")


================================================================================
STEP 2: UPDATE AnalysisRow DATACLASS
================================================================================

FILE TO MODIFY:
  02_zone_system/09_backtest/processor/optimal_trade/analysis_builder.py

--------------------------------------------------------------------------------
FIND the AnalysisRow dataclass and ADD these new fields after is_actual_exit:
--------------------------------------------------------------------------------

@dataclass
class AnalysisRow:
    """
    Single row in the expanded analysis view.
    Represents ONE BAR of ONE TRADE with full context.
    
    v3.1: Added decay analysis fields (columns AC-AP)
    """
    # ... existing fields A-AB ...
    
    # =========================================================================
    # COLUMNS AC-AL: DECAY ANALYSIS (NEW - 10 columns)
    # =========================================================================
    
    # Post-MFE flags
    is_post_mfe: int = 0              # AC - 1 if bars_from_mfe > 0
    bars_after_mfe: int = 0           # AD - Bars since MFE (0 at MFE, negative before)
    
    # Decay metrics
    r_given_back: float = 0.0         # AE - MFE_R - R_at_this_bar
    health_at_mfe: int = 0            # AF - Health when MFE occurred
    health_decay: int = 0             # AG - health_at_mfe - health_at_bar
    
    # Indicator state comparison to MFE
    vwap_same_as_mfe: int = 0         # AH - 1 if VWAP position unchanged from MFE
    sma_same_as_mfe: int = 0          # AI - 1 if SMA alignment unchanged from MFE
    structure_same_as_mfe: int = 0    # AJ - 1 if M5 structure unchanged from MFE
    cvd_same_as_mfe: int = 0          # AK - 1 if CVD direction unchanged from MFE
    
    # First flip tracking
    is_first_flip: int = 0            # AL - 1 if this is the first negative event after MFE
    
    # =========================================================================
    # COLUMNS AM-AP: OUTCOME ANALYSIS (moved from AC-AI, renumbered)
    # =========================================================================
    actual_exit_price: float = 0.0    # AM
    actual_exit_time: str = ""        # AN
    actual_r: float = 0.0             # AO
    actual_exit_reason: str = ""      # AP
    mfe_r: float = 0.0                # AQ
    mae_r: float = 0.0                # AR
    win: int = 0                      # AS


================================================================================
STEP 3: UPDATE analysis_row_to_list FUNCTION
================================================================================

--------------------------------------------------------------------------------
UPDATE the function to include new columns:
--------------------------------------------------------------------------------

def analysis_row_to_list(row: AnalysisRow) -> List:
    """
    Convert AnalysisRow to list for Excel output.
    
    Returns:
        List of values in column order (A-AS, 45 columns)
    """
    return [
        # A-E: Trade Identification
        row.trade_id,
        row.date,
        row.ticker,
        row.direction,
        row.model,
        
        # F-J: Entry Conditions
        row.entry_health,
        row.entry_health_label,
        row.entry_vwap,
        row.entry_trend,
        row.entry_m5_structure,
        
        # K-R: This Bar's Data
        row.bar_seq,
        row.bar_time,
        row.bars_from_entry,
        row.bars_from_mfe,
        row.event_type,
        row.price_at_bar,
        row.r_if_exit,
        row.health_at_bar,
        
        # S-W: Current State
        row.vwap_at_bar,
        row.sma9_at_bar,
        row.sma21_at_bar,
        row.volume_at_bar,
        row.swing_high,
        
        # X-AB: Comparison Metrics
        row.health_vs_entry,
        row.r_vs_mfe,
        row.r_vs_actual,
        row.is_mfe,
        row.is_actual_exit,
        
        # AC-AL: Decay Analysis (NEW)
        row.is_post_mfe,
        row.bars_after_mfe,
        row.r_given_back,
        row.health_at_mfe,
        row.health_decay,
        row.vwap_same_as_mfe,
        row.sma_same_as_mfe,
        row.structure_same_as_mfe,
        row.cvd_same_as_mfe,
        row.is_first_flip,
        
        # AM-AS: Trade Outcome
        row.actual_exit_price,
        row.actual_exit_time,
        row.actual_r,
        row.actual_exit_reason,
        row.mfe_r,
        row.mae_r,
        row.win,
    ]


================================================================================
STEP 4: UPDATE ANALYSIS_HEADERS
================================================================================

--------------------------------------------------------------------------------
REPLACE ANALYSIS_HEADERS with expanded version:
--------------------------------------------------------------------------------

# Column headers (45 columns, A-AS)
ANALYSIS_HEADERS = [
    # A-E: Trade ID
    "Trade_ID", "Date", "Ticker", "Direction", "Model",
    
    # F-J: Entry Conditions
    "Entry_Health", "Entry_Label", "Entry_VWAP", "Entry_Trend", "Entry_Structure",
    
    # K-R: Bar Data
    "Bar_Seq", "Bar_Time", "Bars_From_Entry", "Bars_From_MFE", "Event_Type",
    "Price", "R_If_Exit", "Health",
    
    # S-W: Current State
    "VWAP", "SMA9", "SMA21", "Volume", "Swing_High",
    
    # X-AB: Comparison
    "Health_vs_Entry", "R_vs_MFE", "R_vs_Actual", "Is_MFE", "Is_Exit",
    
    # AC-AL: Decay Analysis (NEW)
    "Is_Post_MFE", "Bars_After_MFE", "R_Given_Back", "Health_at_MFE", "Health_Decay",
    "VWAP_Same", "SMA_Same", "Structure_Same", "CVD_Same", "Is_First_Flip",
    
    # AM-AS: Outcome
    "Actual_Exit_Price", "Actual_Exit_Time", "Actual_R", "Exit_Reason",
    "MFE_R", "MAE_R", "Win"
]

TOTAL_COLUMNS = 45
END_COL = 'AS'


================================================================================
STEP 5: UPDATE AnalysisBuilder._build_row METHOD
================================================================================

Update the _build_row method to calculate decay fields.

--------------------------------------------------------------------------------
ADD these calculations to _build_row:
--------------------------------------------------------------------------------

    def _build_row(
        self,
        trade_id: str,
        backtest: Dict,
        entry: Dict,
        event: Dict,
        mfe_r: float,
        mae_r: float,
        mfe_seq: Optional[int],
        mfe_event: Optional[Dict],  # ADD this parameter
        first_flip_seq: Optional[int],  # ADD this parameter
    ) -> AnalysisRow:
        """Build a single analysis row from source data."""
        
        # ... existing field calculations ...
        
        # Calculate decay analysis fields
        event_seq = self._safe_int(event.get('event_seq', 0))
        bars_from_mfe = self._safe_int(event.get('bars_from_mfe', 0))
        
        # Is this bar after MFE?
        is_post_mfe = 1 if mfe_seq and event_seq > mfe_seq else 0
        bars_after_mfe = event_seq - mfe_seq if mfe_seq else 0
        
        # R given back from MFE
        r_given_back = mfe_r - r_if_exit if is_post_mfe else 0.0
        
        # Health at MFE
        health_at_mfe = self._safe_int(mfe_event.get('health_score', 0)) if mfe_event else 0
        health_decay = health_at_mfe - health_at_bar if is_post_mfe else 0
        
        # Compare current state to MFE state
        vwap_same_as_mfe = 0
        sma_same_as_mfe = 0
        structure_same_as_mfe = 0
        cvd_same_as_mfe = 0
        
        if mfe_event and is_post_mfe:
            # VWAP position comparison
            mfe_vwap_pos = "ABOVE" if mfe_event.get('vwap', 0) and mfe_event.get('price_at_event', 0) > mfe_event.get('vwap', 0) else "BELOW"
            curr_vwap_pos = "ABOVE" if event.get('vwap', 0) and event.get('price_at_event', 0) > event.get('vwap', 0) else "BELOW"
            vwap_same_as_mfe = 1 if mfe_vwap_pos == curr_vwap_pos else 0
            
            # SMA alignment comparison
            mfe_sma_align = "BULL" if mfe_event.get('sma9', 0) and mfe_event.get('sma21', 0) and mfe_event.get('sma9', 0) > mfe_event.get('sma21', 0) else "BEAR"
            curr_sma_align = "BULL" if event.get('sma9', 0) and event.get('sma21', 0) and event.get('sma9', 0) > event.get('sma21', 0) else "BEAR"
            sma_same_as_mfe = 1 if mfe_sma_align == curr_sma_align else 0
            
            # M5 structure comparison (if available in v3 schema)
            mfe_structure = mfe_event.get('m5_structure', 'NEUTRAL')
            curr_structure = event.get('m5_structure', 'NEUTRAL')
            structure_same_as_mfe = 1 if mfe_structure == curr_structure else 0
            
            # CVD direction comparison
            mfe_cvd = "RISING" if mfe_event.get('cvd_slope', 0) > 0.1 else ("FALLING" if mfe_event.get('cvd_slope', 0) < -0.1 else "FLAT")
            curr_cvd = "RISING" if event.get('cvd_slope', 0) > 0.1 else ("FALLING" if event.get('cvd_slope', 0) < -0.1 else "FLAT")
            cvd_same_as_mfe = 1 if mfe_cvd == curr_cvd else 0
        
        # Is this the first flip after MFE?
        is_first_flip = 1 if first_flip_seq and event_seq == first_flip_seq else 0
        
        return AnalysisRow(
            # ... existing fields ...
            
            # Decay analysis fields
            is_post_mfe=is_post_mfe,
            bars_after_mfe=bars_after_mfe,
            r_given_back=r_given_back,
            health_at_mfe=health_at_mfe,
            health_decay=health_decay,
            vwap_same_as_mfe=vwap_same_as_mfe,
            sma_same_as_mfe=sma_same_as_mfe,
            structure_same_as_mfe=structure_same_as_mfe,
            cvd_same_as_mfe=cvd_same_as_mfe,
            is_first_flip=is_first_flip,
            
            # ... outcome fields ...
        )


================================================================================
STEP 6: UPDATE build_analysis TO FIND MFE EVENT AND FIRST FLIP
================================================================================

--------------------------------------------------------------------------------
UPDATE the loop in build_analysis method:
--------------------------------------------------------------------------------

    def build_analysis(
        self,
        backtest_data: Dict[str, Dict],
        entry_events_data: Dict[str, Dict],
        exit_events_data: Dict[str, List[Dict]]
    ) -> List[AnalysisRow]:
        """Build the expanded analysis view with decay analysis."""
        results = []
        
        for trade_id in backtest_data.keys():
            bt = backtest_data.get(trade_id, {})
            entry = entry_events_data.get(trade_id, {})
            events = exit_events_data.get(trade_id, [])
            
            if not events:
                continue
            
            sorted_events = sorted(events, key=lambda e: self._safe_int(e.get('event_seq', 0)))
            
            # Find MFE event and its details
            mfe_r = 0.0
            mae_r = 0.0
            mfe_seq = None
            mfe_event = None
            
            for e in sorted_events:
                if e.get('event_type') == 'MFE':
                    mfe_r = self._safe_float(e.get('r_at_event', 0))
                    mfe_seq = self._safe_int(e.get('event_seq', 0))
                    mfe_event = e  # Store full event for comparison
                elif e.get('event_type') == 'MAE':
                    mae_r = self._safe_float(e.get('r_at_event', 0))
            
            # Find first flip (first negative event after MFE)
            direction = str(bt.get('direction', 'LONG')).upper()
            first_flip_seq = None
            
            if mfe_seq:
                negative_events = self._get_negative_events(direction)
                
                for e in sorted_events:
                    e_seq = self._safe_int(e.get('event_seq', 0))
                    e_type = e.get('event_type', '')
                    
                    if e_seq > mfe_seq and e_type in negative_events:
                        first_flip_seq = e_seq
                        break
            
            # Build rows
            for event in sorted_events:
                row = self._build_row(
                    trade_id=trade_id,
                    backtest=bt,
                    entry=entry,
                    event=event,
                    mfe_r=mfe_r,
                    mae_r=mae_r,
                    mfe_seq=mfe_seq,
                    mfe_event=mfe_event,
                    first_flip_seq=first_flip_seq,
                )
                results.append(row)
        
        return results
    
    def _get_negative_events(self, direction: str) -> set:
        """Get set of negative event types for direction."""
        if direction == "LONG":
            return {
                'LOWER_HIGH', 'LOWER_LOW',
                'M5_FLIP_BEAR', 'M15_FLIP_BEAR', 'H1_FLIP_BEAR',
                'VWAP_LOST', 'SMA9_LOST', 'SMA21_LOST', 'SMA_CROSS_BEAR',
                'SMA_SPREAD_NARROW', 'VOL_DELTA_BEAR', 'CVD_FALLING',
            }
        else:
            return {
                'HIGHER_LOW', 'HIGHER_HIGH',
                'M5_FLIP_BULL', 'M15_FLIP_BULL', 'H1_FLIP_BULL',
                'VWAP_LOST', 'SMA9_LOST', 'SMA21_LOST', 'SMA_CROSS_BULL',
                'SMA_SPREAD_NARROW', 'VOL_DELTA_BULL', 'CVD_RISING',
            }


================================================================================
STEP 7: UPDATE analysis_writer.py FOR NEW COLUMNS
================================================================================

--------------------------------------------------------------------------------
UPDATE END_COL constant:
--------------------------------------------------------------------------------

END_COL = 'AS'  # 45 columns


================================================================================
STEP 8: ADD DECAY SUMMARY TO STATISTICS
================================================================================

Add decay-specific statistics to get_summary_stats in analysis_writer.py:

--------------------------------------------------------------------------------
ADD to get_summary_stats method:
--------------------------------------------------------------------------------

    def get_summary_stats(self, rows: List[AnalysisRow]) -> Dict:
        """Calculate summary statistics including decay analysis."""
        # ... existing stats ...
        
        # Decay Analysis Stats
        post_mfe_rows = [r for r in rows if r.is_post_mfe == 1]
        first_flip_rows = [r for r in rows if r.is_first_flip == 1]
        
        # Average R given back
        if post_mfe_rows:
            avg_r_given_back = sum(r.r_given_back for r in post_mfe_rows) / len(post_mfe_rows)
        else:
            avg_r_given_back = 0
        
        # First flip analysis
        first_flip_would_be_better = 0
        first_flip_avg_improvement = 0
        
        if first_flip_rows:
            better_count = sum(1 for r in first_flip_rows if r.r_if_exit > r.actual_r)
            first_flip_would_be_better = better_count / len(first_flip_rows) * 100
            
            improvements = [r.r_if_exit - r.actual_r for r in first_flip_rows if r.r_if_exit > r.actual_r]
            if improvements:
                first_flip_avg_improvement = sum(improvements) / len(improvements)
        
        # Which indicator flips first most often?
        first_flip_events = {}
        for r in first_flip_rows:
            event = r.event_type
            if event:
                first_flip_events[event] = first_flip_events.get(event, 0) + 1
        
        return {
            # ... existing stats ...
            
            # Decay stats
            'post_mfe_bar_count': len(post_mfe_rows),
            'first_flip_count': len(first_flip_rows),
            'avg_r_given_back': avg_r_given_back,
            'first_flip_would_be_better_pct': first_flip_would_be_better,
            'first_flip_avg_improvement': first_flip_avg_improvement,
            'first_flip_events': first_flip_events,
        }


================================================================================
VERIFICATION
================================================================================

After implementing these changes:

1. Run optimal_runner.py and verify:
   - New columns AC-AL are populated
   - is_post_mfe = 1 only after MFE bar
   - r_given_back increases as trade decays
   - is_first_flip = 1 for exactly one row per trade

2. Check decay analysis:
   - Filter to is_post_mfe = 1
   - Sort by r_given_back descending
   - See which indicators (vwap_same, sma_same, etc.) change first

3. Run analysis queries:
   - "What % of first flips would have been better exits?"
   - "Which event type appears most as first_flip?"
   - "What's the avg R improvement from exiting at first flip?"

================================================================================
EXCEL QUERIES FOR DECAY ANALYSIS
================================================================================

PIVOT TABLE: First Flip Event Performance
  Rows: Event_Type (filter Is_First_Flip = 1)
  Values:
    - Count of Trade_ID
    - Avg of R_If_Exit
    - Avg of R_vs_Actual

FORMULA: Would First Flip Be Better?
  =COUNTIFS(Is_First_Flip, 1, R_vs_Actual, ">0") / COUNTIF(Is_First_Flip, 1)

FORMULA: Avg R Saved by First Flip Exit
  =AVERAGEIFS(R_vs_Actual, Is_First_Flip, 1, R_vs_Actual, ">0")

FILTER: Post-MFE Decay Points
  Filter: Is_Post_MFE = 1
  Sort: Bars_After_MFE ascending
  Columns: Trade_ID, Bars_After_MFE, R_Given_Back, Health_Decay

================================================================================
END OF PHASE 5
================================================================================