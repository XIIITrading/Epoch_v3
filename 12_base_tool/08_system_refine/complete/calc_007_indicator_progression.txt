# CALC-007: INDICATOR PROGRESSION ANALYSIS
## Claude Code Implementation Instructions
### Epoch Trading System - Indicator Analysis Module

**Document Version:** 1.0  
**Created:** 2026-01-03  
**Author:** Monte AI / Silva  
**Target Application:** 12_indicator_analysis  

---

## 1. OBJECTIVE

Build CALC-007 to analyze how indicators change from ENTRY to MFE (winners) vs ENTRY to MAE (losers). This informs exit timing and early warning signal development.

### Core Question
> "What indicator changes signal that a trade is working vs failing?"

### Purpose
1. **Exit Signal Development** - Identify when to exit early
2. **Winner/Loser Differentiation** - What separates winning trades?
3. **Early Warning Signals** - Detect failing trades before stop hit
4. **DOW AI Exit Recommendations** - Provide exit guidance

---

## 2. PROJECT CONTEXT

### Directory Structure
```
C:\XIIITradingSystems\Epoch\02_zone_system\12_indicator_analysis\
â”œâ”€â”€ calculations/
â”‚   â””â”€â”€ indicator_analysis/
â”‚       â”œâ”€â”€ __init__.py                    # UPDATE - Add exports
â”‚       â”œâ”€â”€ health_correlation.py          # CALC-005
â”‚       â”œâ”€â”€ factor_importance.py           # CALC-006
â”‚       â””â”€â”€ indicator_progression.py       # NEW FILE - CALC-007
â””â”€â”€ app.py                                 # UPDATE - Wire CALC-007
```

### Data Requirement

**NOTE:** CALC-007 requires indicator snapshots at multiple events (ENTRY, MFE, MAE). 

Currently `entry_indicators` only captures ENTRY. Two options:

**Option A (Recommended):** Use `trade_bars` table which has bar-by-bar indicator values
**Option B:** Create additional snapshots table for MFE/MAE events

This document assumes **Option A** using `trade_bars` data.

---

## 3. CALCULATION SPECIFICATION

### Data Source

Join `trade_bars` (filtered to relevant events) with `mfe_mae_potential`:

```sql
SELECT 
    tb.trade_id,
    tb.event_type,
    tb.bars_from_entry,
    tb.health_score,
    tb.cvd_slope,
    tb.vol_delta,
    tb.sma_spread,
    mp.is_winner,
    mp.mfe_r_potential,
    mp.mae_r_potential
FROM trade_bars tb
JOIN mfe_mae_potential mp ON tb.trade_id = mp.trade_id
WHERE tb.event_type IN ('ENTRY', 'MFE', 'MAE', 'EXIT')
ORDER BY tb.trade_id, tb.event_seq
```

### Metrics to Calculate

| Metric | Formula | Purpose |
|--------|---------|---------|
| Avg Health Score at Event | mean(health_score) by event type | Progression baseline |
| Health Delta (Entry â†’ MFE) | hs_mfe - hs_entry for winners | Winner pattern |
| Health Delta (Entry â†’ MAE) | hs_mae - hs_entry for losers | Loser pattern |
| Early Degradation Rate | % trades with hs_drop > X within Y bars | Early warning |
| Divergence Point | Bar where winner/loser paths separate | Critical timing |

### Event Types

| Event | Description | Analysis Use |
|-------|-------------|--------------|
| ENTRY | Trade entry bar | Baseline state |
| MFE | Maximum Favorable Excursion bar | Winner peak |
| MAE | Maximum Adverse Excursion bar | Loser trough |
| EXIT | Trade exit bar | Final state |

---

## 4. IMPLEMENTATION

### File: calculations/indicator_analysis/indicator_progression.py

```python
"""
CALC-007: Indicator Progression Analysis

Analyzes how indicators change from ENTRY to MFE/MAE.
Identifies early warning signals for failing trades.
"""

import pandas as pd
import numpy as np
from scipy import stats
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
import streamlit as st

import sys
from pathlib import Path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from config import INDICATOR_ANALYSIS_CONFIG


# Indicators to track progression
PROGRESSION_INDICATORS = [
    'health_score',
    'cvd_slope',
    'vol_delta',
    'vol_roc',
    'sma_spread',
    'sma_momentum'
]


@dataclass
class EventSnapshot:
    """Indicator snapshot at a specific event."""
    event_type: str
    avg_health_score: float
    std_health_score: float
    avg_cvd_slope: float
    avg_vol_delta: float
    avg_sma_spread: float
    trade_count: int


@dataclass
class ProgressionPath:
    """Indicator progression path for a trade group (winners/losers)."""
    outcome: str  # 'WIN' or 'LOSS'
    entry_snapshot: EventSnapshot
    peak_snapshot: EventSnapshot  # MFE for winners, MAE for losers
    exit_snapshot: Optional[EventSnapshot]
    
    # Deltas
    health_delta_to_peak: float
    cvd_delta_to_peak: float
    vol_delta_to_peak: float
    
    # Timing
    avg_bars_to_peak: float
    trade_count: int


@dataclass
class EarlyWarningSignal:
    """Early warning signal definition."""
    indicator: str
    threshold: float
    direction: str  # 'drop' or 'rise'
    bars_window: int
    hit_rate_losers: float  # % of losers that show this signal
    hit_rate_winners: float  # % of winners that show this signal (false positives)
    lift: float  # hit_rate_losers - hit_rate_winners
    predictive_power: float  # Lift / hit_rate_losers


@dataclass
class IndicatorProgressionResult:
    """Container for all progression analysis results."""
    total_trades: int
    winner_count: int
    loser_count: int
    
    # Progression paths
    winner_path: ProgressionPath
    loser_path: ProgressionPath
    
    # By-event summary
    event_summary: pd.DataFrame  # [event, outcome, health_score, cvd_slope, ...]
    
    # Delta distributions
    winner_deltas: pd.DataFrame  # [indicator, entry_val, peak_val, delta, pct_change]
    loser_deltas: pd.DataFrame
    
    # Early warning signals
    early_warnings: List[EarlyWarningSignal]
    
    # Best early warning
    best_warning: Optional[EarlyWarningSignal]


def calculate_event_snapshot(
    df: pd.DataFrame,
    event_type: str
) -> Optional[EventSnapshot]:
    """
    Calculate indicator averages at a specific event type.
    
    Parameters:
        df: DataFrame filtered to specific outcome group
        event_type: 'ENTRY', 'MFE', 'MAE', or 'EXIT'
    
    Returns:
        EventSnapshot with average values
    """
    event_df = df[df['event_type'] == event_type]
    
    if len(event_df) == 0:
        return None
    
    return EventSnapshot(
        event_type=event_type,
        avg_health_score=event_df['health_score'].mean() if 'health_score' in event_df else 0,
        std_health_score=event_df['health_score'].std() if 'health_score' in event_df else 0,
        avg_cvd_slope=event_df['cvd_slope'].mean() if 'cvd_slope' in event_df else 0,
        avg_vol_delta=event_df['vol_delta'].mean() if 'vol_delta' in event_df else 0,
        avg_sma_spread=event_df['sma_spread'].mean() if 'sma_spread' in event_df else 0,
        trade_count=len(event_df['trade_id'].unique())
    )


def calculate_progression_path(
    df: pd.DataFrame,
    outcome: str,
    is_winner: bool
) -> Optional[ProgressionPath]:
    """
    Calculate progression path for winners or losers.
    
    Parameters:
        df: DataFrame with trade_bars data
        outcome: 'WIN' or 'LOSS'
        is_winner: True for winners, False for losers
    
    Returns:
        ProgressionPath for the group
    """
    # Filter to outcome group
    group_df = df[df['is_winner'] == is_winner]
    
    if len(group_df) == 0:
        return None
    
    # Get snapshots
    entry_snapshot = calculate_event_snapshot(group_df, 'ENTRY')
    exit_snapshot = calculate_event_snapshot(group_df, 'EXIT')
    
    # Peak event differs by outcome
    if is_winner:
        peak_snapshot = calculate_event_snapshot(group_df, 'MFE')
    else:
        peak_snapshot = calculate_event_snapshot(group_df, 'MAE')
    
    if not entry_snapshot or not peak_snapshot:
        return None
    
    # Calculate deltas
    health_delta = peak_snapshot.avg_health_score - entry_snapshot.avg_health_score
    cvd_delta = peak_snapshot.avg_cvd_slope - entry_snapshot.avg_cvd_slope
    vol_delta = peak_snapshot.avg_vol_delta - entry_snapshot.avg_vol_delta
    
    # Calculate average bars to peak
    peak_event = 'MFE' if is_winner else 'MAE'
    peak_bars = group_df[group_df['event_type'] == peak_event]['bars_from_entry']
    avg_bars = peak_bars.mean() if len(peak_bars) > 0 else 0
    
    return ProgressionPath(
        outcome=outcome,
        entry_snapshot=entry_snapshot,
        peak_snapshot=peak_snapshot,
        exit_snapshot=exit_snapshot,
        health_delta_to_peak=health_delta,
        cvd_delta_to_peak=cvd_delta,
        vol_delta_to_peak=vol_delta,
        avg_bars_to_peak=avg_bars,
        trade_count=len(group_df['trade_id'].unique())
    )


def calculate_early_warning_signals(
    df: pd.DataFrame,
    indicators: List[str] = None,
    bars_windows: List[int] = [3, 5, 10]
) -> List[EarlyWarningSignal]:
    """
    Identify early warning signals that predict losing trades.
    
    Parameters:
        df: DataFrame with trade_bars data
        indicators: List of indicators to analyze
        bars_windows: Number of bars from entry to check
    
    Returns:
        List of EarlyWarningSignal objects
    """
    if indicators is None:
        indicators = ['health_score', 'cvd_slope']
    
    warnings = []
    
    for indicator in indicators:
        if indicator not in df.columns:
            continue
            
        for bars_window in bars_windows:
            # Get entry values
            entry_vals = df[df['event_type'] == 'ENTRY'].groupby('trade_id')[indicator].first()
            
            # Get values at N bars from entry
            window_df = df[df['bars_from_entry'] == bars_window]
            window_vals = window_df.groupby('trade_id')[indicator].first()
            
            # Calculate change
            common_trades = entry_vals.index.intersection(window_vals.index)
            if len(common_trades) < 30:
                continue
            
            changes = window_vals[common_trades] - entry_vals[common_trades]
            
            # Get outcomes
            outcomes = df[df['trade_id'].isin(common_trades)].groupby('trade_id')['is_winner'].first()
            
            # Test different thresholds
            for threshold in [-2, -1.5, -1, -0.5]:  # Health score drops
                # Calculate hit rates
                losers = outcomes[outcomes == False].index
                winners = outcomes[outcomes == True].index
                
                loser_hits = (changes[losers] <= threshold).sum() / len(losers) * 100 if len(losers) > 0 else 0
                winner_hits = (changes[winners] <= threshold).sum() / len(winners) * 100 if len(winners) > 0 else 0
                
                lift = loser_hits - winner_hits
                predictive = lift / loser_hits if loser_hits > 0 else 0
                
                if lift > 5:  # Only add if meaningful lift
                    warnings.append(EarlyWarningSignal(
                        indicator=indicator,
                        threshold=threshold,
                        direction='drop',
                        bars_window=bars_window,
                        hit_rate_losers=loser_hits,
                        hit_rate_winners=winner_hits,
                        lift=lift,
                        predictive_power=predictive
                    ))
    
    # Sort by lift
    warnings.sort(key=lambda x: x.lift, reverse=True)
    
    return warnings


def create_event_summary(
    df: pd.DataFrame
) -> pd.DataFrame:
    """
    Create summary table of indicator values by event and outcome.
    """
    results = []
    
    for event in ['ENTRY', 'MFE', 'MAE', 'EXIT']:
        for is_winner in [True, False]:
            outcome = 'WIN' if is_winner else 'LOSS'
            subset = df[(df['event_type'] == event) & (df['is_winner'] == is_winner)]
            
            if len(subset) == 0:
                continue
            
            row = {
                'event': event,
                'outcome': outcome,
                'trades': len(subset['trade_id'].unique())
            }
            
            for indicator in PROGRESSION_INDICATORS:
                if indicator in subset.columns:
                    row[f'{indicator}_avg'] = subset[indicator].mean()
                    row[f'{indicator}_std'] = subset[indicator].std()
            
            results.append(row)
    
    return pd.DataFrame(results)


def create_delta_summary(
    df: pd.DataFrame,
    is_winner: bool
) -> pd.DataFrame:
    """
    Create summary of indicator changes from entry to peak.
    """
    outcome_df = df[df['is_winner'] == is_winner]
    peak_event = 'MFE' if is_winner else 'MAE'
    
    entry_df = outcome_df[outcome_df['event_type'] == 'ENTRY']
    peak_df = outcome_df[outcome_df['event_type'] == peak_event]
    
    results = []
    
    for indicator in PROGRESSION_INDICATORS:
        if indicator not in entry_df.columns:
            continue
        
        entry_vals = entry_df.groupby('trade_id')[indicator].first()
        peak_vals = peak_df.groupby('trade_id')[indicator].first()
        
        common = entry_vals.index.intersection(peak_vals.index)
        if len(common) == 0:
            continue
        
        entry_avg = entry_vals[common].mean()
        peak_avg = peak_vals[common].mean()
        delta = peak_avg - entry_avg
        pct_change = (delta / entry_avg * 100) if entry_avg != 0 else 0
        
        results.append({
            'indicator': indicator,
            'entry_avg': entry_avg,
            'peak_avg': peak_avg,
            'delta': delta,
            'pct_change': pct_change
        })
    
    return pd.DataFrame(results)


def analyze_indicator_progression(df: pd.DataFrame) -> IndicatorProgressionResult:
    """
    Main analysis function for CALC-007.
    
    Parameters:
        df: DataFrame with trade_bars data joined with outcomes
    
    Returns:
        IndicatorProgressionResult with all analysis outputs
    """
    # Basic counts
    trades = df['trade_id'].unique()
    total_trades = len(trades)
    
    winner_trades = df[df['is_winner'] == True]['trade_id'].unique()
    loser_trades = df[df['is_winner'] == False]['trade_id'].unique()
    
    winner_count = len(winner_trades)
    loser_count = len(loser_trades)
    
    # Calculate progression paths
    winner_path = calculate_progression_path(df, 'WIN', True)
    loser_path = calculate_progression_path(df, 'LOSS', False)
    
    # Event summary
    event_summary = create_event_summary(df)
    
    # Delta summaries
    winner_deltas = create_delta_summary(df, True)
    loser_deltas = create_delta_summary(df, False)
    
    # Early warning signals
    early_warnings = calculate_early_warning_signals(df)
    best_warning = early_warnings[0] if early_warnings else None
    
    return IndicatorProgressionResult(
        total_trades=total_trades,
        winner_count=winner_count,
        loser_count=loser_count,
        winner_path=winner_path,
        loser_path=loser_path,
        event_summary=event_summary,
        winner_deltas=winner_deltas,
        loser_deltas=loser_deltas,
        early_warnings=early_warnings,
        best_warning=best_warning
    )


# =============================================================================
# STREAMLIT RENDERING FUNCTIONS
# =============================================================================

def render_progression_summary_cards(result: IndicatorProgressionResult):
    """Render summary cards for progression analysis."""
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            label="Total Trades",
            value=f"{result.total_trades:,}"
        )
    
    with col2:
        st.metric(
            label="Winners",
            value=f"{result.winner_count:,}",
            delta=f"{result.winner_count/result.total_trades*100:.1f}%" if result.total_trades > 0 else "0%"
        )
    
    with col3:
        st.metric(
            label="Losers",
            value=f"{result.loser_count:,}"
        )
    
    with col4:
        if result.best_warning:
            st.metric(
                label="Best Warning Signal",
                value=f"{result.best_warning.indicator}",
                delta=f"+{result.best_warning.lift:.1f}pp lift"
            )


def render_progression_path_chart(result: IndicatorProgressionResult):
    """Render line chart comparing winner vs loser progression paths."""
    import plotly.graph_objects as go
    
    fig = go.Figure()
    
    # Winner path
    if result.winner_path:
        wp = result.winner_path
        fig.add_trace(go.Scatter(
            x=['ENTRY', 'MFE', 'EXIT'] if wp.exit_snapshot else ['ENTRY', 'MFE'],
            y=[
                wp.entry_snapshot.avg_health_score,
                wp.peak_snapshot.avg_health_score,
                wp.exit_snapshot.avg_health_score if wp.exit_snapshot else None
            ],
            mode='lines+markers',
            name='Winners',
            line=dict(color='#26a69a', width=3),
            marker=dict(size=12)
        ))
    
    # Loser path
    if result.loser_path:
        lp = result.loser_path
        fig.add_trace(go.Scatter(
            x=['ENTRY', 'MAE', 'EXIT'] if lp.exit_snapshot else ['ENTRY', 'MAE'],
            y=[
                lp.entry_snapshot.avg_health_score,
                lp.peak_snapshot.avg_health_score,
                lp.exit_snapshot.avg_health_score if lp.exit_snapshot else None
            ],
            mode='lines+markers',
            name='Losers',
            line=dict(color='#ef5350', width=3),
            marker=dict(size=12)
        ))
    
    fig.update_layout(
        title="Health Score Progression: Winners vs Losers",
        xaxis_title="Event",
        yaxis_title="Average Health Score",
        template="plotly_dark",
        paper_bgcolor="#16213e",
        plot_bgcolor="#1a1a2e",
        font=dict(color="#e0e0e0"),
        yaxis=dict(range=[0, 10])
    )
    
    st.plotly_chart(fig, use_container_width=True)


def render_delta_comparison_chart(result: IndicatorProgressionResult):
    """Render bar chart comparing entry-to-peak deltas for winners vs losers."""
    import plotly.graph_objects as go
    
    if result.winner_deltas is None or result.loser_deltas is None:
        st.warning("Insufficient data for delta comparison")
        return
    
    indicators = result.winner_deltas['indicator'].tolist()
    
    fig = go.Figure()
    
    fig.add_trace(go.Bar(
        name='Winners (Entry â†’ MFE)',
        x=indicators,
        y=result.winner_deltas['delta'],
        marker_color='#26a69a'
    ))
    
    fig.add_trace(go.Bar(
        name='Losers (Entry â†’ MAE)',
        x=indicators,
        y=result.loser_deltas['delta'],
        marker_color='#ef5350'
    ))
    
    fig.update_layout(
        title="Indicator Delta: Entry to Peak",
        xaxis_title="Indicator",
        yaxis_title="Change (Delta)",
        barmode='group',
        template="plotly_dark",
        paper_bgcolor="#16213e",
        plot_bgcolor="#1a1a2e",
        font=dict(color="#e0e0e0"),
        xaxis_tickangle=-45
    )
    
    st.plotly_chart(fig, use_container_width=True)


def render_early_warning_table(result: IndicatorProgressionResult):
    """Render table of early warning signals."""
    if not result.early_warnings:
        st.info("No significant early warning signals identified")
        return
    
    data = [{
        'Indicator': w.indicator,
        'Threshold': f"â‰¤ {w.threshold}",
        'Window': f"{w.bars_window} bars",
        'Loser Hit Rate': f"{w.hit_rate_losers:.1f}%",
        'Winner Hit Rate': f"{w.hit_rate_winners:.1f}%",
        'Lift': f"+{w.lift:.1f}pp",
        'Predictive': f"{w.predictive_power:.2f}"
    } for w in result.early_warnings[:10]]  # Top 10
    
    df = pd.DataFrame(data)
    st.dataframe(df, use_container_width=True, hide_index=True)


def render_event_summary_table(result: IndicatorProgressionResult):
    """Render detailed event summary table."""
    df = result.event_summary.copy()
    
    if 'health_score_avg' in df.columns:
        df['health_score_avg'] = df['health_score_avg'].apply(lambda x: f"{x:.2f}")
    
    st.dataframe(df, use_container_width=True, hide_index=True)


def render_calc_007_section(df: pd.DataFrame):
    """
    Main render function for CALC-007 section in Streamlit.
    
    Parameters:
        df: DataFrame from trade_bars with outcomes joined
    """
    st.subheader("CALC-007: Indicator Progression Analysis")
    st.markdown("*What changes between entry and outcome?*")
    
    try:
        result = analyze_indicator_progression(df)
        
        # Summary cards
        render_progression_summary_cards(result)
        
        st.divider()
        
        # Progression paths
        st.markdown("### Health Score Progression")
        render_progression_path_chart(result)
        
        # Delta comparison
        st.markdown("### Indicator Changes: Entry to Peak")
        render_delta_comparison_chart(result)
        
        st.divider()
        
        # Early warning signals
        st.markdown("### ðŸš¨ Early Warning Signals")
        st.markdown("*Signals that predict trade failure before stop is hit*")
        render_early_warning_table(result)
        
        # Event summary (expandable)
        with st.expander("ðŸ“Š Detailed Event Summary", expanded=False):
            render_event_summary_table(result)
        
        # Key findings
        st.divider()
        st.markdown("### ðŸ“Š Key Findings")
        
        findings = []
        
        if result.winner_path and result.loser_path:
            hs_diff = result.winner_path.entry_snapshot.avg_health_score - result.loser_path.entry_snapshot.avg_health_score
            if hs_diff > 0.5:
                findings.append(f"âœ… **Winners start with higher Health Score** (+{hs_diff:.1f} points at entry)")
            
            w_delta = result.winner_path.health_delta_to_peak
            l_delta = result.loser_path.health_delta_to_peak
            
            if w_delta > 0 and l_delta < 0:
                findings.append(f"âœ… **Divergent paths:** Winners improve ({w_delta:+.1f}), losers degrade ({l_delta:+.1f})")
        
        if result.best_warning:
            bw = result.best_warning
            findings.append(
                f"ðŸš¨ **Best Early Warning:** {bw.indicator} drop of {bw.threshold} within {bw.bars_window} bars "
                f"catches {bw.hit_rate_losers:.0f}% of losers (only {bw.hit_rate_winners:.0f}% false positives)"
            )
        
        for finding in findings:
            st.markdown(finding)
        
        return result
        
    except Exception as e:
        st.error(f"Error in CALC-007 analysis: {e}")
        import traceback
        st.code(traceback.format_exc())
        return None
```

---

## 5. DATA LOADING UPDATE

### Update data/supabase_client.py

Add method to fetch trade_bars with outcomes:

```python
def fetch_trade_bars_with_outcomes(
    self,
    date_from: Optional[date] = None,
    date_to: Optional[date] = None,
    models: Optional[List[str]] = None,
    event_types: Optional[List[str]] = ['ENTRY', 'MFE', 'MAE', 'EXIT'],
    limit: int = 100000
) -> List[Dict]:
    """
    Fetch trade_bars data with outcome information for progression analysis.
    
    Parameters:
        date_from: Start date filter
        date_to: End date filter
        models: List of models to include
        event_types: List of event types to include
        limit: Maximum rows to return
    
    Returns:
        List of trade_bar records with is_winner joined
    """
    try:
        query = """
            SELECT 
                tb.trade_id,
                tb.date,
                tb.ticker,
                tb.direction,
                tb.model,
                tb.event_type,
                tb.event_seq,
                tb.bars_from_entry,
                tb.health_score,
                tb.cvd_slope,
                tb.vol_delta,
                tb.vol_roc,
                tb.sma_spread,
                tb.sma_momentum,
                tb.vwap,
                mp.is_winner,
                mp.mfe_r_potential,
                mp.mae_r_potential
            FROM trade_bars tb
            JOIN mfe_mae_potential mp ON tb.trade_id = mp.trade_id
            WHERE 1=1
        """
        params = []
        param_idx = 1
        
        if event_types:
            query += f" AND tb.event_type = ANY(${param_idx})"
            params.append(event_types)
            param_idx += 1
        
        if date_from:
            query += f" AND tb.date >= ${param_idx}"
            params.append(date_from)
            param_idx += 1
        
        if date_to:
            query += f" AND tb.date <= ${param_idx}"
            params.append(date_to)
            param_idx += 1
        
        if models:
            query += f" AND tb.model = ANY(${param_idx})"
            params.append(models)
            param_idx += 1
        
        query += f" ORDER BY tb.trade_id, tb.event_seq LIMIT ${param_idx}"
        params.append(limit)
        
        self.cursor.execute(query, params)
        columns = [desc[0] for desc in self.cursor.description]
        rows = self.cursor.fetchall()
        
        return [dict(zip(columns, row)) for row in rows]
        
    except Exception as e:
        self.conn.rollback()
        print(f"Error fetching trade_bars with outcomes: {e}")
        return []
```

---

## 6. UPDATE app.py

Wire CALC-007 into the Indicator Analysis tab:

```python
# Add data loading function:
@st.cache_data(ttl=300)
def load_trade_bars_progression():
    client = get_client()
    return client.fetch_trade_bars_with_outcomes(
        date_from=filters.get('date_from'),
        date_to=filters.get('date_to'),
        models=filters.get('models'),
        event_types=['ENTRY', 'MFE', 'MAE', 'EXIT']
    )

# In the calc7 sub-tab section:
with calc7:
    st.subheader("CALC-007: Indicator Progression Analysis")
    st.markdown("*What changes between entry and outcome?*")
    
    trade_bars_data = load_trade_bars_progression()
    
    if trade_bars_data:
        from calculations.indicator_analysis import render_calc_007_section
        trade_bars_df = pd.DataFrame(trade_bars_data)
        calc_007_result = render_calc_007_section(trade_bars_df)
    else:
        st.warning("No trade_bars data available for CALC-007 analysis")
```

---

## 7. EXPECTED OUTPUT EXAMPLE

```
CALC-007: Indicator Progression Analysis

Health Score Progression:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Outcome â”‚ ENTRY   â”‚ MFE/MAE â”‚ Delta   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Winners â”‚  6.8    â”‚   7.2   â”‚  +0.4   â”‚
â”‚ Losers  â”‚  5.9    â”‚   4.1   â”‚  -1.8   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Key Insight: Winners start slightly higher and IMPROVE.
             Losers start lower and DEGRADE significantly.

ðŸš¨ Early Warning Signals:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Indicator      â”‚ Threshold â”‚ Window â”‚ Loser Hit% â”‚ Winner Hit%â”‚ Lift     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ health_score   â”‚ â‰¤ -1.5    â”‚ 5 bars â”‚   68.2%    â”‚    24.1%   â”‚ +44.1 pp â”‚
â”‚ cvd_slope      â”‚ â‰¤ -0.15   â”‚ 5 bars â”‚   72.3%    â”‚    31.8%   â”‚ +40.5 pp â”‚
â”‚ health_score   â”‚ â‰¤ -1.0    â”‚ 3 bars â”‚   54.6%    â”‚    18.9%   â”‚ +35.7 pp â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Best Warning: Health Score drop of 1.5+ within 5 bars catches 68% of losers
              with only 24% false positives.

DOW AI Exit Signal: Consider early exit if Health Score drops 1.5+ within 5 bars.
```

---

## 8. NOTES FOR CLAUDE CODE

1. **Data Dependency**: Requires `trade_bars` table with event-level indicator snapshots. If this table has data quality issues similar to `optimal_trades`, may need alternative approach.

2. **Event Types**: Focus on ENTRY, MFE, MAE, EXIT events. Skip regular BAR events for summary analysis.

3. **Early Warning Thresholds**: Test multiple thresholds (-0.5, -1.0, -1.5, -2.0) and multiple windows (3, 5, 10 bars).

4. **Lift Calculation**: Lift = loser_hit_rate - winner_hit_rate. Higher lift = better discriminator.

5. **Minimum Samples**: Need at least 30 trades in each outcome group for statistical validity.

6. **Chart Colors**: Winners = green (#26a69a), Losers = red (#ef5350).

---

**END OF DOCUMENT 5**