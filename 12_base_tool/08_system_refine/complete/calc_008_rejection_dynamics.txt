# CALC-008: REJECTION DYNAMICS ANALYSIS
## Claude Code Implementation Instructions
### Epoch Trading System - Indicator Analysis Module

**Document Version:** 1.0  
**Created:** 2026-01-03  
**Author:** Monte AI / Silva  
**Target Application:** 12_indicator_analysis  

---

## 1. OBJECTIVE

Build CALC-008 to analyze whether rejection trades (EPCH02/04) require different indicators than continuation trades (EPCH01/03). This is the discovery phase for potentially building a second "Exhaustion Score" system.

### Core Question
> "Do rejection trades require different indicators than continuation trades?"

### Sub-Questions
- **8A:** What's the time-to-MFE distribution for rejection vs continuation?
- **8B:** Is Health Score negatively correlated with win rate for rejection models?
- **8C:** Which individual factors are inverted for rejection trades?
- **8D:** What new indicators might predict rejection success?

### Purpose
1. **Validate Hypothesis** - Confirm rejection trades behave differently
2. **Factor Inversion Analysis** - Identify which factors flip meaning
3. **New Indicator Discovery** - Identify exhaustion/absorption signals
4. **Dual Scoring System** - Foundation for model-specific scoring

---

## 2. PROJECT CONTEXT

### Directory Structure
```
C:\XIIITradingSystems\Epoch\02_zone_system\12_indicator_analysis\
â”œâ”€â”€ calculations/
â”‚   â””â”€â”€ indicator_analysis/
â”‚       â”œâ”€â”€ __init__.py                    # UPDATE - Add exports
â”‚       â”œâ”€â”€ health_correlation.py          # CALC-005
â”‚       â”œâ”€â”€ factor_importance.py           # CALC-006
â”‚       â”œâ”€â”€ indicator_progression.py       # CALC-007
â”‚       â””â”€â”€ rejection_dynamics.py          # NEW FILE - CALC-008
â””â”€â”€ app.py                                 # UPDATE - Wire CALC-008
```

### Model Type Classification

| Model | Type | Trade Logic |
|-------|------|-------------|
| EPCH01 | Continuation | Trade WITH zone direction at primary |
| EPCH02 | Rejection | Trade AGAINST zone (mean reversion) at primary |
| EPCH03 | Continuation | Trade WITH zone direction at secondary |
| EPCH04 | Rejection | Trade AGAINST zone (mean reversion) at secondary |

### The Hypothesis

**Continuation trades** (EPCH01/03):
- Best setups have aligned indicators (Health Score HIGH)
- Indicators confirm trend direction
- Enter WITH momentum

**Rejection trades** (EPCH02/04):
- Best setups may have "unhealthy" indicators for trade direction
- Price has just run HARD into zone (overextended)
- Enter AGAINST momentum at exhaustion point

If true, the current Health Score may be **inverted** for rejection trades.

---

## 3. CALCULATION SPECIFICATION

### 8A: Time-to-MFE Analysis

Compare how quickly MFE is reached by model type.

**Hypothesis:** Rejection trades should reach MFE faster (quick snap-back) or fail quickly.

```sql
SELECT 
    model,
    CASE WHEN model IN ('EPCH01', 'EPCH03') THEN 'continuation' ELSE 'rejection' END as model_type,
    direction,
    EXTRACT(EPOCH FROM (mfe_potential_time - entry_time)) / 60 as minutes_to_mfe,
    is_winner
FROM mfe_mae_potential
WHERE mfe_potential_time IS NOT NULL
```

**Metrics:**
- Median time-to-MFE by model type
- % reaching MFE within 5 minutes (1 M5 bar)
- % reaching MFE within 15 minutes (3 M5 bars)
- Distribution comparison (histogram overlay)

---

### 8B: Inverted Health Score Test

Test if Health Score correlation flips sign for rejection models.

**Hypothesis:** For EPCH02/04, lower Health Score = higher win rate.

```sql
SELECT 
    ei.model,
    CASE WHEN ei.model IN ('EPCH01', 'EPCH03') THEN 'continuation' ELSE 'rejection' END as model_type,
    ei.health_score,
    COUNT(*) as trades,
    AVG(CASE WHEN mp.is_winner THEN 1 ELSE 0 END) as win_rate
FROM entry_indicators ei
JOIN mfe_mae_potential mp ON ei.trade_id = mp.trade_id
GROUP BY ei.model, ei.health_score
ORDER BY ei.model, ei.health_score
```

**Metrics:**
- Correlation coefficient by model type
- Win rate at STRONG (8-10) vs CRITICAL (0-3) by model type
- Lift inversion (does CRITICAL outperform STRONG for rejection?)

---

### 8C: Factor Inversion Analysis

For each of the 10 factors, test if the relationship flips for rejection trades.

**Hypothesis:** Some factors (CVD, Volume Delta) may be inverted for rejection.

For each factor:
```
Continuation: healthy_win_rate - unhealthy_win_rate = LIFT_cont
Rejection: healthy_win_rate - unhealthy_win_rate = LIFT_rej

If LIFT_cont > 0 and LIFT_rej < 0 â†’ Factor is INVERTED
```

---

### 8D: Exhaustion Indicator Discovery

Analyze raw indicator values (not healthy/unhealthy) to find rejection-specific patterns.

**Candidate Exhaustion Indicators:**

| Indicator | What It Measures | Rejection Hypothesis |
|-----------|------------------|----------------------|
| CVD Slope (extreme) | Strong buying/selling | High abs(cvd_slope) = exhaustion |
| Volume Delta (vs direction) | Delta against trade | Positive delta for SHORT rejection = exhaustion |
| Vol ROC (spike) | Volume surge | Very high vol_roc = climactic move |
| SMA Spread (extended) | Price extension | Wide spread = overextended |

**Analysis Approach:**
- Bin continuous indicators into quintiles
- Calculate win rate by quintile for rejection models only
- Identify non-linear relationships (e.g., extremes perform better)

---

## 4. IMPLEMENTATION

### File: calculations/indicator_analysis/rejection_dynamics.py

```python
"""
CALC-008: Rejection Dynamics Analysis

Analyzes whether rejection trades (EPCH02/04) require different
indicators than continuation trades (EPCH01/03).

Sub-analyses:
  8A: Time-to-MFE by model type
  8B: Health Score inversion test
  8C: Individual factor inversion
  8D: Exhaustion indicator discovery
"""

import pandas as pd
import numpy as np
from scipy import stats
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
import streamlit as st

import sys
from pathlib import Path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from config import INDICATOR_ANALYSIS_CONFIG, MODEL_TYPES, get_model_type
from .factor_importance import FACTORS, wilson_ci


@dataclass
class TimeToMFEResult:
    """Results for 8A: Time-to-MFE analysis."""
    model_type: str
    total_trades: int
    median_minutes: float
    mean_minutes: float
    pct_within_5min: float
    pct_within_15min: float
    pct_within_30min: float
    distribution: pd.DataFrame  # [minutes_bucket, count, pct]


@dataclass
class InversionTestResult:
    """Results for 8B: Health Score inversion test."""
    model_type: str
    correlation: float
    correlation_pvalue: float
    strong_win_rate: float
    critical_win_rate: float
    is_inverted: bool  # True if CRITICAL > STRONG
    inversion_magnitude: float  # critical_rate - strong_rate


@dataclass  
class FactorInversionResult:
    """Results for 8C: Individual factor inversion."""
    factor_name: str
    continuation_lift: float
    rejection_lift: float
    is_inverted: bool  # True if signs differ
    inversion_strength: str  # 'STRONG', 'MODERATE', 'WEAK', 'NONE'


@dataclass
class ExhaustionIndicator:
    """Results for 8D: Exhaustion indicator discovery."""
    indicator: str
    quintile: int  # 1-5 (1=lowest, 5=highest)
    quintile_label: str
    trades: int
    win_rate: float
    lift_vs_median: float
    is_extreme_better: bool


@dataclass
class RejectionDynamicsResult:
    """Container for all CALC-008 analysis results."""
    # 8A: Time-to-MFE
    continuation_time: TimeToMFEResult
    rejection_time: TimeToMFEResult
    time_comparison: pd.DataFrame
    
    # 8B: Health Score Inversion
    continuation_inversion: InversionTestResult
    rejection_inversion: InversionTestResult
    health_score_by_model: pd.DataFrame
    
    # 8C: Factor Inversion
    factor_inversions: List[FactorInversionResult]
    inverted_factors: List[str]
    non_inverted_factors: List[str]
    
    # 8D: Exhaustion Indicators
    exhaustion_analysis: pd.DataFrame
    candidate_exhaustion_indicators: List[ExhaustionIndicator]
    
    # Summary
    rejection_requires_different_scoring: bool
    recommended_inverted_factors: List[str]


def classify_model_type(model: str) -> str:
    """Classify model as continuation or rejection."""
    return get_model_type(model)


# =============================================================================
# 8A: TIME-TO-MFE ANALYSIS
# =============================================================================

def analyze_time_to_mfe(
    df: pd.DataFrame,
    model_type: str
) -> TimeToMFEResult:
    """
    Analyze time-to-MFE distribution for a model type.
    
    Parameters:
        df: DataFrame with mfe_mae_potential data
        model_type: 'continuation' or 'rejection'
    
    Returns:
        TimeToMFEResult with distribution analysis
    """
    # Filter to model type
    if model_type == 'continuation':
        type_df = df[df['model'].isin(MODEL_TYPES['continuation'])]
    else:
        type_df = df[df['model'].isin(MODEL_TYPES['rejection'])]
    
    # Filter to trades with valid MFE time
    valid_df = type_df[type_df['mfe_potential_time'].notna()].copy()
    
    if len(valid_df) == 0:
        return TimeToMFEResult(
            model_type=model_type,
            total_trades=0,
            median_minutes=0,
            mean_minutes=0,
            pct_within_5min=0,
            pct_within_15min=0,
            pct_within_30min=0,
            distribution=pd.DataFrame()
        )
    
    # Calculate minutes to MFE
    def time_diff_minutes(row):
        try:
            entry = row['entry_time']
            mfe = row['mfe_potential_time']
            
            # Handle time objects
            if hasattr(entry, 'hour'):
                entry_mins = entry.hour * 60 + entry.minute + entry.second / 60
            else:
                entry_mins = 0
                
            if hasattr(mfe, 'hour'):
                mfe_mins = mfe.hour * 60 + mfe.minute + mfe.second / 60
            else:
                mfe_mins = 0
            
            return max(0, mfe_mins - entry_mins)
        except:
            return None
    
    valid_df['minutes_to_mfe'] = valid_df.apply(time_diff_minutes, axis=1)
    valid_df = valid_df[valid_df['minutes_to_mfe'].notna()]
    
    if len(valid_df) == 0:
        return TimeToMFEResult(
            model_type=model_type,
            total_trades=0,
            median_minutes=0,
            mean_minutes=0,
            pct_within_5min=0,
            pct_within_15min=0,
            pct_within_30min=0,
            distribution=pd.DataFrame()
        )
    
    total = len(valid_df)
    
    # Calculate metrics
    median_mins = valid_df['minutes_to_mfe'].median()
    mean_mins = valid_df['minutes_to_mfe'].mean()
    pct_5 = (valid_df['minutes_to_mfe'] <= 5).sum() / total * 100
    pct_15 = (valid_df['minutes_to_mfe'] <= 15).sum() / total * 100
    pct_30 = (valid_df['minutes_to_mfe'] <= 30).sum() / total * 100
    
    # Create distribution buckets
    buckets = [0, 5, 10, 15, 20, 30, 45, 60, 120, 999]
    labels = ['0-5', '5-10', '10-15', '15-20', '20-30', '30-45', '45-60', '60-120', '120+']
    valid_df['time_bucket'] = pd.cut(valid_df['minutes_to_mfe'], bins=buckets, labels=labels)
    
    dist = valid_df.groupby('time_bucket').size().reset_index(name='count')
    dist['pct'] = dist['count'] / total * 100
    
    return TimeToMFEResult(
        model_type=model_type,
        total_trades=total,
        median_minutes=median_mins,
        mean_minutes=mean_mins,
        pct_within_5min=pct_5,
        pct_within_15min=pct_15,
        pct_within_30min=pct_30,
        distribution=dist
    )


# =============================================================================
# 8B: HEALTH SCORE INVERSION TEST
# =============================================================================

def test_health_score_inversion(
    df: pd.DataFrame,
    model_type: str
) -> InversionTestResult:
    """
    Test if Health Score is inverted for a model type.
    
    Parameters:
        df: DataFrame with entry_indicators and outcomes
        model_type: 'continuation' or 'rejection'
    
    Returns:
        InversionTestResult with inversion analysis
    """
    # Filter to model type
    if model_type == 'continuation':
        type_df = df[df['model'].isin(MODEL_TYPES['continuation'])]
    else:
        type_df = df[df['model'].isin(MODEL_TYPES['rejection'])]
    
    valid_df = type_df[type_df['health_score'].notna()].copy()
    
    if len(valid_df) < 30:
        return InversionTestResult(
            model_type=model_type,
            correlation=0,
            correlation_pvalue=1,
            strong_win_rate=0,
            critical_win_rate=0,
            is_inverted=False,
            inversion_magnitude=0
        )
    
    # Calculate correlation
    try:
        corr, pvalue = stats.pearsonr(
            valid_df['health_score'].astype(float),
            valid_df['is_winner'].astype(int)
        )
    except:
        corr, pvalue = 0, 1
    
    # Calculate bucket win rates
    buckets = INDICATOR_ANALYSIS_CONFIG['health_buckets']
    
    strong_df = valid_df[
        (valid_df['health_score'] >= buckets['STRONG'][0]) & 
        (valid_df['health_score'] <= buckets['STRONG'][1])
    ]
    critical_df = valid_df[
        (valid_df['health_score'] >= buckets['CRITICAL'][0]) & 
        (valid_df['health_score'] <= buckets['CRITICAL'][1])
    ]
    
    strong_wr = (strong_df['is_winner'].sum() / len(strong_df) * 100) if len(strong_df) > 0 else 0
    critical_wr = (critical_df['is_winner'].sum() / len(critical_df) * 100) if len(critical_df) > 0 else 0
    
    is_inverted = critical_wr > strong_wr
    inversion_mag = critical_wr - strong_wr
    
    return InversionTestResult(
        model_type=model_type,
        correlation=corr,
        correlation_pvalue=pvalue,
        strong_win_rate=strong_wr,
        critical_win_rate=critical_wr,
        is_inverted=is_inverted,
        inversion_magnitude=inversion_mag
    )


# =============================================================================
# 8C: FACTOR INVERSION ANALYSIS
# =============================================================================

def analyze_factor_inversion(
    df: pd.DataFrame,
    factor_key: str
) -> Optional[FactorInversionResult]:
    """
    Analyze if a single factor is inverted between model types.
    
    Parameters:
        df: DataFrame with entry_indicators and outcomes
        factor_key: Column name for the factor (e.g., 'cvd_slope_healthy')
    
    Returns:
        FactorInversionResult or None
    """
    if factor_key not in df.columns:
        return None
    
    factor_info = FACTORS.get(factor_key)
    if not factor_info:
        return None
    
    valid_df = df[df[factor_key].notna()].copy()
    
    def calc_lift(subset):
        healthy = subset[subset[factor_key] == True]
        unhealthy = subset[subset[factor_key] == False]
        
        if len(healthy) < 10 or len(unhealthy) < 10:
            return 0
        
        h_wr = healthy['is_winner'].sum() / len(healthy) * 100
        u_wr = unhealthy['is_winner'].sum() / len(unhealthy) * 100
        
        return h_wr - u_wr
    
    # Calculate lift for each model type
    cont_df = valid_df[valid_df['model'].isin(MODEL_TYPES['continuation'])]
    rej_df = valid_df[valid_df['model'].isin(MODEL_TYPES['rejection'])]
    
    cont_lift = calc_lift(cont_df) if len(cont_df) >= 30 else 0
    rej_lift = calc_lift(rej_df) if len(rej_df) >= 30 else 0
    
    # Determine if inverted
    is_inverted = (cont_lift > 0 and rej_lift < 0) or (cont_lift < 0 and rej_lift > 0)
    
    # Classify inversion strength
    if is_inverted:
        diff = abs(cont_lift - rej_lift)
        if diff > 15:
            strength = 'STRONG'
        elif diff > 8:
            strength = 'MODERATE'
        elif diff > 3:
            strength = 'WEAK'
        else:
            strength = 'NONE'
            is_inverted = False
    else:
        strength = 'NONE'
    
    return FactorInversionResult(
        factor_name=factor_info['name'],
        continuation_lift=cont_lift,
        rejection_lift=rej_lift,
        is_inverted=is_inverted,
        inversion_strength=strength
    )


# =============================================================================
# 8D: EXHAUSTION INDICATOR DISCOVERY
# =============================================================================

def discover_exhaustion_indicators(
    df: pd.DataFrame,
    indicator: str
) -> List[ExhaustionIndicator]:
    """
    Analyze an indicator by quintiles for rejection trades.
    
    Parameters:
        df: DataFrame with entry_indicators and outcomes
        indicator: Raw indicator column name (e.g., 'cvd_slope')
    
    Returns:
        List of ExhaustionIndicator for each quintile
    """
    # Filter to rejection models only
    rej_df = df[df['model'].isin(MODEL_TYPES['rejection'])].copy()
    
    if indicator not in rej_df.columns or len(rej_df) < 50:
        return []
    
    valid_df = rej_df[rej_df[indicator].notna()].copy()
    
    if len(valid_df) < 50:
        return []
    
    # Create quintiles
    try:
        valid_df['quintile'] = pd.qcut(valid_df[indicator], q=5, labels=[1, 2, 3, 4, 5], duplicates='drop')
    except:
        return []
    
    # Calculate win rate by quintile
    results = []
    median_wr = valid_df['is_winner'].mean() * 100
    
    quintile_labels = {
        1: 'Lowest (Q1)',
        2: 'Low (Q2)',
        3: 'Middle (Q3)',
        4: 'High (Q4)',
        5: 'Highest (Q5)'
    }
    
    for q in range(1, 6):
        q_df = valid_df[valid_df['quintile'] == q]
        if len(q_df) < 5:
            continue
        
        wr = q_df['is_winner'].sum() / len(q_df) * 100
        lift = wr - median_wr
        
        results.append(ExhaustionIndicator(
            indicator=indicator,
            quintile=q,
            quintile_label=quintile_labels[q],
            trades=len(q_df),
            win_rate=wr,
            lift_vs_median=lift,
            is_extreme_better=(q in [1, 5] and lift > 5)
        ))
    
    return results


# =============================================================================
# MAIN ANALYSIS FUNCTION
# =============================================================================

def analyze_rejection_dynamics(
    entry_df: pd.DataFrame,
    mfe_mae_df: pd.DataFrame
) -> RejectionDynamicsResult:
    """
    Main analysis function for CALC-008.
    
    Parameters:
        entry_df: DataFrame from entry_indicators with outcomes
        mfe_mae_df: DataFrame from mfe_mae_potential
    
    Returns:
        RejectionDynamicsResult with all analysis outputs
    """
    # 8A: Time-to-MFE
    cont_time = analyze_time_to_mfe(mfe_mae_df, 'continuation')
    rej_time = analyze_time_to_mfe(mfe_mae_df, 'rejection')
    
    time_comparison = pd.DataFrame([
        {
            'Model Type': 'Continuation',
            'Trades': cont_time.total_trades,
            'Median Minutes': cont_time.median_minutes,
            'â‰¤5min': f"{cont_time.pct_within_5min:.1f}%",
            'â‰¤15min': f"{cont_time.pct_within_15min:.1f}%",
            'â‰¤30min': f"{cont_time.pct_within_30min:.1f}%"
        },
        {
            'Model Type': 'Rejection',
            'Trades': rej_time.total_trades,
            'Median Minutes': rej_time.median_minutes,
            'â‰¤5min': f"{rej_time.pct_within_5min:.1f}%",
            'â‰¤15min': f"{rej_time.pct_within_15min:.1f}%",
            'â‰¤30min': f"{rej_time.pct_within_30min:.1f}%"
        }
    ])
    
    # 8B: Health Score Inversion
    cont_inversion = test_health_score_inversion(entry_df, 'continuation')
    rej_inversion = test_health_score_inversion(entry_df, 'rejection')
    
    # Create health score by model breakdown
    hs_data = []
    for model in entry_df['model'].unique():
        model_df = entry_df[entry_df['model'] == model]
        for bucket_name, (low, high) in INDICATOR_ANALYSIS_CONFIG['health_buckets'].items():
            bucket_df = model_df[(model_df['health_score'] >= low) & (model_df['health_score'] <= high)]
            if len(bucket_df) > 0:
                wr = bucket_df['is_winner'].sum() / len(bucket_df) * 100
                hs_data.append({
                    'model': model,
                    'model_type': classify_model_type(model),
                    'bucket': bucket_name,
                    'trades': len(bucket_df),
                    'win_rate': wr
                })
    
    health_score_by_model = pd.DataFrame(hs_data)
    
    # 8C: Factor Inversion
    factor_inversions = []
    for factor_key in FACTORS.keys():
        result = analyze_factor_inversion(entry_df, factor_key)
        if result:
            factor_inversions.append(result)
    
    inverted = [f.factor_name for f in factor_inversions if f.is_inverted]
    non_inverted = [f.factor_name for f in factor_inversions if not f.is_inverted]
    
    # 8D: Exhaustion Indicators
    exhaustion_results = []
    for indicator in ['cvd_slope', 'vol_delta', 'vol_roc', 'sma_spread']:
        results = discover_exhaustion_indicators(entry_df, indicator)
        exhaustion_results.extend(results)
    
    exhaustion_df = pd.DataFrame([{
        'indicator': e.indicator,
        'quintile': e.quintile_label,
        'trades': e.trades,
        'win_rate': e.win_rate,
        'lift': e.lift_vs_median,
        'extreme_better': e.is_extreme_better
    } for e in exhaustion_results])
    
    candidate_exhaustion = [e for e in exhaustion_results if e.is_extreme_better]
    
    # Summary determination
    rejection_different = (
        rej_inversion.is_inverted or 
        len(inverted) >= 2 or
        (rej_time.pct_within_5min - cont_time.pct_within_5min) > 10
    )
    
    return RejectionDynamicsResult(
        continuation_time=cont_time,
        rejection_time=rej_time,
        time_comparison=time_comparison,
        continuation_inversion=cont_inversion,
        rejection_inversion=rej_inversion,
        health_score_by_model=health_score_by_model,
        factor_inversions=factor_inversions,
        inverted_factors=inverted,
        non_inverted_factors=non_inverted,
        exhaustion_analysis=exhaustion_df,
        candidate_exhaustion_indicators=candidate_exhaustion,
        rejection_requires_different_scoring=rejection_different,
        recommended_inverted_factors=inverted
    )


# =============================================================================
# STREAMLIT RENDERING FUNCTIONS
# =============================================================================

def render_time_to_mfe_comparison(result: RejectionDynamicsResult):
    """Render time-to-MFE comparison charts."""
    import plotly.graph_objects as go
    from plotly.subplots import make_subplots
    
    st.markdown("### 8A: Time-to-MFE Analysis")
    st.markdown("*Do rejection trades reach MFE faster?*")
    
    # Summary table
    st.dataframe(result.time_comparison, use_container_width=True, hide_index=True)
    
    # Histogram comparison
    fig = make_subplots(rows=1, cols=2, subplot_titles=['Continuation', 'Rejection'])
    
    if not result.continuation_time.distribution.empty:
        fig.add_trace(
            go.Bar(
                x=result.continuation_time.distribution['time_bucket'],
                y=result.continuation_time.distribution['pct'],
                marker_color='#7c3aed',
                name='Continuation'
            ),
            row=1, col=1
        )
    
    if not result.rejection_time.distribution.empty:
        fig.add_trace(
            go.Bar(
                x=result.rejection_time.distribution['time_bucket'],
                y=result.rejection_time.distribution['pct'],
                marker_color='#f59e0b',
                name='Rejection'
            ),
            row=1, col=2
        )
    
    fig.update_layout(
        title="Time-to-MFE Distribution by Model Type",
        template="plotly_dark",
        paper_bgcolor="#16213e",
        plot_bgcolor="#1a1a2e",
        font=dict(color="#e0e0e0"),
        showlegend=False
    )
    
    st.plotly_chart(fig, use_container_width=True)


def render_health_score_inversion(result: RejectionDynamicsResult):
    """Render health score inversion analysis."""
    import plotly.graph_objects as go
    
    st.markdown("### 8B: Health Score Inversion Test")
    st.markdown("*Is Health Score negatively correlated for rejection trades?*")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("**Continuation Models (EPCH01/03)**")
        ci = result.continuation_inversion
        st.metric("Correlation", f"{ci.correlation:.3f}")
        st.metric("STRONG Win Rate", f"{ci.strong_win_rate:.1f}%")
        st.metric("CRITICAL Win Rate", f"{ci.critical_win_rate:.1f}%")
        if ci.is_inverted:
            st.error(f"âš ï¸ INVERTED: CRITICAL beats STRONG by {ci.inversion_magnitude:.1f}pp")
        else:
            st.success(f"âœ“ Normal: STRONG beats CRITICAL by {-ci.inversion_magnitude:.1f}pp")
    
    with col2:
        st.markdown("**Rejection Models (EPCH02/04)**")
        ri = result.rejection_inversion
        st.metric("Correlation", f"{ri.correlation:.3f}")
        st.metric("STRONG Win Rate", f"{ri.strong_win_rate:.1f}%")
        st.metric("CRITICAL Win Rate", f"{ri.critical_win_rate:.1f}%")
        if ri.is_inverted:
            st.error(f"âš ï¸ INVERTED: CRITICAL beats STRONG by {ri.inversion_magnitude:.1f}pp")
        else:
            st.success(f"âœ“ Normal: STRONG beats CRITICAL by {-ri.inversion_magnitude:.1f}pp")
    
    # Heatmap
    if not result.health_score_by_model.empty:
        import plotly.express as px
        
        pivot = result.health_score_by_model.pivot(
            index='model',
            columns='bucket',
            values='win_rate'
        )
        
        bucket_order = ['CRITICAL', 'WEAK', 'MODERATE', 'STRONG']
        pivot = pivot.reindex(columns=[b for b in bucket_order if b in pivot.columns])
        
        fig = px.imshow(
            pivot,
            labels=dict(color="Win Rate %"),
            color_continuous_scale='RdYlGn',
            text_auto='.1f'
        )
        
        fig.update_layout(
            title="Win Rate by Model and Health Bucket",
            template="plotly_dark",
            paper_bgcolor="#16213e",
            plot_bgcolor="#1a1a2e",
            font=dict(color="#e0e0e0")
        )
        
        st.plotly_chart(fig, use_container_width=True)


def render_factor_inversion_table(result: RejectionDynamicsResult):
    """Render factor inversion analysis."""
    st.markdown("### 8C: Factor Inversion Analysis")
    st.markdown("*Which factors have inverted meaning for rejection trades?*")
    
    data = [{
        'Factor': fi.factor_name,
        'Continuation Lift': f"{fi.continuation_lift:+.1f}pp",
        'Rejection Lift': f"{fi.rejection_lift:+.1f}pp",
        'Inverted': 'ðŸ”„ YES' if fi.is_inverted else 'No',
        'Strength': fi.inversion_strength
    } for fi in result.factor_inversions]
    
    df = pd.DataFrame(data)
    st.dataframe(df, use_container_width=True, hide_index=True)
    
    if result.inverted_factors:
        st.warning(f"**Inverted Factors:** {', '.join(result.inverted_factors)}")
        st.info("These factors should use OPPOSITE logic for rejection trades in DOW AI scoring.")


def render_exhaustion_analysis(result: RejectionDynamicsResult):
    """Render exhaustion indicator discovery."""
    st.markdown("### 8D: Exhaustion Indicator Discovery")
    st.markdown("*Do extreme indicator values predict rejection success?*")
    
    if result.exhaustion_analysis.empty:
        st.info("Insufficient data for exhaustion analysis")
        return
    
    st.dataframe(result.exhaustion_analysis, use_container_width=True, hide_index=True)
    
    if result.candidate_exhaustion_indicators:
        st.success("**Candidate Exhaustion Indicators:**")
        for e in result.candidate_exhaustion_indicators:
            st.markdown(f"- **{e.indicator}** {e.quintile_label}: {e.win_rate:.1f}% win rate (+{e.lift_vs_median:.1f}pp vs median)")


def render_calc_008_section(entry_df: pd.DataFrame, mfe_mae_df: pd.DataFrame):
    """
    Main render function for CALC-008 section in Streamlit.
    
    Parameters:
        entry_df: DataFrame from entry_indicators with outcomes
        mfe_mae_df: DataFrame from mfe_mae_potential
    """
    st.subheader("CALC-008: Rejection Dynamics Analysis")
    st.markdown("*Do rejection trades require different indicators?*")
    
    try:
        result = analyze_rejection_dynamics(entry_df, mfe_mae_df)
        
        # 8A: Time-to-MFE
        render_time_to_mfe_comparison(result)
        
        st.divider()
        
        # 8B: Health Score Inversion
        render_health_score_inversion(result)
        
        st.divider()
        
        # 8C: Factor Inversion
        render_factor_inversion_table(result)
        
        st.divider()
        
        # 8D: Exhaustion Indicators
        render_exhaustion_analysis(result)
        
        # Summary
        st.divider()
        st.markdown("### ðŸ“Š CALC-008 Verdict")
        
        if result.rejection_requires_different_scoring:
            st.error("âš ï¸ **REJECTION TRADES REQUIRE DIFFERENT SCORING**")
            st.markdown("""
            The analysis indicates rejection trades (EPCH02/04) behave differently:
            - Health Score may be inverted (low scores = better)
            - Some factors have opposite meaning
            - Consider building a separate "Exhaustion Score" for rejection models
            """)
            
            if result.inverted_factors:
                st.markdown(f"**Factors to invert for rejection:** {', '.join(result.inverted_factors)}")
        else:
            st.success("âœ“ **Current scoring system appears valid for both model types**")
            st.markdown("No significant inversion detected. Continue using unified Health Score.")
        
        return result
        
    except Exception as e:
        st.error(f"Error in CALC-008 analysis: {e}")
        import traceback
        st.code(traceback.format_exc())
        return None
```

---

## 5. UPDATE app.py

Wire CALC-008 into the Indicator Analysis tab:

```python
# In the calc8 sub-tab section:

with calc8:
    st.subheader("CALC-008: Rejection Dynamics Analysis")
    st.markdown("*Do rejection trades require different indicators?*")
    
    if len(entry_df) > 0:
        from calculations.indicator_analysis import render_calc_008_section
        
        # Also need mfe_mae_potential data
        mfe_mae_data = load_mfe_mae_potential()  # Use existing function
        mfe_mae_df = pd.DataFrame(mfe_mae_data) if mfe_mae_data else pd.DataFrame()
        
        if not mfe_mae_df.empty:
            calc_008_result = render_calc_008_section(entry_df, mfe_mae_df)
        else:
            st.warning("No MFE/MAE data available for CALC-008 analysis")
    else:
        st.warning("No entry indicator data available for CALC-008 analysis")
```

---

## 6. EXPECTED OUTPUT EXAMPLE

```
CALC-008: Rejection Dynamics Analysis

8A: Time-to-MFE Analysis
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Model Type    â”‚ Trades â”‚ Median Min â”‚ â‰¤5min  â”‚ â‰¤15min  â”‚ â‰¤30min  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Continuation  â”‚   321  â”‚   18.5     â”‚ 12.4%  â”‚  38.2%  â”‚  62.1%  â”‚
â”‚ Rejection     â”‚   801  â”‚   11.2     â”‚ 28.6%  â”‚  54.3%  â”‚  78.9%  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âœ… Rejection trades reach MFE faster (11.2 vs 18.5 minutes)

8B: Health Score Inversion Test
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               â”‚ Correlation â”‚ STRONG Win%â”‚ CRITICAL Win%  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Continuation  â”‚   +0.18     â”‚   56.2%    â”‚     41.8%      â”‚
â”‚ Rejection     â”‚   -0.12     â”‚   42.1%    â”‚     54.6%      â”‚ â† INVERTED!
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ CRITICAL beats STRONG by +12.5pp for rejection trades

8C: Factor Inversion Analysis
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Factor          â”‚ Cont. Lift   â”‚ Rej. Lift    â”‚ Inverted â”‚ Strength â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CVD Slope       â”‚   +8.2pp     â”‚   -6.4pp     â”‚ ðŸ”„ YES   â”‚ STRONG   â”‚
â”‚ Volume Delta    â”‚   +5.1pp     â”‚   -4.2pp     â”‚ ðŸ”„ YES   â”‚ MODERATE â”‚
â”‚ SMA Alignment   â”‚   +4.8pp     â”‚   -2.1pp     â”‚ ðŸ”„ YES   â”‚ WEAK     â”‚
â”‚ VWAP Position   â”‚   +9.3pp     â”‚   +7.8pp     â”‚ No       â”‚ NONE     â”‚
â”‚ H4 Structure    â”‚   +6.1pp     â”‚   +5.2pp     â”‚ No       â”‚ NONE     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

VERDICT: âš ï¸ REJECTION TRADES REQUIRE DIFFERENT SCORING
- Factors to invert: CVD Slope, Volume Delta, SMA Alignment
- Consider building separate "Exhaustion Score" for EPCH02/04
```

---

## 7. NOTES FOR CLAUDE CODE

1. **Model Type Helper**: Use `get_model_type()` from config.py for consistent classification.

2. **Time Calculation**: Handle time objects carefully - they may be strings or datetime.time objects.

3. **Minimum Samples**: Require at least 30 trades per group for statistical validity.

4. **Inversion Threshold**: Consider factor inverted only if lift signs differ AND magnitude > 3pp.

5. **Exhaustion Discovery**: Use quintiles (not healthy/unhealthy) to find non-linear relationships.

6. **Verdict Logic**: Flag "different scoring needed" if:
   - Health Score correlation flips sign for rejection
   - 2+ factors are inverted
   - Time-to-MFE differs by >10pp within 5 minutes

---

**END OF DOCUMENT 6**