# INDICATOR ANALYSIS TAB SETUP
## Claude Code Implementation Instructions
### Epoch Trading System - Monte AI Indicator Analysis Module

**Document Version:** 1.0  
**Created:** 2026-01-03  
**Author:** Monte AI / Silva  
**Target Application:** 12_indicator_analysis  

---

## 1. OBJECTIVE

Create a new "Indicator Analysis" tab in the Streamlit application that will house CALC-005 through CALC-008 modules. This tab focuses on understanding how entry indicators correlate with trade outcomes.

### Purpose
1. **Separate Concern** - Trade management analysis (Tab 1) vs Entry indicator analysis (Tab 2)
2. **Foundation** - Prepare UI structure for CALC-005 through CALC-008
3. **Config Update** - Add indicator analysis specific configuration

---

## 2. PROJECT CONTEXT

### Directory Structure
```
C:\XIIITradingSystems\Epoch\02_zone_system\12_indicator_analysis\
‚îú‚îÄ‚îÄ app.py                          # MODIFY - Add new tab
‚îú‚îÄ‚îÄ config.py                       # MODIFY - Add indicator analysis config
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îî‚îÄ‚îÄ supabase_client.py          # MODIFY - Add fetch_entry_indicators()
‚îú‚îÄ‚îÄ calculations/
‚îÇ   ‚îú‚îÄ‚îÄ trade_management/           # Existing (CALC-001 to CALC-004)
‚îÇ   ‚îî‚îÄ‚îÄ indicator_analysis/         # NEW DIRECTORY
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îî‚îÄ‚îÄ (future CALC-005+ modules)
‚îî‚îÄ‚îÄ components/
    ‚îî‚îÄ‚îÄ indicator_charts.py         # NEW FILE - Indicator-specific charts
```

---

## 3. IMPLEMENTATION TASKS

### Task 1: Update config.py

Add indicator analysis configuration section:

```python
# =============================================================================
# INDICATOR ANALYSIS CONFIGURATION (CALC-005+)
# =============================================================================

INDICATOR_ANALYSIS_CONFIG = {
    # Health Score Buckets for CALC-005
    "health_buckets": {
        "CRITICAL": (0, 3),
        "WEAK": (4, 5),
        "MODERATE": (6, 7),
        "STRONG": (8, 10)
    },
    
    # Minimum trades for statistical relevance
    "min_trades_for_analysis": 30,
    
    # Confidence interval for charts
    "confidence_interval": 0.95,
    
    # Individual indicator thresholds (for CALC-006)
    "indicator_thresholds": {
        "vol_roc": 20.0,           # Above average threshold
        "cvd_slope_bullish": 0.1,  # Rising threshold
        "cvd_slope_bearish": -0.1, # Falling threshold
        "sma_widening": 1.1,       # Momentum ratio threshold
    },
    
    # Time-to-MFE buckets for CALC-008 (in minutes)
    "time_to_mfe_buckets": {
        "FAST": (0, 5),      # Within 1 M5 bar
        "QUICK": (5, 15),    # Within 3 M5 bars
        "NORMAL": (15, 30),  # Within 6 M5 bars
        "SLOW": (30, 999)    # Beyond 30 minutes
    }
}

# Health Score Factor Groups (for CALC-006 grouping)
HEALTH_FACTOR_GROUPS = {
    "structure": ["h4_structure", "h1_structure", "m15_structure", "m5_structure"],
    "volume": ["vol_roc", "vol_delta", "cvd_slope"],
    "price": ["sma_alignment", "sma_momentum", "vwap_position"]
}

# Model Type Classification
MODEL_TYPES = {
    "continuation": ["EPCH01", "EPCH03"],
    "rejection": ["EPCH02", "EPCH04"]
}

def get_model_type(model: str) -> str:
    """Return 'continuation' or 'rejection' based on model."""
    if model in MODEL_TYPES["continuation"]:
        return "continuation"
    elif model in MODEL_TYPES["rejection"]:
        return "rejection"
    return "unknown"
```

---

### Task 2: Update data/supabase_client.py

Add method to fetch entry indicators:

```python
def fetch_entry_indicators(
    self,
    date_from: Optional[date] = None,
    date_to: Optional[date] = None,
    models: Optional[List[str]] = None,
    directions: Optional[List[str]] = None,
    tickers: Optional[List[str]] = None,
    health_score_min: Optional[int] = None,
    health_score_max: Optional[int] = None,
    limit: int = 50000
) -> List[Dict]:
    """
    Fetch entry indicator snapshots.
    
    Parameters:
        date_from: Start date filter
        date_to: End date filter
        models: List of models to include
        directions: List of directions to include
        tickers: List of tickers to include
        health_score_min: Minimum health score filter
        health_score_max: Maximum health score filter
        limit: Maximum rows to return
    
    Returns:
        List of entry indicator records
    """
    try:
        query = """
            SELECT 
                ei.*,
                mp.mfe_r_potential,
                mp.mae_r_potential,
                mp.mfe_potential_time,
                mp.mae_potential_time,
                mp.is_winner,
                mp.pnl_r
            FROM entry_indicators ei
            JOIN mfe_mae_potential mp ON ei.trade_id = mp.trade_id
            WHERE 1=1
        """
        params = []
        param_idx = 1
        
        if date_from:
            query += f" AND ei.date >= ${param_idx}"
            params.append(date_from)
            param_idx += 1
            
        if date_to:
            query += f" AND ei.date <= ${param_idx}"
            params.append(date_to)
            param_idx += 1
            
        if models:
            query += f" AND ei.model = ANY(${param_idx})"
            params.append(models)
            param_idx += 1
            
        if directions:
            query += f" AND ei.direction = ANY(${param_idx})"
            params.append(directions)
            param_idx += 1
            
        if tickers:
            query += f" AND ei.ticker = ANY(${param_idx})"
            params.append(tickers)
            param_idx += 1
            
        if health_score_min is not None:
            query += f" AND ei.health_score >= ${param_idx}"
            params.append(health_score_min)
            param_idx += 1
            
        if health_score_max is not None:
            query += f" AND ei.health_score <= ${param_idx}"
            params.append(health_score_max)
            param_idx += 1
        
        query += f" ORDER BY ei.date DESC, ei.entry_time DESC LIMIT ${param_idx}"
        params.append(limit)
        
        self.cursor.execute(query, params)
        columns = [desc[0] for desc in self.cursor.description]
        rows = self.cursor.fetchall()
        
        return [dict(zip(columns, row)) for row in rows]
        
    except Exception as e:
        self.conn.rollback()
        print(f"Error fetching entry indicators: {e}")
        return []
```

---

### Task 3: Create calculations/indicator_analysis/__init__.py

```python
"""
Indicator Analysis Module (CALC-005 through CALC-008)

This module analyzes entry indicators and their correlation with trade outcomes.

Modules:
    - health_correlation (CALC-005): Health Score ‚Üí Win Rate correlation
    - factor_importance (CALC-006): Individual indicator predictiveness
    - indicator_progression (CALC-007): Entry ‚Üí MFE/MAE indicator changes
    - rejection_dynamics (CALC-008): Rejection trade specific analysis
"""

from .health_correlation import *
from .factor_importance import *
from .indicator_progression import *
from .rejection_dynamics import *
```

---

### Task 4: Create components/indicator_charts.py

```python
"""
Indicator Analysis Chart Components

Plotly chart rendering functions for indicator analysis with dark theme.
"""

import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import pandas as pd
import numpy as np
from typing import Dict, List, Optional

# Theme Configuration (matching existing charts.py)
THEME = {
    "background": "#1a1a2e",
    "paper": "#16213e",
    "text": "#e0e0e0",
    "grid": "#2d3748",
    "win_color": "#26a69a",
    "loss_color": "#ef5350",
    "neutral_color": "#ffa726",
    "primary": "#7c3aed",
    "secondary": "#3b82f6",
    "accent": "#10b981"
}


def render_health_correlation_curve(df: pd.DataFrame) -> go.Figure:
    """
    Line chart showing win rate by health score with confidence bands.
    
    Parameters:
        df: DataFrame with columns [health_score, win_rate, trades, ci_lower, ci_upper]
    
    Returns:
        Plotly Figure object
    """
    fig = go.Figure()
    
    # Confidence band
    fig.add_trace(go.Scatter(
        x=list(df['health_score']) + list(df['health_score'][::-1]),
        y=list(df['ci_upper']) + list(df['ci_lower'][::-1]),
        fill='toself',
        fillcolor='rgba(124, 58, 237, 0.2)',
        line=dict(color='rgba(255,255,255,0)'),
        name='95% CI',
        showlegend=True
    ))
    
    # Main line
    fig.add_trace(go.Scatter(
        x=df['health_score'],
        y=df['win_rate'],
        mode='lines+markers',
        name='Win Rate',
        line=dict(color=THEME['primary'], width=3),
        marker=dict(size=10, color=THEME['primary'])
    ))
    
    # 50% reference line
    fig.add_hline(
        y=50, 
        line_dash="dash", 
        line_color=THEME['neutral_color'],
        annotation_text="50% Baseline"
    )
    
    fig.update_layout(
        title="Win Rate by Health Score",
        xaxis_title="Health Score at Entry",
        yaxis_title="Win Rate (%)",
        template="plotly_dark",
        paper_bgcolor=THEME['paper'],
        plot_bgcolor=THEME['background'],
        font=dict(color=THEME['text']),
        xaxis=dict(
            tickmode='linear',
            tick0=0,
            dtick=1,
            range=[-0.5, 10.5]
        ),
        yaxis=dict(range=[0, 100])
    )
    
    return fig


def render_health_bucket_bars(df: pd.DataFrame) -> go.Figure:
    """
    Grouped bar chart showing win rate by health bucket and model.
    
    Parameters:
        df: DataFrame with columns [health_bucket, model, win_rate, trades]
    
    Returns:
        Plotly Figure object
    """
    fig = px.bar(
        df,
        x='health_bucket',
        y='win_rate',
        color='model',
        barmode='group',
        text='trades',
        category_orders={
            'health_bucket': ['CRITICAL (0-3)', 'WEAK (4-5)', 'MODERATE (6-7)', 'STRONG (8-10)']
        }
    )
    
    fig.update_traces(texttemplate='n=%{text}', textposition='outside')
    
    fig.update_layout(
        title="Win Rate by Health Score Bucket",
        xaxis_title="Health Score Bucket",
        yaxis_title="Win Rate (%)",
        template="plotly_dark",
        paper_bgcolor=THEME['paper'],
        plot_bgcolor=THEME['background'],
        font=dict(color=THEME['text']),
        yaxis=dict(range=[0, 100])
    )
    
    # Add 50% reference line
    fig.add_hline(y=50, line_dash="dash", line_color=THEME['neutral_color'])
    
    return fig


def render_factor_importance_bars(df: pd.DataFrame) -> go.Figure:
    """
    Horizontal bar chart showing factor importance ranking.
    
    Parameters:
        df: DataFrame with columns [factor, lift, healthy_win_rate, unhealthy_win_rate]
    
    Returns:
        Plotly Figure object
    """
    df_sorted = df.sort_values('lift', ascending=True)
    
    colors = [THEME['win_color'] if x > 0 else THEME['loss_color'] for x in df_sorted['lift']]
    
    fig = go.Figure(go.Bar(
        x=df_sorted['lift'],
        y=df_sorted['factor'],
        orientation='h',
        marker_color=colors,
        text=[f"+{x:.1f}pp" if x > 0 else f"{x:.1f}pp" for x in df_sorted['lift']],
        textposition='outside'
    ))
    
    fig.add_vline(x=0, line_color=THEME['text'], line_width=1)
    
    fig.update_layout(
        title="Indicator Predictiveness (Lift vs Baseline)",
        xaxis_title="Win Rate Lift (percentage points)",
        yaxis_title="Indicator",
        template="plotly_dark",
        paper_bgcolor=THEME['paper'],
        plot_bgcolor=THEME['background'],
        font=dict(color=THEME['text'])
    )
    
    return fig


def render_time_to_mfe_histogram(df: pd.DataFrame, model_type: str = "all") -> go.Figure:
    """
    Histogram showing time-to-MFE distribution.
    
    Parameters:
        df: DataFrame with column [time_to_mfe_minutes]
        model_type: Filter label for title
    
    Returns:
        Plotly Figure object
    """
    fig = px.histogram(
        df,
        x='time_to_mfe_minutes',
        nbins=30,
        color_discrete_sequence=[THEME['primary']]
    )
    
    # Add vertical lines for buckets
    fig.add_vline(x=5, line_dash="dash", line_color=THEME['win_color'], 
                  annotation_text="1 M5 bar")
    fig.add_vline(x=15, line_dash="dash", line_color=THEME['neutral_color'],
                  annotation_text="3 M5 bars")
    fig.add_vline(x=30, line_dash="dash", line_color=THEME['loss_color'],
                  annotation_text="6 M5 bars")
    
    fig.update_layout(
        title=f"Time to MFE Distribution ({model_type})",
        xaxis_title="Minutes from Entry to MFE",
        yaxis_title="Trade Count",
        template="plotly_dark",
        paper_bgcolor=THEME['paper'],
        plot_bgcolor=THEME['background'],
        font=dict(color=THEME['text'])
    )
    
    return fig


def render_indicator_progression_lines(df: pd.DataFrame) -> go.Figure:
    """
    Line chart showing indicator progression from entry to MFE/MAE.
    
    Parameters:
        df: DataFrame with columns [event, indicator_value, outcome]
    
    Returns:
        Plotly Figure object
    """
    fig = go.Figure()
    
    # Winners path
    winners = df[df['outcome'] == 'WIN']
    fig.add_trace(go.Scatter(
        x=winners['event'],
        y=winners['indicator_value'],
        mode='lines+markers',
        name='Winners',
        line=dict(color=THEME['win_color'], width=3),
        marker=dict(size=10)
    ))
    
    # Losers path
    losers = df[df['outcome'] == 'LOSS']
    fig.add_trace(go.Scatter(
        x=losers['event'],
        y=losers['indicator_value'],
        mode='lines+markers',
        name='Losers',
        line=dict(color=THEME['loss_color'], width=3),
        marker=dict(size=10)
    ))
    
    fig.update_layout(
        title="Indicator Progression: Winners vs Losers",
        xaxis_title="Event",
        yaxis_title="Indicator Value",
        template="plotly_dark",
        paper_bgcolor=THEME['paper'],
        plot_bgcolor=THEME['background'],
        font=dict(color=THEME['text'])
    )
    
    return fig
```

---

### Task 5: Update app.py - Add Indicator Analysis Tab

Locate the tab structure in app.py and add the new tab:

```python
# Find existing tab creation (approximately):
# tab1, tab2 = st.tabs(["Metrics Overview", "Archived Analysis"])

# Change to:
tab1, tab2, tab3 = st.tabs(["Metrics Overview", "Indicator Analysis", "Archived Analysis"])

# Add new tab content after tab1 (Metrics Overview) block:

with tab2:
    st.header("Indicator Analysis")
    st.markdown("*Entry indicator correlation with trade outcomes*")
    
    # Check if entry_indicators data exists
    @st.cache_data(ttl=300)
    def load_entry_indicators():
        client = get_client()
        return client.fetch_entry_indicators(
            date_from=filters.get('date_from'),
            date_to=filters.get('date_to'),
            models=filters.get('models'),
            directions=filters.get('directions'),
            tickers=filters.get('tickers')
        )
    
    entry_data = load_entry_indicators()
    
    if not entry_data:
        st.warning("‚ö†Ô∏è No entry indicator data available. Run the entry_indicators population script first.")
        st.info("""
        **To populate entry_indicators table:**
        ```bash
        cd C:\\XIIITradingSystems\\Epoch\\02_zone_system\\12_indicator_analysis
        python -m calculations.indicator_analysis.entry_indicators.runner
        ```
        """)
    else:
        entry_df = pd.DataFrame(entry_data)
        
        # Sub-tabs for different analyses
        calc5, calc6, calc7, calc8 = st.tabs([
            "Health Correlation (005)",
            "Factor Importance (006)", 
            "Progression (007)",
            "Rejection Dynamics (008)"
        ])
        
        with calc5:
            st.subheader("CALC-005: Health Score ‚Üí Outcome Correlation")
            st.markdown("*Does higher Health Score predict higher win rate?*")
            
            # Placeholder for CALC-005 implementation
            st.info("üìä CALC-005 module pending implementation")
            
        with calc6:
            st.subheader("CALC-006: Individual Indicator Predictiveness")
            st.markdown("*Which of the 10 factors actually matter?*")
            
            # Placeholder for CALC-006 implementation
            st.info("üìä CALC-006 module pending implementation")
            
        with calc7:
            st.subheader("CALC-007: Indicator Progression Analysis")
            st.markdown("*What changes between entry and outcome?*")
            
            # Placeholder for CALC-007 implementation
            st.info("üìä CALC-007 module pending implementation")
            
        with calc8:
            st.subheader("CALC-008: Rejection Dynamics Analysis")
            st.markdown("*Do rejection trades require different indicators?*")
            
            # Placeholder for CALC-008 implementation
            st.info("üìä CALC-008 module pending implementation")
        
        # Monte AI Section at bottom
        st.divider()
        st.subheader("ü§ñ Monte AI - Indicator Analysis")
        # Placeholder for Monte AI integration
        st.info("Monte AI indicator analysis integration pending")
```

---

## 4. FILE CREATION SUMMARY

| File | Action | Purpose |
|------|--------|---------|
| `config.py` | MODIFY | Add INDICATOR_ANALYSIS_CONFIG |
| `data/supabase_client.py` | MODIFY | Add fetch_entry_indicators() |
| `calculations/indicator_analysis/__init__.py` | CREATE | Module initialization |
| `components/indicator_charts.py` | CREATE | Indicator-specific charts |
| `app.py` | MODIFY | Add Indicator Analysis tab |

---

## 5. VERIFICATION STEPS

After implementation:

1. **Run application:**
   ```bash
   streamlit run app.py --server.port 8502
   ```

2. **Verify tab appears:**
   - Should see 3 tabs: "Metrics Overview", "Indicator Analysis", "Archived Analysis"

3. **Verify empty state:**
   - Indicator Analysis tab should show warning about missing data

4. **Verify config loads:**
   ```python
   from config import INDICATOR_ANALYSIS_CONFIG, MODEL_TYPES
   print(INDICATOR_ANALYSIS_CONFIG)
   ```

---

## 6. NOTES FOR CLAUDE CODE

1. **Theme Consistency**: Match existing dark theme colors from components/charts.py

2. **Import Patterns**: Follow existing import patterns in app.py

3. **Cache Decorator**: Use @st.cache_data(ttl=300) for data loading functions

4. **Error Handling**: Include try/except blocks in database methods

5. **Placeholder Pattern**: Use st.info() for pending implementations to maintain clean UI

---

**END OF DOCUMENT 1**