================================================================================
EPOCH TRADING SYSTEM - CALC-009: STOP TYPE ANALYSIS
Implementation Specification for Claude Code
XIII Trading LLC
Generated: 2026-01-09
================================================================================

PURPOSE:
--------
Analyze 6 different stop placement methods to determine which provides the best
risk-adjusted returns. This calculation becomes the FOUNDATION for all downstream
indicator analysis - we must first identify stops with structural edge before
testing if indicators improve that edge.

WORKFLOW CONTEXT:
-----------------
Phase 1: Stop Analysis (THIS CALC) → Find which stop types have edge
Phase 2: Indicator Analysis → Test if indicators improve winning stop types
Phase 3: Vehicle Validation → Confirm options don't destroy the edge

================================================================================
SECTION 1: STOP TYPE DEFINITIONS
================================================================================

STOP TYPE 1: Zone Boundary + 5% Buffer
--------------------------------------
Description: Stop placed just beyond the opposite side of the entry zone,
             with a 5% buffer of the zone distance to avoid wick-outs.

Calculation:
    LONG Entry:
        zone_distance = entry_price - zone_low
        buffer = zone_distance * 0.05
        stop_price = zone_low - buffer
        
    SHORT Entry:
        zone_distance = zone_high - entry_price
        buffer = zone_distance * 0.05
        stop_price = zone_high + buffer

Example (LONG):
    entry_price = $100.00
    zone_low = $99.50
    zone_distance = $0.50
    buffer = $0.025
    stop_price = $99.475

Trigger: M1 bar where low <= stop_price (LONG) or high >= stop_price (SHORT)

Data Sources:
    - trades.zone_low, trades.zone_high
    - mfe_mae_potential.entry_price


STOP TYPE 2: Prior M1 Bar High/Low
----------------------------------
Description: Stop at the high/low of the M1 candle immediately before entry.
             This is the tightest structural stop - price just respected this level.

Calculation:
    LONG Entry:
        prior_m1 = M1 bar immediately before entry_time
        stop_price = prior_m1.low
        
    SHORT Entry:
        stop_price = prior_m1.high

Trigger: M1 bar where low <= stop_price (LONG) or high >= stop_price (SHORT)

Data Sources:
    - m1_bars table (ticker, bar_date, bar_time < entry_time)
    - mfe_mae_potential.entry_time


STOP TYPE 3: Prior M5 Bar High/Low
----------------------------------
Description: Stop at the high/low of the last COMPLETED M5 bar before entry.
             Slightly wider than M1, represents short-term structure.

Calculation:
    LONG Entry:
        # M5 bars are at :00, :05, :10, :15, etc.
        # Find last completed M5 bar before entry
        entry_m5_slot = floor(entry_time to nearest 5 min)
        prior_m5_time = entry_m5_slot - 5 minutes
        
        prior_m5 = m5_trade_bars WHERE bar_time = prior_m5_time
        stop_price = prior_m5.low
        
    SHORT Entry:
        stop_price = prior_m5.high

Note: Use bars_from_entry = -1 (the M5 bar just before entry bar)

Trigger: M1 bar where low <= stop_price (LONG) or high >= stop_price (SHORT)

Data Sources:
    - m5_trade_bars table (trade_id, bars_from_entry = -1)


STOP TYPE 4: M5 ATR (Close-Based) - 1.1x Multiplier
---------------------------------------------------
Description: Volatility-normalized stop using 14-period ATR on M5 bars.
             CLOSE-BASED trigger - only exits if M5 candle CLOSES beyond level.
             More forgiving than price-touch stops.

ATR Calculation:
    # Get 14 M5 bars at or before entry (bars_from_entry <= 0)
    bars = m5_trade_bars WHERE bars_from_entry BETWEEN -13 AND 0
    
    # True Range for each bar
    for i, bar in enumerate(bars):
        if i == 0:
            tr = bar.high - bar.low
        else:
            tr = max(
                bar.high - bar.low,
                abs(bar.high - bars[i-1].close),
                abs(bar.low - bars[i-1].close)
            )
    
    atr_m5 = mean(all_true_ranges)

Stop Calculation:
    LONG Entry:
        stop_level = entry_price - (atr_m5 * 1.1)
        
    SHORT Entry:
        stop_level = entry_price + (atr_m5 * 1.1)

Trigger: M5 bar where CLOSE <= stop_level (LONG) or CLOSE >= stop_level (SHORT)
         NOTE: Price can wick through without triggering - only CLOSE matters

Data Sources:
    - m5_trade_bars table (trade_id, bars_from_entry, high, low, close)


STOP TYPE 5: M15 ATR (Close-Based) - 1.1x Multiplier
----------------------------------------------------
Description: Wider volatility stop using M15 timeframe ATR.
             Gives trades more room to develop.

ATR Calculation:
    # Aggregate M5 bars into M15 (every 3 M5 bars = 1 M15 bar)
    # Need 14 M15 periods = 42 M5 bars before entry
    
    m5_bars = m5_trade_bars WHERE bars_from_entry BETWEEN -41 AND 0
    
    # Group into M15 bars
    m15_bars = []
    for i in range(0, len(m5_bars), 3):
        group = m5_bars[i:i+3]
        m15_bar = {
            'high': max(b.high for b in group),
            'low': min(b.low for b in group),
            'close': group[-1].close,  # Close of last M5 in group
            'open': group[0].open       # Open of first M5 in group
        }
        m15_bars.append(m15_bar)
    
    # Calculate ATR on M15 bars (same formula as M5)
    atr_m15 = calculate_atr(m15_bars, period=14)

Stop Calculation:
    LONG Entry:
        stop_level = entry_price - (atr_m15 * 1.1)
        
    SHORT Entry:
        stop_level = entry_price + (atr_m15 * 1.1)

Trigger: M15 bar where CLOSE <= stop_level (LONG) or CLOSE >= stop_level (SHORT)
         Check at M15 boundaries (:00, :15, :30, :45)

Data Sources:
    - m5_trade_bars aggregated to M15


STOP TYPE 6: M5 Fractal High/Low (Market Structure)
---------------------------------------------------
Description: Stop beyond the most recent confirmed swing high/low.
             This is TRUE market structure - breaking it means trend change.

Fractal Detection Logic (from existing code):
    fractal_length = 5
    
    Swing High = M5 bar where:
        high > high of 2 bars before AND
        high > high of 2 bars after
        
    Swing Low = M5 bar where:
        low < low of 2 bars before AND
        low < low of 2 bars after
    
    # Note: Fractals require 2 bars after to CONFIRM
    # So most recent confirmed fractal is at least 2 bars old

Stop Calculation:
    LONG Entry:
        # Find most recent confirmed fractal LOW before entry
        fractals = detect_fractals(m5_bars before entry)
        stop_price = most_recent_swing_low
        
        # Fallback if swing_low is None or too close to entry
        if stop_price is None or (entry_price - stop_price) < min_threshold:
            stop_price = prev_swing_low  # Use second most recent
        
    SHORT Entry:
        stop_price = most_recent_swing_high
        
        if stop_price is None or (stop_price - entry_price) < min_threshold:
            stop_price = prev_swing_high

Trigger: M1 bar where low <= stop_price (LONG) or high >= stop_price (SHORT)

Data Sources:
    - m5_trade_bars (need sufficient history for fractal detection)
    - Reuse existing detect_structure() logic from 03_indicators


================================================================================
SECTION 2: DATABASE SCHEMAS
================================================================================

TABLE: mfe_mae_potential (Primary trade data)
---------------------------------------------
Columns used:
    - trade_id (VARCHAR) - Primary key, links to other tables
    - date (DATE) - Trade date
    - ticker (VARCHAR) - Stock symbol
    - direction (VARCHAR) - 'LONG' or 'SHORT'
    - model (VARCHAR) - 'EPCH01', 'EPCH02', 'EPCH03', 'EPCH04'
    - entry_time (TIMESTAMP) - Time of trade entry
    - entry_price (NUMERIC) - Entry price
    - mfe_potential_price (NUMERIC) - Best price from entry to 15:30
    - mfe_potential_time (TIMESTAMP) - Time of MFE
    - mae_potential_price (NUMERIC) - Worst price from entry to 15:30
    - mae_potential_time (TIMESTAMP) - Time of MAE


TABLE: trades (Zone data)
-------------------------
Columns used:
    - trade_id (VARCHAR) - Links to mfe_mae_potential
    - zone_high (NUMERIC) - Upper boundary of entry zone
    - zone_low (NUMERIC) - Lower boundary of entry zone


TABLE: m1_bars (1-minute bar data)
----------------------------------
CREATE TABLE public.m1_bars (
    id BIGSERIAL PRIMARY KEY,
    ticker VARCHAR(10) NOT NULL,
    bar_date DATE NOT NULL,
    bar_time TIME WITHOUT TIME ZONE NOT NULL,
    bar_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    open NUMERIC(12, 4) NOT NULL,
    high NUMERIC(12, 4) NOT NULL,
    low NUMERIC(12, 4) NOT NULL,
    close NUMERIC(12, 4) NOT NULL,
    volume BIGINT NOT NULL,
    vwap NUMERIC(12, 4),
    transactions INTEGER,
    fetched_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    CONSTRAINT m1_bars_unique_bar UNIQUE (ticker, bar_timestamp)
);

Indexes:
    - idx_m1_bars_ticker_date (ticker, bar_date)
    - idx_m1_bars_ticker_date_time (ticker, bar_date, bar_time)


TABLE: m5_trade_bars (5-minute bar data with indicators)
--------------------------------------------------------
CREATE TABLE public.m5_trade_bars (
    trade_id VARCHAR(50) NOT NULL,
    bar_seq INTEGER NOT NULL,
    bar_time TIME WITHOUT TIME ZONE NOT NULL,
    bars_from_entry INTEGER NOT NULL,
    event_type VARCHAR(10) NOT NULL,
    date DATE NOT NULL,
    ticker VARCHAR(10) NOT NULL,
    direction VARCHAR(10) NOT NULL,
    model VARCHAR(10),
    open NUMERIC(12, 4) NOT NULL,
    high NUMERIC(12, 4) NOT NULL,
    low NUMERIC(12, 4) NOT NULL,
    close NUMERIC(12, 4) NOT NULL,
    volume BIGINT NOT NULL,
    -- [additional indicator columns omitted for brevity]
    PRIMARY KEY (trade_id, bar_seq),
    FOREIGN KEY (trade_id) REFERENCES trades(trade_id) ON DELETE CASCADE
);

Key columns for stop analysis:
    - trade_id - Links to trade
    - bar_seq - Sequential bar number
    - bar_time - Time of bar
    - bars_from_entry - Negative = before entry, 0 = entry bar, positive = after
    - high, low, close - Price data for calculations


================================================================================
SECTION 3: SQL QUERIES
================================================================================

QUERY 1: Get all trades with zone data
--------------------------------------
SELECT 
    m.trade_id,
    m.date,
    m.ticker,
    m.direction,
    m.model,
    m.entry_time,
    m.entry_price,
    m.mfe_potential_price,
    m.mfe_potential_time,
    m.mae_potential_price,
    m.mae_potential_time,
    t.zone_high,
    t.zone_low
FROM mfe_mae_potential m
JOIN trades t ON m.trade_id = t.trade_id
WHERE m.entry_price > 0
  AND t.zone_high IS NOT NULL
  AND t.zone_low IS NOT NULL
ORDER BY m.date, m.entry_time;


QUERY 2: Get M1 bars for a specific trade (for walking price)
-------------------------------------------------------------
SELECT 
    bar_time,
    high,
    low,
    close
FROM m1_bars
WHERE ticker = :ticker
  AND bar_date = :trade_date
  AND bar_time >= :entry_time
  AND bar_time <= '15:30:00'
ORDER BY bar_time;


QUERY 3: Get prior M1 bar for stop calculation
----------------------------------------------
SELECT 
    bar_time,
    high,
    low
FROM m1_bars
WHERE ticker = :ticker
  AND bar_date = :trade_date
  AND bar_time < :entry_time
ORDER BY bar_time DESC
LIMIT 1;


QUERY 4: Get M5 bars for a trade (for ATR and fractal calculation)
------------------------------------------------------------------
SELECT 
    bar_seq,
    bar_time,
    bars_from_entry,
    open,
    high,
    low,
    close
FROM m5_trade_bars
WHERE trade_id = :trade_id
ORDER BY bar_seq;


QUERY 5: Get prior M5 bar specifically
--------------------------------------
SELECT 
    high,
    low
FROM m5_trade_bars
WHERE trade_id = :trade_id
  AND bars_from_entry = -1
LIMIT 1;


================================================================================
SECTION 4: CALCULATION LOGIC (PSEUDOCODE)
================================================================================

MAIN PROCESSING LOOP:
---------------------

def analyze_all_stops():
    """Main entry point for stop analysis."""
    
    # 1. Fetch all trades with zone data
    trades = fetch_trades_with_zones()
    
    # 2. Initialize results storage
    results = {
        'zone_buffer': [],
        'prior_m1': [],
        'prior_m5': [],
        'm5_atr': [],
        'm15_atr': [],
        'fractal': []
    }
    
    # 3. Process each trade
    for trade in trades:
        # Get M1 bars for this trade (entry to 15:30)
        m1_bars = fetch_m1_bars(trade.ticker, trade.date, trade.entry_time)
        
        # Get M5 bars for this trade
        m5_bars = fetch_m5_bars(trade.trade_id)
        
        # Calculate all 6 stop prices
        stop_prices = calculate_stop_prices(trade, m1_bars, m5_bars)
        
        # For each stop type, simulate outcome
        for stop_type, stop_price in stop_prices.items():
            if stop_price is None:
                continue
                
            outcome = simulate_stop_outcome(
                trade=trade,
                stop_price=stop_price,
                stop_type=stop_type,
                m1_bars=m1_bars,
                m5_bars=m5_bars
            )
            
            results[stop_type].append(outcome)
    
    # 4. Aggregate results
    summary = aggregate_results(results)
    
    return summary


STOP PRICE CALCULATION:
-----------------------

def calculate_stop_prices(trade, m1_bars, m5_bars):
    """Calculate stop price for each of the 6 stop types."""
    
    entry_price = trade.entry_price
    direction = trade.direction
    is_long = direction == 'LONG'
    
    stops = {}
    
    # STOP 1: Zone Boundary + 5% Buffer
    if is_long:
        zone_distance = entry_price - trade.zone_low
        buffer = zone_distance * 0.05
        stops['zone_buffer'] = trade.zone_low - buffer
    else:
        zone_distance = trade.zone_high - entry_price
        buffer = zone_distance * 0.05
        stops['zone_buffer'] = trade.zone_high + buffer
    
    # STOP 2: Prior M1 High/Low
    prior_m1 = get_prior_m1_bar(m1_bars, trade.entry_time)
    if prior_m1:
        stops['prior_m1'] = prior_m1['low'] if is_long else prior_m1['high']
    else:
        stops['prior_m1'] = None
    
    # STOP 3: Prior M5 High/Low
    prior_m5 = get_bar_by_bars_from_entry(m5_bars, bars_from_entry=-1)
    if prior_m5:
        stops['prior_m5'] = prior_m5['low'] if is_long else prior_m5['high']
    else:
        stops['prior_m5'] = None
    
    # STOP 4: M5 ATR (1.1x)
    atr_m5 = calculate_atr(m5_bars, period=14, timeframe='m5')
    if atr_m5:
        if is_long:
            stops['m5_atr'] = entry_price - (atr_m5 * 1.1)
        else:
            stops['m5_atr'] = entry_price + (atr_m5 * 1.1)
    else:
        stops['m5_atr'] = None
    
    # STOP 5: M15 ATR (1.1x)
    atr_m15 = calculate_atr_m15(m5_bars, period=14)
    if atr_m15:
        if is_long:
            stops['m15_atr'] = entry_price - (atr_m15 * 1.1)
        else:
            stops['m15_atr'] = entry_price + (atr_m15 * 1.1)
    else:
        stops['m15_atr'] = None
    
    # STOP 6: M5 Fractal High/Low
    fractal_stop = calculate_fractal_stop(m5_bars, direction)
    stops['fractal'] = fractal_stop
    
    return stops


ATR CALCULATION:
----------------

def calculate_atr(bars, period=14, timeframe='m5'):
    """
    Calculate Average True Range.
    
    True Range = max(
        high - low,
        abs(high - prev_close),
        abs(low - prev_close)
    )
    """
    # Filter to bars at or before entry
    pre_entry_bars = [b for b in bars if b['bars_from_entry'] <= 0]
    
    # Need at least 'period' bars
    if len(pre_entry_bars) < period:
        return None
    
    # Take most recent 'period' bars
    recent_bars = pre_entry_bars[-period:]
    
    true_ranges = []
    for i, bar in enumerate(recent_bars):
        if i == 0:
            tr = bar['high'] - bar['low']
        else:
            prev_close = recent_bars[i-1]['close']
            tr = max(
                bar['high'] - bar['low'],
                abs(bar['high'] - prev_close),
                abs(bar['low'] - prev_close)
            )
        true_ranges.append(tr)
    
    return sum(true_ranges) / len(true_ranges)


def calculate_atr_m15(m5_bars, period=14):
    """
    Calculate M15 ATR by aggregating M5 bars.
    Need 14 M15 bars = 42 M5 bars.
    """
    # Filter to bars at or before entry
    pre_entry_bars = [b for b in m5_bars if b['bars_from_entry'] <= 0]
    
    # Need at least 42 M5 bars for 14 M15 periods
    if len(pre_entry_bars) < 42:
        # Fall back to available data
        if len(pre_entry_bars) < 3:
            return None
    
    # Aggregate M5 to M15 (every 3 bars)
    m15_bars = []
    
    # Start from oldest, group by 3
    for i in range(0, len(pre_entry_bars) - 2, 3):
        group = pre_entry_bars[i:i+3]
        if len(group) < 3:
            continue
            
        m15_bar = {
            'high': max(b['high'] for b in group),
            'low': min(b['low'] for b in group),
            'close': group[-1]['close'],
            'open': group[0]['open']
        }
        m15_bars.append(m15_bar)
    
    if len(m15_bars) < 2:
        return None
    
    # Calculate ATR on M15 bars
    true_ranges = []
    for i, bar in enumerate(m15_bars):
        if i == 0:
            tr = bar['high'] - bar['low']
        else:
            prev_close = m15_bars[i-1]['close']
            tr = max(
                bar['high'] - bar['low'],
                abs(bar['high'] - prev_close),
                abs(bar['low'] - prev_close)
            )
        true_ranges.append(tr)
    
    # Use available periods (up to 14)
    return sum(true_ranges) / len(true_ranges)


FRACTAL DETECTION:
------------------

def calculate_fractal_stop(m5_bars, direction):
    """
    Find most recent confirmed fractal high/low for stop placement.
    
    Fractal High: Bar where high > high of 2 bars before AND 2 bars after
    Fractal Low: Bar where low < low of 2 bars before AND 2 bars after
    
    Note: Most recent CONFIRMED fractal is at least 2 bars before entry
    because we need 2 bars after to confirm.
    """
    # Filter to bars before entry (need confirmation)
    # bars_from_entry <= -2 because fractal needs 2 bars after to confirm
    confirmable_bars = [b for b in m5_bars if b['bars_from_entry'] <= -2]
    
    if len(confirmable_bars) < 5:
        return None
    
    is_long = direction == 'LONG'
    fractal_length = 2  # Bars on each side
    
    fractals = []
    
    # Find all fractals
    for i in range(fractal_length, len(confirmable_bars) - fractal_length):
        bar = confirmable_bars[i]
        
        if is_long:
            # Looking for fractal LOWS (for stop below)
            is_fractal = True
            for j in range(1, fractal_length + 1):
                if bar['low'] >= confirmable_bars[i-j]['low']:
                    is_fractal = False
                    break
                if bar['low'] >= confirmable_bars[i+j]['low']:
                    is_fractal = False
                    break
            
            if is_fractal:
                fractals.append({
                    'type': 'low',
                    'price': bar['low'],
                    'bars_from_entry': bar['bars_from_entry']
                })
        else:
            # Looking for fractal HIGHS (for stop above)
            is_fractal = True
            for j in range(1, fractal_length + 1):
                if bar['high'] <= confirmable_bars[i-j]['high']:
                    is_fractal = False
                    break
                if bar['high'] <= confirmable_bars[i+j]['high']:
                    is_fractal = False
                    break
            
            if is_fractal:
                fractals.append({
                    'type': 'high',
                    'price': bar['high'],
                    'bars_from_entry': bar['bars_from_entry']
                })
    
    if not fractals:
        return None
    
    # Return most recent fractal (closest to entry)
    most_recent = max(fractals, key=lambda x: x['bars_from_entry'])
    return most_recent['price']


OUTCOME SIMULATION:
-------------------

def simulate_stop_outcome(trade, stop_price, stop_type, m1_bars, m5_bars):
    """
    Simulate trade outcome for a given stop price.
    
    Walk through bars from entry to 15:30 and determine:
    1. Was stop hit?
    2. If yes, was MFE reached before stop?
    3. Calculate R achieved
    """
    entry_price = trade.entry_price
    direction = trade.direction
    is_long = direction == 'LONG'
    
    mfe_price = trade.mfe_potential_price
    mfe_time = trade.mfe_potential_time
    mae_price = trade.mae_potential_price
    mae_time = trade.mae_potential_time
    
    # Calculate stop distance (R denominator)
    stop_distance = abs(entry_price - stop_price)
    stop_distance_pct = (stop_distance / entry_price) * 100
    
    # Determine if stop would be hit based on MAE
    # For ATR stops, check closes; for others, check price touch
    
    if stop_type in ['m5_atr', 'm15_atr']:
        # Close-based stop - check if MAE close exceeds stop
        # We need to check M5/M15 closes, not just MAE price
        stop_hit = check_close_based_stop(
            trade, stop_price, stop_type, m5_bars, is_long
        )
    else:
        # Price-based stop - check if MAE exceeds stop
        if is_long:
            stop_hit = mae_price <= stop_price
        else:
            stop_hit = mae_price >= stop_price
    
    # Calculate MFE distance
    if is_long:
        mfe_distance = mfe_price - entry_price
    else:
        mfe_distance = entry_price - mfe_price
    
    mfe_distance = max(0, mfe_distance)  # Can't be negative
    
    # Determine outcome
    if stop_hit:
        # Need to check timing - did MFE occur before stop hit?
        stop_hit_time = find_stop_hit_time(
            trade, stop_price, stop_type, m1_bars, m5_bars, is_long
        )
        
        if stop_hit_time and mfe_time and mfe_time < stop_hit_time:
            # MFE reached before stop - calculate R captured
            r_achieved = mfe_distance / stop_distance if stop_distance > 0 else 0
            outcome = 'WIN' if r_achieved >= 1.0 else 'PARTIAL'
        else:
            # Stop hit before meaningful MFE
            r_achieved = -1.0
            outcome = 'LOSS'
    else:
        # Stop never hit - full MFE potentially captured
        r_achieved = mfe_distance / stop_distance if stop_distance > 0 else 0
        outcome = 'WIN' if r_achieved >= 1.0 else 'PARTIAL'
    
    return {
        'trade_id': trade.trade_id,
        'direction': direction,
        'model': trade.model,
        'stop_type': stop_type,
        'entry_price': entry_price,
        'stop_price': stop_price,
        'stop_distance': stop_distance,
        'stop_distance_pct': stop_distance_pct,
        'stop_hit': stop_hit,
        'mfe_price': mfe_price,
        'mfe_distance': mfe_distance,
        'r_achieved': r_achieved,
        'outcome': outcome
    }


def check_close_based_stop(trade, stop_price, stop_type, m5_bars, is_long):
    """
    Check if a close-based (ATR) stop was triggered.
    Only triggers if candle CLOSES beyond the level.
    """
    # Get bars after entry
    post_entry_bars = [b for b in m5_bars if b['bars_from_entry'] > 0]
    
    if stop_type == 'm15_atr':
        # Aggregate to M15 and check closes
        # Check at M15 boundaries (bars 3, 6, 9, etc.)
        for i in range(2, len(post_entry_bars), 3):
            bar = post_entry_bars[i]  # Last bar of M15 period
            if is_long:
                if bar['close'] <= stop_price:
                    return True
            else:
                if bar['close'] >= stop_price:
                    return True
    else:
        # M5 ATR - check each M5 close
        for bar in post_entry_bars:
            if is_long:
                if bar['close'] <= stop_price:
                    return True
            else:
                if bar['close'] >= stop_price:
                    return True
    
    return False


def find_stop_hit_time(trade, stop_price, stop_type, m1_bars, m5_bars, is_long):
    """
    Find the exact time when stop was hit.
    Used to compare against MFE time for outcome determination.
    """
    if stop_type in ['m5_atr', 'm15_atr']:
        # Close-based - find first M5/M15 close beyond level
        post_entry = [b for b in m5_bars if b['bars_from_entry'] > 0]
        
        if stop_type == 'm15_atr':
            for i in range(2, len(post_entry), 3):
                bar = post_entry[i]
                if is_long and bar['close'] <= stop_price:
                    return bar['bar_time']
                elif not is_long and bar['close'] >= stop_price:
                    return bar['bar_time']
        else:
            for bar in post_entry:
                if is_long and bar['close'] <= stop_price:
                    return bar['bar_time']
                elif not is_long and bar['close'] >= stop_price:
                    return bar['bar_time']
    else:
        # Price-based - find first M1 bar that touches stop
        entry_time = trade.entry_time.time() if hasattr(trade.entry_time, 'time') else trade.entry_time
        
        for bar in m1_bars:
            if bar['bar_time'] <= entry_time:
                continue
                
            if is_long and bar['low'] <= stop_price:
                return bar['bar_time']
            elif not is_long and bar['high'] >= stop_price:
                return bar['bar_time']
    
    return None


================================================================================
SECTION 5: RESULTS AGGREGATION
================================================================================

def aggregate_results(results):
    """
    Aggregate individual trade results into summary statistics.
    """
    summary = {}
    
    for stop_type, outcomes in results.items():
        if not outcomes:
            continue
        
        df = pd.DataFrame(outcomes)
        
        total_trades = len(df)
        
        # Basic stats
        stop_hit_count = df['stop_hit'].sum()
        stop_hit_pct = (stop_hit_count / total_trades) * 100
        
        avg_stop_distance = df['stop_distance'].mean()
        avg_stop_distance_pct = df['stop_distance_pct'].mean()
        
        # Win rate (1R+ achieved)
        wins = len(df[df['r_achieved'] >= 1.0])
        win_rate = (wins / total_trades) * 100
        
        # R statistics
        avg_r_winners = df[df['outcome'] == 'WIN']['r_achieved'].mean()
        avg_r_all = df['r_achieved'].mean()
        
        # Expectancy
        # E = (win% * avg_win) - (loss% * 1R)
        losses = len(df[df['outcome'] == 'LOSS'])
        loss_rate = (losses / total_trades)
        win_rate_decimal = wins / total_trades
        
        if pd.notna(avg_r_winners):
            expectancy = (win_rate_decimal * avg_r_winners) - (loss_rate * 1.0)
        else:
            expectancy = -(loss_rate * 1.0)
        
        summary[stop_type] = {
            'total_trades': total_trades,
            'avg_stop_distance': avg_stop_distance,
            'avg_stop_distance_pct': avg_stop_distance_pct,
            'stop_hit_count': stop_hit_count,
            'stop_hit_pct': stop_hit_pct,
            'wins': wins,
            'losses': losses,
            'win_rate': win_rate,
            'avg_r_winners': avg_r_winners if pd.notna(avg_r_winners) else 0,
            'avg_r_all': avg_r_all,
            'expectancy': expectancy
        }
    
    return summary


def aggregate_by_segment(results, segment_field):
    """
    Aggregate results by a segment (model, direction, model_type).
    """
    all_outcomes = []
    for stop_type, outcomes in results.items():
        for outcome in outcomes:
            outcome['stop_type'] = stop_type
            all_outcomes.append(outcome)
    
    df = pd.DataFrame(all_outcomes)
    
    # Group by stop_type and segment
    grouped = df.groupby(['stop_type', segment_field]).apply(
        lambda x: pd.Series({
            'total_trades': len(x),
            'stop_hit_pct': (x['stop_hit'].sum() / len(x)) * 100,
            'win_rate': (len(x[x['r_achieved'] >= 1.0]) / len(x)) * 100,
            'avg_r_all': x['r_achieved'].mean(),
            'expectancy': calculate_expectancy(x)
        })
    ).reset_index()
    
    return grouped


================================================================================
SECTION 6: OUTPUT SPECIFICATION
================================================================================

PRIMARY OUTPUT TABLE:
---------------------
| Stop Type        | n     | Avg Stop | Stop Hit % | Win Rate | Avg R (Win) | Avg R (All) | Expectancy |
|------------------|-------|----------|------------|----------|-------------|-------------|------------|
| Zone + 5% Buffer | 1,545 | 0.XX%    | XX.X%      | XX.X%    | +X.XXR      | +/-X.XXR    | +/-X.XXX   |
| Prior M1 H/L     | 1,545 | 0.XX%    | XX.X%      | XX.X%    | +X.XXR      | +/-X.XXR    | +/-X.XXX   |
| Prior M5 H/L     | 1,545 | 0.XX%    | XX.X%      | XX.X%    | +X.XXR      | +/-X.XXR    | +/-X.XXX   |
| M5 ATR (Close)   | 1,545 | 0.XX%    | XX.X%      | XX.X%    | +X.XXR      | +/-X.XXR    | +/-X.XXX   |
| M15 ATR (Close)  | 1,545 | 0.XX%    | XX.X%      | XX.X%    | +X.XXR      | +/-X.XXR    | +/-X.XXX   |
| M5 Fractal H/L   | 1,545 | 0.XX%    | XX.X%      | XX.X%    | +X.XXR      | +/-X.XXR    | +/-X.XXX   |


COLUMN DEFINITIONS:
-------------------
| Column          | Formula                                        | Interpretation                          |
|-----------------|------------------------------------------------|-----------------------------------------|
| n               | COUNT(trades)                                  | Sample size                             |
| Avg Stop        | MEAN(stop_distance_pct)                        | Average risk per trade as % of entry    |
| Stop Hit %      | COUNT(stop_hit=True) / n * 100                 | How often the stop is triggered         |
| Win Rate        | COUNT(r_achieved >= 1.0) / n * 100             | % of trades reaching 1R before stop     |
| Avg R (Win)     | MEAN(r_achieved) WHERE outcome='WIN'           | Average R on winning trades             |
| Avg R (All)     | MEAN(r_achieved) all trades                    | Net R per trade                         |
| Expectancy      | (win_rate * avg_win_r) - (loss_rate * 1R)      | Expected R per trade                    |


BREAKDOWN TABLES:
-----------------

BY MODEL TYPE (Continuation vs Rejection):
| Stop Type        | Type         | n   | Win Rate | Expectancy |
|------------------|--------------|-----|----------|------------|
| Zone + 5% Buffer | Continuation | XXX | XX.X%    | +/-X.XXX   |
| Zone + 5% Buffer | Rejection    | XXX | XX.X%    | +/-X.XXX   |
| Prior M1 H/L     | Continuation | XXX | XX.X%    | +/-X.XXX   |
| Prior M1 H/L     | Rejection    | XXX | XX.X%    | +/-X.XXX   |
...

BY DIRECTION:
| Stop Type        | Direction | n   | Win Rate | Expectancy |
|------------------|-----------|-----|----------|------------|
| Zone + 5% Buffer | LONG      | XXX | XX.X%    | +/-X.XXX   |
| Zone + 5% Buffer | SHORT     | XXX | XX.X%    | +/-X.XXX   |
...

BY MODEL-DIRECTION (8 combinations):
| Stop Type        | EPCH1-L | EPCH1-S | EPCH2-L | EPCH2-S | EPCH3-L | EPCH3-S | EPCH4-L | EPCH4-S |
|------------------|---------|---------|---------|---------|---------|---------|---------|---------|
| Zone + 5% Buffer | XX.X%   | XX.X%   | XX.X%   | XX.X%   | XX.X%   | XX.X%   | XX.X%   | XX.X%   |
| Prior M1 H/L     | XX.X%   | XX.X%   | XX.X%   | XX.X%   | XX.X%   | XX.X%   | XX.X%   | XX.X%   |
...


================================================================================
SECTION 7: STREAMLIT UI COMPONENTS
================================================================================

PLACEMENT:
----------
Location: Metrics Overview Tab, immediately after Summary Cards row
Position: First calculation section (before current CALC-001)

UI STRUCTURE:
-------------

st.subheader("Stop Type Analysis")
st.caption("Foundation analysis: Which stop placement method provides best risk-adjusted returns?")

# Summary cards row
col1, col2, col3, col4 = st.columns(4)
with col1:
    st.metric("Best Stop Type", best_stop_name)
with col2:
    st.metric("Best Win Rate", f"{best_win_rate:.1f}%")
with col3:
    st.metric("Best Expectancy", f"{best_expectancy:+.3f}R")
with col4:
    st.metric("Trades Analyzed", f"{total_trades:,}")

# Main comparison table
st.dataframe(summary_df, use_container_width=True)

# Expandable sections for breakdowns
with st.expander("View by Model Type (Continuation vs Rejection)"):
    st.dataframe(model_type_df)

with st.expander("View by Direction (LONG vs SHORT)"):
    st.dataframe(direction_df)

with st.expander("View by Model-Direction (8 combinations)"):
    st.dataframe(model_direction_df)

# Visualization
col1, col2 = st.columns(2)
with col1:
    st.plotly_chart(win_rate_chart, use_container_width=True)
with col2:
    st.plotly_chart(expectancy_chart, use_container_width=True)


CHART SPECIFICATIONS:
---------------------

Chart 1: Win Rate by Stop Type (Horizontal Bar)
    - Y-axis: Stop types (6 bars)
    - X-axis: Win Rate %
    - Color: Gradient based on win rate (red < 50% < green)
    - Reference line at 50%

Chart 2: Expectancy by Stop Type (Horizontal Bar)
    - Y-axis: Stop types (6 bars)
    - X-axis: Expectancy (R)
    - Color: Red for negative, green for positive
    - Reference line at 0

Chart 3: Stop Distance Distribution (Box Plot)
    - Y-axis: Stop types
    - X-axis: Stop distance %
    - Shows distribution of risk per trade

Chart 4: Risk-Reward Scatter
    - X-axis: Average Stop Distance %
    - Y-axis: Win Rate %
    - Bubble size: Expectancy
    - Labels: Stop type names


================================================================================
SECTION 8: FILE STRUCTURE
================================================================================

calculations/
└── stop_analysis/
    ├── __init__.py
    ├── stop_calculator.py       # Calculate stop prices for each type
    ├── outcome_simulator.py     # Walk bars and determine outcomes  
    ├── atr_calculator.py        # ATR calculation (M5 and M15)
    ├── fractal_detector.py      # Fractal high/low detection
    ├── results_aggregator.py    # Aggregate results into summaries
    └── ui_components.py         # Streamlit display components


FILE: __init__.py
-----------------
from .stop_calculator import calculate_all_stop_prices
from .outcome_simulator import simulate_all_outcomes
from .results_aggregator import aggregate_stop_results
from .ui_components import render_stop_analysis


FILE: stop_calculator.py
------------------------
"""
Calculate stop prices for all 6 stop types.
"""

def calculate_zone_buffer_stop(entry_price, zone_low, zone_high, direction):
    """Stop Type 1: Zone boundary + 5% buffer"""
    pass

def calculate_prior_m1_stop(m1_bars, entry_time, direction):
    """Stop Type 2: Prior M1 bar high/low"""
    pass

def calculate_prior_m5_stop(m5_bars, direction):
    """Stop Type 3: Prior M5 bar high/low"""
    pass

def calculate_m5_atr_stop(m5_bars, entry_price, direction, multiplier=1.1):
    """Stop Type 4: M5 ATR-based stop"""
    pass

def calculate_m15_atr_stop(m5_bars, entry_price, direction, multiplier=1.1):
    """Stop Type 5: M15 ATR-based stop"""
    pass

def calculate_fractal_stop(m5_bars, direction):
    """Stop Type 6: M5 fractal high/low"""
    pass

def calculate_all_stop_prices(trade, m1_bars, m5_bars):
    """Calculate all 6 stop prices for a trade"""
    pass


FILE: outcome_simulator.py
--------------------------
"""
Simulate trade outcomes for each stop type.
"""

def simulate_outcome(trade, stop_price, stop_type, m1_bars, m5_bars):
    """Simulate single trade outcome"""
    pass

def check_price_based_stop(m1_bars, stop_price, entry_time, direction):
    """Check if price-based stop was hit"""
    pass

def check_close_based_stop(m5_bars, stop_price, stop_type, direction):
    """Check if close-based stop was hit"""
    pass

def find_stop_hit_time(trade, stop_price, stop_type, m1_bars, m5_bars):
    """Find exact time stop was triggered"""
    pass

def simulate_all_outcomes(trades, m1_bars_dict, m5_bars_dict):
    """Process all trades and return results"""
    pass


FILE: atr_calculator.py
-----------------------
"""
ATR calculation for M5 and M15 timeframes.
"""

def calculate_true_range(bar, prev_close=None):
    """Calculate true range for a single bar"""
    pass

def calculate_atr_m5(m5_bars, period=14):
    """Calculate 14-period ATR on M5 bars"""
    pass

def calculate_atr_m15(m5_bars, period=14):
    """Calculate 14-period ATR on aggregated M15 bars"""
    pass

def aggregate_m5_to_m15(m5_bars):
    """Aggregate M5 bars into M15 bars"""
    pass


FILE: fractal_detector.py
-------------------------
"""
Fractal (swing high/low) detection for market structure stops.
"""

def find_fractal_highs(bars, fractal_length=2):
    """Find all fractal highs in bar series"""
    pass

def find_fractal_lows(bars, fractal_length=2):
    """Find all fractal lows in bar series"""
    pass

def get_most_recent_fractal(fractals, direction):
    """Get most recent confirmed fractal for stop placement"""
    pass

def calculate_fractal_stop_price(m5_bars, direction, fractal_length=2):
    """Calculate fractal-based stop price"""
    pass


FILE: results_aggregator.py
---------------------------
"""
Aggregate individual results into summary statistics.
"""

def aggregate_by_stop_type(results):
    """Aggregate results for each stop type"""
    pass

def aggregate_by_model_type(results):
    """Aggregate by continuation vs rejection"""
    pass

def aggregate_by_direction(results):
    """Aggregate by LONG vs SHORT"""
    pass

def aggregate_by_model_direction(results):
    """Aggregate by 8 model-direction combinations"""
    pass

def find_best_stop_type(summary):
    """Identify best performing stop type"""
    pass


FILE: ui_components.py
----------------------
"""
Streamlit UI components for stop analysis display.
"""

def render_stop_analysis(trades_df, m1_bars_dict, m5_bars_dict):
    """Main entry point for stop analysis UI"""
    pass

def render_summary_cards(summary):
    """Render top-level summary metric cards"""
    pass

def render_comparison_table(summary_df):
    """Render main stop type comparison table"""
    pass

def render_breakdown_expanders(results):
    """Render expandable breakdown sections"""
    pass

def render_win_rate_chart(summary_df):
    """Render win rate comparison bar chart"""
    pass

def render_expectancy_chart(summary_df):
    """Render expectancy comparison bar chart"""
    pass


================================================================================
SECTION 9: INTEGRATION NOTES
================================================================================

1. DATABASE CONNECTION
   - Use existing SupabaseClient from data/supabase_client.py
   - Add new fetch methods for m1_bars if not existing

2. CACHING
   - Cache M1 bars by (ticker, date) - reused across trades
   - M5 bars already available per trade via m5_trade_bars
   - Cache stop analysis results with TTL=300s

3. PERFORMANCE CONSIDERATIONS
   - M1 bars: ~390 bars per trade (09:30 to 16:00)
   - ~1,545 trades = ~600K M1 bar lookups
   - Batch fetch M1 bars by (ticker, date) to reduce queries
   - Consider pre-computing stop prices and storing in database

4. ERROR HANDLING
   - Handle missing zone data gracefully (skip Stop Type 1)
   - Handle insufficient bar history for ATR/fractal (skip those types)
   - Log trades that couldn't be processed with reason

5. DOWNSTREAM IMPACT
   - Once best stop type(s) identified, update CALC-005 through 008
   - Use winning stop type's win/loss as the outcome variable
   - Re-run indicator analysis with realistic win definition


================================================================================
SECTION 10: TESTING CHECKLIST
================================================================================

[ ] Unit Tests:
    [ ] Zone buffer calculation (LONG and SHORT)
    [ ] Prior M1 bar retrieval
    [ ] Prior M5 bar retrieval
    [ ] M5 ATR calculation
    [ ] M15 ATR calculation (aggregation)
    [ ] Fractal detection
    [ ] Stop hit detection (price-based)
    [ ] Stop hit detection (close-based)
    [ ] R calculation
    [ ] Outcome classification

[ ] Integration Tests:
    [ ] Full pipeline for single trade
    [ ] Full pipeline for 100 trades
    [ ] Results aggregation
    [ ] UI rendering

[ ] Validation:
    [ ] Compare stop distances to MFE/MAE distributions
    [ ] Verify win rates are reasonable (not 0% or 100%)
    [ ] Check for data quality issues (missing bars, etc.)
    [ ] Validate against manual calculation for 5 random trades


================================================================================
END OF SPECIFICATION
================================================================================