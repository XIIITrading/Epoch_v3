# CALC-007: INDICATOR PROGRESSION ANALYSIS (UPDATED)
## Claude Code Implementation Instructions
### Epoch Trading System - Indicator Analysis Module

**Document Version:** 2.0
**Updated:** 2026-01-04
**Author:** Monte AI / Silva
**Target Application:** 12_indicator_analysis

---

## 1. OBJECTIVE

Build CALC-007 to analyze how indicators change from ENTRY to MFE (winners) vs ENTRY to MAE (losers). This informs exit timing and early warning signal development.

### Core Question
> "What indicator changes signal that a trade is working vs failing?"

### Purpose
1. **Exit Signal Development** - Identify when to exit early
2. **Winner/Loser Differentiation** - What separates winning trades?
3. **Early Warning Signals** - Detect failing trades before stop hit
4. **DOW AI Exit Recommendations** - Provide exit guidance

---

## 2. PROJECT CONTEXT

### Directory Structure
```
C:\XIIITradingSystems\Epoch\02_zone_system\12_indicator_analysis\
├── calculations/
│   └── indicator_analysis/
│       ├── __init__.py                    # UPDATE - Add exports
│       ├── health_correlation.py          # CALC-005
│       ├── factor_importance.py           # CALC-006
│       └── indicator_progression.py       # NEW FILE - CALC-007
└── app.py                                 # UPDATE - Wire CALC-007
```

### Data Source: m5_trade_bars Table

**IMPORTANT:** This analysis uses the `m5_trade_bars` table which was populated with:
- Trade-specific M5 bars from entry to 15:30 ET
- Full indicator snapshots per bar
- Direction-specific health scoring (10 factors)
- MFE/MAE event marking

Table Location: `02_zone_system/09_backtest/processor/secondary_analysis/m5_trade_bars/`

---

## 3. DATABASE SCHEMA REFERENCE

The `m5_trade_bars` table has the following structure:

```sql
-- Primary Key (composite)
trade_id VARCHAR(50) NOT NULL,
bar_seq INTEGER NOT NULL,           -- Sequential within trade (0, 1, 2...)

-- Bar Identification
bar_time TIME NOT NULL,
bars_from_entry INTEGER NOT NULL,   -- 0 at entry bar
event_type VARCHAR(10) NOT NULL,    -- ENTRY, IN_TRADE, MFE, MAE, MFE_MAE

-- Trade Context (denormalized)
date DATE NOT NULL,
ticker VARCHAR(10) NOT NULL,
direction VARCHAR(10) NOT NULL,
model VARCHAR(10),

-- OHLCV
open DECIMAL(12, 4) NOT NULL,
high DECIMAL(12, 4) NOT NULL,
low DECIMAL(12, 4) NOT NULL,
close DECIMAL(12, 4) NOT NULL,
volume BIGINT NOT NULL,

-- Price Indicators
vwap DECIMAL(12, 4),
sma9 DECIMAL(12, 4),
sma21 DECIMAL(12, 4),
sma_spread DECIMAL(12, 4),
sma_alignment VARCHAR(10),          -- BULL or BEAR
sma_alignment_healthy BOOLEAN,
sma_momentum_ratio DECIMAL(10, 6),
sma_momentum_label VARCHAR(15),
sma_momentum_healthy BOOLEAN,
vwap_position VARCHAR(10),          -- ABOVE or BELOW
vwap_healthy BOOLEAN,

-- Volume Indicators
vol_roc DECIMAL(10, 4),
vol_roc_healthy BOOLEAN,
vol_delta DECIMAL(12, 2),
vol_delta_healthy BOOLEAN,
cvd_slope DECIMAL(10, 6),
cvd_slope_healthy BOOLEAN,

-- Structure
h4_structure VARCHAR(10),
h4_structure_healthy BOOLEAN,
h1_structure VARCHAR(10),
h1_structure_healthy BOOLEAN,
m15_structure VARCHAR(10),
m15_structure_healthy BOOLEAN,
m5_structure VARCHAR(10),
m5_structure_healthy BOOLEAN,

-- Composite Health Score
health_score INTEGER,               -- 0-10
health_label VARCHAR(15),           -- CRITICAL, WEAK, MODERATE, STRONG
structure_score INTEGER,            -- 0-4
volume_score INTEGER,               -- 0-3
price_score INTEGER,                -- 0-3
```

### Event Types

| Event | Description | Analysis Use |
|-------|-------------|--------------|
| ENTRY | Trade entry bar (bar_seq = 0) | Baseline state |
| MFE | Maximum Favorable Excursion bar | Winner peak |
| MAE | Maximum Adverse Excursion bar | Loser trough |
| MFE_MAE | Both MFE and MAE on same bar | Edge case |
| IN_TRADE | Regular bars during trade | Progression tracking |

---

## 4. CALCULATION SPECIFICATION

### Data Query

Join `m5_trade_bars` with `mfe_mae_potential` for outcome data:

```sql
SELECT
    tb.trade_id,
    tb.bar_seq,
    tb.bar_time,
    tb.bars_from_entry,
    tb.event_type,
    tb.date,
    tb.ticker,
    tb.direction,
    tb.model,
    tb.health_score,
    tb.health_label,
    tb.structure_score,
    tb.volume_score,
    tb.price_score,
    tb.cvd_slope,
    tb.vol_delta,
    tb.vol_roc,
    tb.sma_spread,
    tb.sma_momentum_ratio,
    tb.vwap,
    tb.sma_alignment_healthy,
    tb.sma_momentum_healthy,
    tb.vwap_healthy,
    tb.vol_roc_healthy,
    tb.vol_delta_healthy,
    tb.cvd_slope_healthy,
    tb.h4_structure_healthy,
    tb.h1_structure_healthy,
    tb.m15_structure_healthy,
    tb.m5_structure_healthy,
    mp.is_winner,
    mp.mfe_r_potential,
    mp.mae_r_potential,
    mp.mfe_potential_time,
    mp.mae_potential_time
FROM m5_trade_bars tb
JOIN mfe_mae_potential mp ON tb.trade_id = mp.trade_id
WHERE tb.event_type IN ('ENTRY', 'MFE', 'MAE', 'MFE_MAE', 'IN_TRADE')
ORDER BY tb.trade_id, tb.bar_seq
```

### Metrics to Calculate

| Metric | Formula | Purpose |
|--------|---------|---------|
| Avg Health Score at Event | mean(health_score) by event_type | Progression baseline |
| Health Delta (Entry → MFE) | hs_mfe - hs_entry for winners | Winner pattern |
| Health Delta (Entry → MAE) | hs_mae - hs_entry for losers | Loser pattern |
| Early Degradation Rate | % trades with hs_drop > X within Y bars | Early warning |
| Divergence Point | Bar where winner/loser paths separate | Critical timing |
| Score Component Deltas | Changes in structure/volume/price scores | Component analysis |

---

## 5. IMPLEMENTATION

### File: calculations/indicator_analysis/indicator_progression.py

```python
"""
CALC-007: Indicator Progression Analysis

Analyzes how indicators change from ENTRY to MFE/MAE using m5_trade_bars data.
Identifies early warning signals for failing trades.
"""

import pandas as pd
import numpy as np
from scipy import stats
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
import streamlit as st

import sys
from pathlib import Path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from config import INDICATOR_ANALYSIS_CONFIG


# Indicators to track progression
PROGRESSION_INDICATORS = [
    'health_score',
    'structure_score',
    'volume_score',
    'price_score',
    'cvd_slope',
    'vol_delta',
    'vol_roc',
    'sma_spread',
    'sma_momentum_ratio'
]

# Health score factor columns
HEALTH_FACTORS = [
    'sma_alignment_healthy',
    'sma_momentum_healthy',
    'vwap_healthy',
    'vol_roc_healthy',
    'vol_delta_healthy',
    'cvd_slope_healthy',
    'h4_structure_healthy',
    'h1_structure_healthy',
    'm15_structure_healthy',
    'm5_structure_healthy'
]


@dataclass
class EventSnapshot:
    """Indicator snapshot at a specific event."""
    event_type: str
    avg_health_score: float
    std_health_score: float
    avg_structure_score: float
    avg_volume_score: float
    avg_price_score: float
    avg_cvd_slope: float
    avg_vol_delta: float
    avg_sma_spread: float
    trade_count: int
    avg_bars_from_entry: float


@dataclass
class ProgressionPath:
    """Indicator progression path for a trade group (winners/losers)."""
    outcome: str  # 'WIN' or 'LOSS'
    entry_snapshot: EventSnapshot
    peak_snapshot: EventSnapshot  # MFE for winners, MAE for losers

    # Deltas
    health_delta_to_peak: float
    structure_delta_to_peak: float
    volume_delta_to_peak: float
    price_delta_to_peak: float
    cvd_delta_to_peak: float
    vol_delta_to_peak: float

    # Timing
    avg_bars_to_peak: float
    trade_count: int


@dataclass
class EarlyWarningSignal:
    """Early warning signal definition."""
    indicator: str
    threshold: float
    direction: str  # 'drop' or 'rise'
    bars_window: int
    hit_rate_losers: float  # % of losers that show this signal
    hit_rate_winners: float  # % of winners that show this signal (false positives)
    lift: float  # hit_rate_losers - hit_rate_winners
    predictive_power: float  # Lift / hit_rate_losers


@dataclass
class FactorDegradationAnalysis:
    """Analysis of how individual factors degrade before MAE."""
    factor_name: str
    healthy_at_entry_pct: float
    healthy_at_mae_pct: float
    degradation_rate: float  # entry - mae
    flip_rate: float  # % that went from healthy to unhealthy
    early_flip_rate: float  # % that flipped within first 5 bars


@dataclass
class IndicatorProgressionResult:
    """Container for all progression analysis results."""
    total_trades: int
    winner_count: int
    loser_count: int
    overall_win_rate: float

    # Progression paths
    winner_path: ProgressionPath
    loser_path: ProgressionPath

    # By-event summary
    event_summary: pd.DataFrame  # [event_type, outcome, health_score, etc.]

    # Delta distributions
    winner_deltas: pd.DataFrame  # [indicator, entry_val, peak_val, delta, pct_change]
    loser_deltas: pd.DataFrame

    # Early warning signals
    early_warnings: List[EarlyWarningSignal]

    # Best early warning
    best_warning: Optional[EarlyWarningSignal]

    # Factor degradation analysis
    factor_degradation: List[FactorDegradationAnalysis]

    # Bar-by-bar progression (for charting)
    bar_progression: pd.DataFrame  # [bars_from_entry, outcome, avg_health, etc.]


def calculate_event_snapshot(
    df: pd.DataFrame,
    event_type: str
) -> Optional[EventSnapshot]:
    """
    Calculate indicator averages at a specific event type.

    Parameters:
        df: DataFrame filtered to specific outcome group
        event_type: 'ENTRY', 'MFE', 'MAE', or 'MFE_MAE'

    Returns:
        EventSnapshot with average values
    """
    # Handle MFE_MAE as both MFE and MAE
    if event_type in ['MFE', 'MAE']:
        event_df = df[df['event_type'].isin([event_type, 'MFE_MAE'])]
    else:
        event_df = df[df['event_type'] == event_type]

    if len(event_df) == 0:
        return None

    return EventSnapshot(
        event_type=event_type,
        avg_health_score=event_df['health_score'].mean() if 'health_score' in event_df else 0,
        std_health_score=event_df['health_score'].std() if 'health_score' in event_df else 0,
        avg_structure_score=event_df['structure_score'].mean() if 'structure_score' in event_df else 0,
        avg_volume_score=event_df['volume_score'].mean() if 'volume_score' in event_df else 0,
        avg_price_score=event_df['price_score'].mean() if 'price_score' in event_df else 0,
        avg_cvd_slope=event_df['cvd_slope'].mean() if 'cvd_slope' in event_df else 0,
        avg_vol_delta=event_df['vol_delta'].mean() if 'vol_delta' in event_df else 0,
        avg_sma_spread=event_df['sma_spread'].mean() if 'sma_spread' in event_df else 0,
        trade_count=len(event_df['trade_id'].unique()),
        avg_bars_from_entry=event_df['bars_from_entry'].mean() if 'bars_from_entry' in event_df else 0
    )


def calculate_progression_path(
    df: pd.DataFrame,
    outcome: str,
    is_winner: bool
) -> Optional[ProgressionPath]:
    """
    Calculate progression path for winners or losers.

    Parameters:
        df: DataFrame with m5_trade_bars data
        outcome: 'WIN' or 'LOSS'
        is_winner: True for winners, False for losers

    Returns:
        ProgressionPath for the group
    """
    # Filter to outcome group
    group_df = df[df['is_winner'] == is_winner]

    if len(group_df) == 0:
        return None

    # Get snapshots
    entry_snapshot = calculate_event_snapshot(group_df, 'ENTRY')

    # Peak event differs by outcome
    if is_winner:
        peak_snapshot = calculate_event_snapshot(group_df, 'MFE')
    else:
        peak_snapshot = calculate_event_snapshot(group_df, 'MAE')

    if not entry_snapshot or not peak_snapshot:
        return None

    # Calculate deltas
    health_delta = peak_snapshot.avg_health_score - entry_snapshot.avg_health_score
    structure_delta = peak_snapshot.avg_structure_score - entry_snapshot.avg_structure_score
    volume_delta = peak_snapshot.avg_volume_score - entry_snapshot.avg_volume_score
    price_delta = peak_snapshot.avg_price_score - entry_snapshot.avg_price_score
    cvd_delta = peak_snapshot.avg_cvd_slope - entry_snapshot.avg_cvd_slope
    vol_delta = peak_snapshot.avg_vol_delta - entry_snapshot.avg_vol_delta

    return ProgressionPath(
        outcome=outcome,
        entry_snapshot=entry_snapshot,
        peak_snapshot=peak_snapshot,
        health_delta_to_peak=health_delta,
        structure_delta_to_peak=structure_delta,
        volume_delta_to_peak=volume_delta,
        price_delta_to_peak=price_delta,
        cvd_delta_to_peak=cvd_delta,
        vol_delta_to_peak=vol_delta,
        avg_bars_to_peak=peak_snapshot.avg_bars_from_entry,
        trade_count=len(group_df['trade_id'].unique())
    )


def calculate_bar_by_bar_progression(
    df: pd.DataFrame,
    max_bars: int = 30
) -> pd.DataFrame:
    """
    Calculate average indicator values by bars_from_entry and outcome.

    Parameters:
        df: DataFrame with m5_trade_bars data
        max_bars: Maximum bars from entry to analyze

    Returns:
        DataFrame with [bars_from_entry, outcome, avg_health, avg_structure, ...]
    """
    # Filter to reasonable bar range
    df_filtered = df[df['bars_from_entry'] <= max_bars].copy()

    results = []

    for bars in range(0, max_bars + 1):
        for is_winner in [True, False]:
            subset = df_filtered[
                (df_filtered['bars_from_entry'] == bars) &
                (df_filtered['is_winner'] == is_winner)
            ]

            if len(subset) < 5:  # Minimum sample
                continue

            outcome = 'WIN' if is_winner else 'LOSS'

            row = {
                'bars_from_entry': bars,
                'outcome': outcome,
                'trade_count': len(subset['trade_id'].unique()),
                'avg_health_score': subset['health_score'].mean(),
                'std_health_score': subset['health_score'].std(),
                'avg_structure_score': subset['structure_score'].mean(),
                'avg_volume_score': subset['volume_score'].mean(),
                'avg_price_score': subset['price_score'].mean()
            }
            results.append(row)

    return pd.DataFrame(results)


def calculate_early_warning_signals(
    df: pd.DataFrame,
    indicators: List[str] = None,
    bars_windows: List[int] = [3, 5, 10, 15]
) -> List[EarlyWarningSignal]:
    """
    Identify early warning signals that predict losing trades.

    Parameters:
        df: DataFrame with m5_trade_bars data
        indicators: List of indicators to analyze
        bars_windows: Number of bars from entry to check

    Returns:
        List of EarlyWarningSignal objects
    """
    if indicators is None:
        indicators = ['health_score', 'cvd_slope', 'structure_score', 'volume_score']

    warnings = []

    for indicator in indicators:
        if indicator not in df.columns:
            continue

        for bars_window in bars_windows:
            # Get entry values
            entry_df = df[df['event_type'] == 'ENTRY']
            entry_vals = entry_df.groupby('trade_id')[indicator].first()

            # Get values at N bars from entry
            window_df = df[df['bars_from_entry'] == bars_window]
            window_vals = window_df.groupby('trade_id')[indicator].first()

            # Calculate change
            common_trades = entry_vals.index.intersection(window_vals.index)
            if len(common_trades) < 30:
                continue

            changes = window_vals[common_trades] - entry_vals[common_trades]

            # Get outcomes
            outcomes = df[df['trade_id'].isin(common_trades)].groupby('trade_id')['is_winner'].first()

            # Test different thresholds based on indicator type
            if indicator == 'health_score':
                thresholds = [-3, -2, -1.5, -1]
            elif indicator in ['structure_score', 'volume_score', 'price_score']:
                thresholds = [-2, -1.5, -1]
            else:
                thresholds = [-0.5, -0.3, -0.1]

            for threshold in thresholds:
                # Calculate hit rates
                losers = outcomes[outcomes == False].index
                winners = outcomes[outcomes == True].index

                if len(losers) == 0 or len(winners) == 0:
                    continue

                loser_hits = (changes[losers] <= threshold).sum() / len(losers) * 100
                winner_hits = (changes[winners] <= threshold).sum() / len(winners) * 100

                lift = loser_hits - winner_hits
                predictive = lift / loser_hits if loser_hits > 0 else 0

                if lift > 5:  # Only add if meaningful lift
                    warnings.append(EarlyWarningSignal(
                        indicator=indicator,
                        threshold=threshold,
                        direction='drop',
                        bars_window=bars_window,
                        hit_rate_losers=loser_hits,
                        hit_rate_winners=winner_hits,
                        lift=lift,
                        predictive_power=predictive
                    ))

    # Sort by lift
    warnings.sort(key=lambda x: x.lift, reverse=True)

    return warnings


def analyze_factor_degradation(
    df: pd.DataFrame
) -> List[FactorDegradationAnalysis]:
    """
    Analyze how individual health factors degrade from entry to MAE for losers.

    Parameters:
        df: DataFrame with m5_trade_bars data

    Returns:
        List of FactorDegradationAnalysis for each factor
    """
    # Filter to losers only
    loser_df = df[df['is_winner'] == False]

    results = []

    for factor in HEALTH_FACTORS:
        if factor not in loser_df.columns:
            continue

        # Get entry state
        entry_df = loser_df[loser_df['event_type'] == 'ENTRY']
        entry_healthy = entry_df.groupby('trade_id')[factor].first()

        # Get MAE state (include MFE_MAE)
        mae_df = loser_df[loser_df['event_type'].isin(['MAE', 'MFE_MAE'])]
        mae_healthy = mae_df.groupby('trade_id')[factor].first()

        # Get state at bar 5 (early check)
        bar5_df = loser_df[loser_df['bars_from_entry'] == 5]
        bar5_healthy = bar5_df.groupby('trade_id')[factor].first()

        common = entry_healthy.index.intersection(mae_healthy.index)
        if len(common) == 0:
            continue

        healthy_at_entry = entry_healthy[common].mean() * 100
        healthy_at_mae = mae_healthy[common].mean() * 100

        # Calculate flip rate (was healthy at entry, unhealthy at MAE)
        flipped = ((entry_healthy[common] == True) & (mae_healthy[common] == False)).sum()
        flip_rate = flipped / len(common) * 100

        # Calculate early flip rate
        common_bar5 = entry_healthy.index.intersection(bar5_healthy.index)
        early_flipped = 0
        if len(common_bar5) > 0:
            early_flipped = (
                (entry_healthy[common_bar5] == True) &
                (bar5_healthy[common_bar5] == False)
            ).sum()
            early_flip_rate = early_flipped / len(common_bar5) * 100
        else:
            early_flip_rate = 0

        # Clean factor name for display
        factor_name = factor.replace('_healthy', '').replace('_', ' ').title()

        results.append(FactorDegradationAnalysis(
            factor_name=factor_name,
            healthy_at_entry_pct=healthy_at_entry,
            healthy_at_mae_pct=healthy_at_mae,
            degradation_rate=healthy_at_entry - healthy_at_mae,
            flip_rate=flip_rate,
            early_flip_rate=early_flip_rate
        ))

    # Sort by degradation rate
    results.sort(key=lambda x: x.degradation_rate, reverse=True)

    return results


def create_event_summary(
    df: pd.DataFrame
) -> pd.DataFrame:
    """
    Create summary table of indicator values by event and outcome.
    """
    results = []

    for event in ['ENTRY', 'MFE', 'MAE', 'MFE_MAE']:
        for is_winner in [True, False]:
            outcome = 'WIN' if is_winner else 'LOSS'

            if event in ['MFE', 'MFE_MAE']:
                subset = df[(df['event_type'].isin([event, 'MFE_MAE'])) & (df['is_winner'] == is_winner)]
            else:
                subset = df[(df['event_type'] == event) & (df['is_winner'] == is_winner)]

            if len(subset) == 0:
                continue

            row = {
                'event': event,
                'outcome': outcome,
                'trades': len(subset['trade_id'].unique()),
                'avg_bars': subset['bars_from_entry'].mean()
            }

            for indicator in PROGRESSION_INDICATORS:
                if indicator in subset.columns:
                    row[f'{indicator}_avg'] = subset[indicator].mean()
                    row[f'{indicator}_std'] = subset[indicator].std()

            results.append(row)

    return pd.DataFrame(results)


def create_delta_summary(
    df: pd.DataFrame,
    is_winner: bool
) -> pd.DataFrame:
    """
    Create summary of indicator changes from entry to peak.
    """
    outcome_df = df[df['is_winner'] == is_winner]
    peak_event = 'MFE' if is_winner else 'MAE'

    entry_df = outcome_df[outcome_df['event_type'] == 'ENTRY']
    peak_df = outcome_df[outcome_df['event_type'].isin([peak_event, 'MFE_MAE'])]

    results = []

    for indicator in PROGRESSION_INDICATORS:
        if indicator not in entry_df.columns:
            continue

        entry_vals = entry_df.groupby('trade_id')[indicator].first()
        peak_vals = peak_df.groupby('trade_id')[indicator].first()

        common = entry_vals.index.intersection(peak_vals.index)
        if len(common) == 0:
            continue

        entry_avg = entry_vals[common].mean()
        peak_avg = peak_vals[common].mean()
        delta = peak_avg - entry_avg
        pct_change = (delta / entry_avg * 100) if entry_avg != 0 else 0

        results.append({
            'indicator': indicator,
            'entry_avg': entry_avg,
            'peak_avg': peak_avg,
            'delta': delta,
            'pct_change': pct_change
        })

    return pd.DataFrame(results)


def analyze_indicator_progression(df: pd.DataFrame) -> IndicatorProgressionResult:
    """
    Main analysis function for CALC-007.

    Parameters:
        df: DataFrame with m5_trade_bars data joined with outcomes

    Returns:
        IndicatorProgressionResult with all analysis outputs
    """
    # Basic counts
    trades = df['trade_id'].unique()
    total_trades = len(trades)

    winner_trades = df[df['is_winner'] == True]['trade_id'].unique()
    loser_trades = df[df['is_winner'] == False]['trade_id'].unique()

    winner_count = len(winner_trades)
    loser_count = len(loser_trades)
    overall_win_rate = (winner_count / total_trades * 100) if total_trades > 0 else 0

    # Calculate progression paths
    winner_path = calculate_progression_path(df, 'WIN', True)
    loser_path = calculate_progression_path(df, 'LOSS', False)

    # Event summary
    event_summary = create_event_summary(df)

    # Delta summaries
    winner_deltas = create_delta_summary(df, True)
    loser_deltas = create_delta_summary(df, False)

    # Bar-by-bar progression
    bar_progression = calculate_bar_by_bar_progression(df)

    # Early warning signals
    early_warnings = calculate_early_warning_signals(df)
    best_warning = early_warnings[0] if early_warnings else None

    # Factor degradation analysis
    factor_degradation = analyze_factor_degradation(df)

    return IndicatorProgressionResult(
        total_trades=total_trades,
        winner_count=winner_count,
        loser_count=loser_count,
        overall_win_rate=overall_win_rate,
        winner_path=winner_path,
        loser_path=loser_path,
        event_summary=event_summary,
        winner_deltas=winner_deltas,
        loser_deltas=loser_deltas,
        early_warnings=early_warnings,
        best_warning=best_warning,
        factor_degradation=factor_degradation,
        bar_progression=bar_progression
    )


# =============================================================================
# STREAMLIT RENDERING FUNCTIONS
# =============================================================================

def render_progression_summary_cards(result: IndicatorProgressionResult):
    """Render summary cards for progression analysis."""
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric(
            label="Total Trades",
            value=f"{result.total_trades:,}"
        )

    with col2:
        st.metric(
            label="Winners",
            value=f"{result.winner_count:,}",
            delta=f"{result.overall_win_rate:.1f}%"
        )

    with col3:
        st.metric(
            label="Losers",
            value=f"{result.loser_count:,}"
        )

    with col4:
        if result.best_warning:
            st.metric(
                label="Best Warning Signal",
                value=f"{result.best_warning.indicator}",
                delta=f"+{result.best_warning.lift:.1f}pp lift"
            )


def render_progression_path_chart(result: IndicatorProgressionResult):
    """Render line chart comparing winner vs loser progression paths."""
    import plotly.graph_objects as go

    fig = go.Figure()

    # Winner path
    if result.winner_path:
        wp = result.winner_path
        fig.add_trace(go.Scatter(
            x=['ENTRY', f'MFE\n({wp.avg_bars_to_peak:.0f} bars)'],
            y=[
                wp.entry_snapshot.avg_health_score,
                wp.peak_snapshot.avg_health_score
            ],
            mode='lines+markers+text',
            name=f'Winners (n={wp.trade_count})',
            line=dict(color='#26a69a', width=3),
            marker=dict(size=14),
            text=[
                f"{wp.entry_snapshot.avg_health_score:.1f}",
                f"{wp.peak_snapshot.avg_health_score:.1f}"
            ],
            textposition='top center'
        ))

    # Loser path
    if result.loser_path:
        lp = result.loser_path
        fig.add_trace(go.Scatter(
            x=['ENTRY', f'MAE\n({lp.avg_bars_to_peak:.0f} bars)'],
            y=[
                lp.entry_snapshot.avg_health_score,
                lp.peak_snapshot.avg_health_score
            ],
            mode='lines+markers+text',
            name=f'Losers (n={lp.trade_count})',
            line=dict(color='#ef5350', width=3),
            marker=dict(size=14),
            text=[
                f"{lp.entry_snapshot.avg_health_score:.1f}",
                f"{lp.peak_snapshot.avg_health_score:.1f}"
            ],
            textposition='bottom center'
        ))

    fig.update_layout(
        title="Health Score Progression: Entry to Peak",
        xaxis_title="Event",
        yaxis_title="Average Health Score (0-10)",
        template="plotly_dark",
        paper_bgcolor="#16213e",
        plot_bgcolor="#1a1a2e",
        font=dict(color="#e0e0e0"),
        yaxis=dict(range=[0, 10]),
        showlegend=True,
        legend=dict(orientation='h', y=-0.2)
    )

    st.plotly_chart(fig, use_container_width=True)


def render_bar_by_bar_progression_chart(result: IndicatorProgressionResult):
    """Render line chart of bar-by-bar health score progression."""
    import plotly.graph_objects as go

    if result.bar_progression.empty:
        st.warning("Insufficient data for bar-by-bar analysis")
        return

    df = result.bar_progression

    fig = go.Figure()

    # Winner progression
    winners = df[df['outcome'] == 'WIN']
    if not winners.empty:
        fig.add_trace(go.Scatter(
            x=winners['bars_from_entry'],
            y=winners['avg_health_score'],
            mode='lines+markers',
            name='Winners',
            line=dict(color='#26a69a', width=2),
            marker=dict(size=6)
        ))

        # Add confidence band
        fig.add_trace(go.Scatter(
            x=pd.concat([winners['bars_from_entry'], winners['bars_from_entry'][::-1]]),
            y=pd.concat([
                winners['avg_health_score'] + winners['std_health_score'],
                (winners['avg_health_score'] - winners['std_health_score'])[::-1]
            ]),
            fill='toself',
            fillcolor='rgba(38, 166, 154, 0.2)',
            line=dict(color='rgba(0,0,0,0)'),
            name='Winner Std Dev',
            showlegend=False
        ))

    # Loser progression
    losers = df[df['outcome'] == 'LOSS']
    if not losers.empty:
        fig.add_trace(go.Scatter(
            x=losers['bars_from_entry'],
            y=losers['avg_health_score'],
            mode='lines+markers',
            name='Losers',
            line=dict(color='#ef5350', width=2),
            marker=dict(size=6)
        ))

        # Add confidence band
        fig.add_trace(go.Scatter(
            x=pd.concat([losers['bars_from_entry'], losers['bars_from_entry'][::-1]]),
            y=pd.concat([
                losers['avg_health_score'] + losers['std_health_score'],
                (losers['avg_health_score'] - losers['std_health_score'])[::-1]
            ]),
            fill='toself',
            fillcolor='rgba(239, 83, 80, 0.2)',
            line=dict(color='rgba(0,0,0,0)'),
            name='Loser Std Dev',
            showlegend=False
        ))

    fig.update_layout(
        title="Bar-by-Bar Health Score Progression",
        xaxis_title="Bars from Entry",
        yaxis_title="Average Health Score",
        template="plotly_dark",
        paper_bgcolor="#16213e",
        plot_bgcolor="#1a1a2e",
        font=dict(color="#e0e0e0"),
        yaxis=dict(range=[0, 10]),
        showlegend=True
    )

    st.plotly_chart(fig, use_container_width=True)


def render_score_components_chart(result: IndicatorProgressionResult):
    """Render stacked bar chart of score components (structure, volume, price)."""
    import plotly.graph_objects as go

    if not result.winner_path or not result.loser_path:
        st.warning("Insufficient data for score component analysis")
        return

    categories = ['Winner Entry', 'Winner MFE', 'Loser Entry', 'Loser MAE']

    structure_scores = [
        result.winner_path.entry_snapshot.avg_structure_score,
        result.winner_path.peak_snapshot.avg_structure_score,
        result.loser_path.entry_snapshot.avg_structure_score,
        result.loser_path.peak_snapshot.avg_structure_score
    ]

    volume_scores = [
        result.winner_path.entry_snapshot.avg_volume_score,
        result.winner_path.peak_snapshot.avg_volume_score,
        result.loser_path.entry_snapshot.avg_volume_score,
        result.loser_path.peak_snapshot.avg_volume_score
    ]

    price_scores = [
        result.winner_path.entry_snapshot.avg_price_score,
        result.winner_path.peak_snapshot.avg_price_score,
        result.loser_path.entry_snapshot.avg_price_score,
        result.loser_path.peak_snapshot.avg_price_score
    ]

    fig = go.Figure()

    fig.add_trace(go.Bar(
        name='Structure (0-4)',
        x=categories,
        y=structure_scores,
        marker_color='#7c3aed'
    ))

    fig.add_trace(go.Bar(
        name='Volume (0-3)',
        x=categories,
        y=volume_scores,
        marker_color='#3b82f6'
    ))

    fig.add_trace(go.Bar(
        name='Price (0-3)',
        x=categories,
        y=price_scores,
        marker_color='#10b981'
    ))

    fig.update_layout(
        title="Health Score Components by Event",
        xaxis_title="",
        yaxis_title="Score",
        barmode='stack',
        template="plotly_dark",
        paper_bgcolor="#16213e",
        plot_bgcolor="#1a1a2e",
        font=dict(color="#e0e0e0")
    )

    st.plotly_chart(fig, use_container_width=True)


def render_delta_comparison_chart(result: IndicatorProgressionResult):
    """Render bar chart comparing entry-to-peak deltas for winners vs losers."""
    import plotly.graph_objects as go

    if result.winner_deltas is None or result.loser_deltas is None:
        st.warning("Insufficient data for delta comparison")
        return

    if result.winner_deltas.empty or result.loser_deltas.empty:
        st.warning("Insufficient data for delta comparison")
        return

    indicators = result.winner_deltas['indicator'].tolist()

    fig = go.Figure()

    fig.add_trace(go.Bar(
        name='Winners (Entry -> MFE)',
        x=indicators,
        y=result.winner_deltas['delta'],
        marker_color='#26a69a',
        text=[f"{v:+.2f}" for v in result.winner_deltas['delta']],
        textposition='outside'
    ))

    fig.add_trace(go.Bar(
        name='Losers (Entry -> MAE)',
        x=indicators,
        y=result.loser_deltas['delta'],
        marker_color='#ef5350',
        text=[f"{v:+.2f}" for v in result.loser_deltas['delta']],
        textposition='outside'
    ))

    # Zero line
    fig.add_hline(y=0, line_color='#e0e0e0', line_width=1)

    fig.update_layout(
        title="Indicator Delta: Entry to Peak",
        xaxis_title="Indicator",
        yaxis_title="Change (Delta)",
        barmode='group',
        template="plotly_dark",
        paper_bgcolor="#16213e",
        plot_bgcolor="#1a1a2e",
        font=dict(color="#e0e0e0"),
        xaxis_tickangle=-45
    )

    st.plotly_chart(fig, use_container_width=True)


def render_early_warning_table(result: IndicatorProgressionResult):
    """Render table of early warning signals."""
    if not result.early_warnings:
        st.info("No significant early warning signals identified")
        return

    data = [{
        'Indicator': w.indicator,
        'Threshold': f"<= {w.threshold}",
        'Window': f"{w.bars_window} bars",
        'Loser Hit Rate': f"{w.hit_rate_losers:.1f}%",
        'Winner Hit Rate': f"{w.hit_rate_winners:.1f}%",
        'Lift': f"+{w.lift:.1f}pp",
        'Predictive Power': f"{w.predictive_power:.2f}"
    } for w in result.early_warnings[:10]]  # Top 10

    df = pd.DataFrame(data)
    st.dataframe(df, use_container_width=True, hide_index=True)


def render_factor_degradation_table(result: IndicatorProgressionResult):
    """Render table of factor degradation analysis."""
    if not result.factor_degradation:
        st.info("No factor degradation data available")
        return

    data = [{
        'Factor': fd.factor_name,
        'Healthy @ Entry': f"{fd.healthy_at_entry_pct:.1f}%",
        'Healthy @ MAE': f"{fd.healthy_at_mae_pct:.1f}%",
        'Degradation': f"-{fd.degradation_rate:.1f}pp",
        'Flip Rate': f"{fd.flip_rate:.1f}%",
        'Early Flip (5 bars)': f"{fd.early_flip_rate:.1f}%"
    } for fd in result.factor_degradation]

    df = pd.DataFrame(data)
    st.dataframe(df, use_container_width=True, hide_index=True)


def render_event_summary_table(result: IndicatorProgressionResult):
    """Render detailed event summary table."""
    df = result.event_summary.copy()

    if 'health_score_avg' in df.columns:
        df['health_score_avg'] = df['health_score_avg'].apply(lambda x: f"{x:.2f}")

    st.dataframe(df, use_container_width=True, hide_index=True)


def render_calc_007_section(df: pd.DataFrame):
    """
    Main render function for CALC-007 section in Streamlit.

    Parameters:
        df: DataFrame from m5_trade_bars with outcomes joined
    """
    st.subheader("CALC-007: Indicator Progression Analysis")
    st.markdown("*What changes between entry and outcome?*")

    try:
        result = analyze_indicator_progression(df)

        # Summary cards
        render_progression_summary_cards(result)

        st.divider()

        # Main visualizations in tabs
        tab1, tab2, tab3, tab4 = st.tabs([
            "Progression Paths",
            "Bar-by-Bar Analysis",
            "Early Warnings",
            "Factor Degradation"
        ])

        with tab1:
            col1, col2 = st.columns(2)

            with col1:
                st.markdown("### Health Score Progression")
                render_progression_path_chart(result)

            with col2:
                st.markdown("### Score Components")
                render_score_components_chart(result)

            st.markdown("### Indicator Deltas: Entry to Peak")
            render_delta_comparison_chart(result)

        with tab2:
            st.markdown("### Bar-by-Bar Health Score")
            st.markdown("*Average health score at each bar from entry*")
            render_bar_by_bar_progression_chart(result)

        with tab3:
            st.markdown("### Early Warning Signals")
            st.markdown("*Signals that predict trade failure before stop is hit*")
            render_early_warning_table(result)

            if result.best_warning:
                bw = result.best_warning
                st.success(
                    f"**Best Warning:** {bw.indicator} drop of {bw.threshold} within "
                    f"{bw.bars_window} bars catches {bw.hit_rate_losers:.0f}% of losers "
                    f"(only {bw.hit_rate_winners:.0f}% false positives)"
                )

        with tab4:
            st.markdown("### Factor Degradation Analysis")
            st.markdown("*How individual health factors change for losing trades*")
            render_factor_degradation_table(result)

        # Event summary (expandable)
        with st.expander("Detailed Event Summary", expanded=False):
            render_event_summary_table(result)

        # Key findings
        st.divider()
        st.markdown("### Key Findings")

        findings = []

        if result.winner_path and result.loser_path:
            hs_diff = result.winner_path.entry_snapshot.avg_health_score - result.loser_path.entry_snapshot.avg_health_score
            if abs(hs_diff) > 0.3:
                if hs_diff > 0:
                    findings.append(f"**Winners start with higher Health Score** (+{hs_diff:.1f} points at entry)")
                else:
                    findings.append(f"**Winners start with similar Health Score** ({hs_diff:+.1f} points at entry)")

            w_delta = result.winner_path.health_delta_to_peak
            l_delta = result.loser_path.health_delta_to_peak

            if w_delta > 0 and l_delta < 0:
                findings.append(f"**Divergent paths:** Winners improve ({w_delta:+.1f}), losers degrade ({l_delta:+.1f})")
            elif w_delta > l_delta:
                findings.append(f"**Winners improve more:** Winner delta ({w_delta:+.1f}) vs Loser delta ({l_delta:+.1f})")

            # Timing insight
            w_bars = result.winner_path.avg_bars_to_peak
            l_bars = result.loser_path.avg_bars_to_peak
            findings.append(f"**Timing:** Winners reach MFE in {w_bars:.0f} bars, losers hit MAE in {l_bars:.0f} bars")

        if result.best_warning:
            bw = result.best_warning
            findings.append(
                f"**Best Early Warning:** {bw.indicator} drop of {bw.threshold} within {bw.bars_window} bars "
                f"(catches {bw.hit_rate_losers:.0f}% of losers, {bw.hit_rate_winners:.0f}% false positive rate)"
            )

        if result.factor_degradation:
            worst = result.factor_degradation[0]
            findings.append(
                f"**Fastest Degrading Factor:** {worst.factor_name} "
                f"({worst.degradation_rate:.1f}pp drop from entry to MAE)"
            )

        for finding in findings:
            st.markdown(f"- {finding}")

        return result

    except Exception as e:
        st.error(f"Error in CALC-007 analysis: {e}")
        import traceback
        st.code(traceback.format_exc())
        return None
```

---

## 6. DATA LOADING UPDATE

### Update data/supabase_client.py

Add method to fetch m5_trade_bars with outcomes:

```python
def fetch_m5_trade_bars_with_outcomes(
    self,
    date_from: Optional[date] = None,
    date_to: Optional[date] = None,
    models: Optional[List[str]] = None,
    directions: Optional[List[str]] = None,
    limit: int = 200000
) -> List[Dict]:
    """
    Fetch m5_trade_bars data with outcome information for progression analysis.

    Parameters:
        date_from: Start date filter
        date_to: End date filter
        models: List of models to include
        directions: List of directions (LONG, SHORT)
        limit: Maximum rows to return

    Returns:
        List of m5_trade_bar records with is_winner joined
    """
    try:
        query = """
            SELECT
                tb.trade_id,
                tb.bar_seq,
                tb.bar_time,
                tb.bars_from_entry,
                tb.event_type,
                tb.date,
                tb.ticker,
                tb.direction,
                tb.model,
                tb.open,
                tb.high,
                tb.low,
                tb.close,
                tb.volume,
                tb.vwap,
                tb.sma9,
                tb.sma21,
                tb.sma_spread,
                tb.sma_alignment,
                tb.sma_alignment_healthy,
                tb.sma_momentum_ratio,
                tb.sma_momentum_label,
                tb.sma_momentum_healthy,
                tb.vwap_position,
                tb.vwap_healthy,
                tb.vol_roc,
                tb.vol_roc_healthy,
                tb.vol_delta,
                tb.vol_delta_healthy,
                tb.cvd_slope,
                tb.cvd_slope_healthy,
                tb.h4_structure,
                tb.h4_structure_healthy,
                tb.h1_structure,
                tb.h1_structure_healthy,
                tb.m15_structure,
                tb.m15_structure_healthy,
                tb.m5_structure,
                tb.m5_structure_healthy,
                tb.health_score,
                tb.health_label,
                tb.structure_score,
                tb.volume_score,
                tb.price_score,
                mp.is_winner,
                mp.mfe_r_potential,
                mp.mae_r_potential,
                mp.mfe_potential_time,
                mp.mae_potential_time
            FROM m5_trade_bars tb
            JOIN mfe_mae_potential mp ON tb.trade_id = mp.trade_id
            WHERE 1=1
        """
        params = []
        param_idx = 1

        if date_from:
            query += f" AND tb.date >= ${param_idx}"
            params.append(date_from)
            param_idx += 1

        if date_to:
            query += f" AND tb.date <= ${param_idx}"
            params.append(date_to)
            param_idx += 1

        if models:
            query += f" AND tb.model = ANY(${param_idx})"
            params.append(models)
            param_idx += 1

        if directions:
            query += f" AND tb.direction = ANY(${param_idx})"
            params.append(directions)
            param_idx += 1

        query += f" ORDER BY tb.trade_id, tb.bar_seq LIMIT ${param_idx}"
        params.append(limit)

        self.cursor.execute(query, params)
        columns = [desc[0] for desc in self.cursor.description]
        rows = self.cursor.fetchall()

        return [dict(zip(columns, row)) for row in rows]

    except Exception as e:
        self.conn.rollback()
        print(f"Error fetching m5_trade_bars with outcomes: {e}")
        return []
```

---

## 7. UPDATE app.py

Wire CALC-007 into the Indicator Analysis tab:

```python
# Add data loading function:
@st.cache_data(ttl=300)
def load_m5_trade_bars_progression():
    """Load m5_trade_bars with outcome data for CALC-007."""
    client = get_client()
    return client.fetch_m5_trade_bars_with_outcomes(
        date_from=filters.get('date_from'),
        date_to=filters.get('date_to'),
        models=filters.get('models'),
        directions=filters.get('directions')
    )

# In the Indicator Analysis tab, add CALC-007 sub-tab:
calc5, calc6, calc7, calc8 = st.tabs([
    "CALC-005: Health Correlation",
    "CALC-006: Factor Importance",
    "CALC-007: Indicator Progression",
    "CALC-008: Rejection Dynamics"
])

# In the calc7 sub-tab section:
with calc7:
    st.subheader("CALC-007: Indicator Progression Analysis")
    st.markdown("*What changes between entry and outcome?*")

    with st.spinner("Loading M5 trade bars data..."):
        trade_bars_data = load_m5_trade_bars_progression()

    if trade_bars_data:
        from calculations.indicator_analysis import render_calc_007_section
        trade_bars_df = pd.DataFrame(trade_bars_data)

        # Show data stats
        st.caption(f"Loaded {len(trade_bars_df):,} bars from {trade_bars_df['trade_id'].nunique():,} trades")

        calc_007_result = render_calc_007_section(trade_bars_df)
    else:
        st.warning("No m5_trade_bars data available for CALC-007 analysis")
        st.info("""
        **Data Source:** m5_trade_bars table

        This analysis requires the m5_trade_bars table to be populated.
        Run the populator from:
        `02_zone_system/09_backtest/processor/secondary_analysis/m5_trade_bars/`

        ```bash
        python runner.py  # Full batch run
        ```
        """)
```

---

## 8. UPDATE __init__.py

Add CALC-007 exports to `calculations/indicator_analysis/__init__.py`:

```python
"""
Indicator Analysis Module (CALC-005 through CALC-008)
"""

from .health_correlation import (
    analyze_health_correlation,
    HealthCorrelationResult,
    render_calc_005_section
)

from .factor_importance import (
    analyze_factor_importance,
    FactorImportanceResult,
    FactorAnalysis,
    render_calc_006_section,
    FACTORS
)

from .indicator_progression import (
    analyze_indicator_progression,
    IndicatorProgressionResult,
    ProgressionPath,
    EventSnapshot,
    EarlyWarningSignal,
    FactorDegradationAnalysis,
    render_calc_007_section,
    PROGRESSION_INDICATORS,
    HEALTH_FACTORS
)
```

---

## 9. EXPECTED OUTPUT EXAMPLE

```
CALC-007: Indicator Progression Analysis

+------------------+------------------+------------------+------------------+
| Total Trades     | Winners          | Losers           | Best Warning     |
| 1,122            | 589 (52.5%)      | 533              | health_score     |
|                  |                  |                  | +38.2pp lift     |
+------------------+------------------+------------------+------------------+

PROGRESSION PATHS TAB:

Health Score Progression:
                   ENTRY           PEAK
    Winners:       6.4    --->     7.1   (+0.7)   MFE @ 18 bars
    Losers:        5.9    --->     4.2   (-1.7)   MAE @ 12 bars

Score Components at Each Event:
+------------------+------------+-------+-------+-------+-------+
|                  | Structure  | Vol   | Price | Total |
+------------------+------------+-------+-------+-------+
| Winner Entry     |    2.8     |  1.9  |  1.7  |  6.4  |
| Winner MFE       |    2.9     |  2.1  |  2.1  |  7.1  |
| Loser Entry      |    2.6     |  1.8  |  1.5  |  5.9  |
| Loser MAE        |    2.0     |  1.1  |  1.1  |  4.2  |
+------------------+------------+-------+-------+-------+

BAR-BY-BAR TAB:

[Chart showing health score from bar 0 to bar 30]
- Winners: Starts ~6.4, slowly rises to ~7.0
- Losers: Starts ~5.9, degrades rapidly to ~4.5 by bar 10

EARLY WARNINGS TAB:

+----------------+-----------+--------+------------+------------+----------+
| Indicator      | Threshold | Window | Loser Hit% | Winner Hit%| Lift     |
+----------------+-----------+--------+------------+------------+----------+
| health_score   | <= -2     | 5 bars |   72.3%    |    34.1%   | +38.2 pp |
| health_score   | <= -3     | 10 bars|   68.7%    |    22.8%   | +45.9 pp |
| cvd_slope      | <= -0.1   | 5 bars |   65.4%    |    38.2%   | +27.2 pp |
| structure_score| <= -1     | 5 bars |   54.2%    |    28.6%   | +25.6 pp |
+----------------+-----------+--------+------------+------------+----------+

Best Warning: health_score drop of -2 within 5 bars catches 72% of losers
              with only 34% false positives

FACTOR DEGRADATION TAB:

+------------------+---------------+--------------+-------------+-----------+
| Factor           | Healthy@Entry | Healthy@MAE  | Degradation | Flip Rate |
+------------------+---------------+--------------+-------------+-----------+
| Vol Delta        |    68.2%      |    41.3%     |   -26.9pp   |   31.2%   |
| Cvd Slope        |    72.1%      |    48.4%     |   -23.7pp   |   28.5%   |
| Vwap             |    61.5%      |    42.8%     |   -18.7pp   |   22.1%   |
| M5 Structure     |    58.3%      |    44.2%     |   -14.1pp   |   18.4%   |
| Vol Roc          |    56.8%      |    45.1%     |   -11.7pp   |   15.2%   |
+------------------+---------------+--------------+-------------+-----------+

Key Findings:
- Winners start with higher Health Score (+0.5 points at entry)
- Divergent paths: Winners improve (+0.7), losers degrade (-1.7)
- Timing: Winners reach MFE in 18 bars, losers hit MAE in 12 bars
- Best Early Warning: health_score drop of -2 within 5 bars
- Fastest Degrading Factor: Vol Delta (-26.9pp drop from entry to MAE)
```

---

## 10. NOTES FOR CLAUDE CODE

1. **Data Source**: Use `m5_trade_bars` table (NOT the hypothetical `trade_bars` table from the original spec). This table exists and has 58,481+ records populated.

2. **Event Types**: The m5_trade_bars table uses these event types:
   - `ENTRY` - First bar (bar_seq = 0)
   - `IN_TRADE` - Regular bars during trade
   - `MFE` - Bar at Maximum Favorable Excursion time
   - `MAE` - Bar at Maximum Adverse Excursion time
   - `MFE_MAE` - When MFE and MAE occur on same bar

3. **Health Score Range**: The health_score column is 0-10 (not 0-100). Adjust thresholds accordingly.

4. **Score Components**: Three sub-scores are available:
   - `structure_score` (0-4): Sum of 4 structure factors
   - `volume_score` (0-3): Sum of 3 volume factors
   - `price_score` (0-3): Sum of 3 price factors

5. **Column Names**: Use correct column names from m5_trade_bars:
   - `bars_from_entry` (not `bars_since_entry`)
   - `bar_seq` (sequential 0, 1, 2...)
   - `sma_momentum_ratio` (not `sma_momentum`)
   - `health_label` (CRITICAL, WEAK, MODERATE, STRONG)

6. **Chart Colors**: Maintain consistency:
   - Winners = teal (#26a69a)
   - Losers = red (#ef5350)
   - Structure = purple (#7c3aed)
   - Volume = blue (#3b82f6)
   - Price = green (#10b981)

7. **Minimum Samples**: Require at least 30 trades per group for statistical validity.

8. **Bar-by-Bar Analysis**: Limit to first 30 bars from entry for performance.

9. **Dark Theme**: Use consistent Plotly dark theme settings:
   ```python
   template="plotly_dark",
   paper_bgcolor="#16213e",
   plot_bgcolor="#1a1a2e",
   font=dict(color="#e0e0e0")
   ```

---

**END OF DOCUMENT - VERSION 2.0**
