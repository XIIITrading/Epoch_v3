================================================================================
OPTIONS STOP TYPE ANALYSIS (CALC-O09)
================================================================================
File: 01_op_stop_analysis.txt
Purpose: Define and implement stop type analysis for options trades
Mirrors: CALC-009 (Stop Type Analysis) from Metrics Overview
================================================================================

OVERVIEW
--------
Create a new calculation module that analyzes different stop placement methods
for options trades. Unlike underlying stops (zone-based, ATR-based), options
stops are percentage-based since options don't have zone boundaries.

================================================================================
STOP TYPES TO ANALYZE
================================================================================

PROPOSED OPTIONS STOP TYPES:
----------------------------

1. STOP_10PCT - 10% Loss Stop
   - Stop triggers when option loses 10% from entry
   - Tightest stop, highest stop-out rate expected
   - Good for: High-probability setups, scalping

2. STOP_15PCT - 15% Loss Stop
   - Stop triggers when option loses 15% from entry
   - Tight stop with some breathing room

3. STOP_20PCT - 20% Loss Stop
   - Stop triggers when option loses 20% from entry
   - Moderate stop level

4. STOP_25PCT - 25% Loss Stop (RECOMMENDED DEFAULT)
   - Stop triggers when option loses 25% from entry
   - Balances protection vs premature stop-outs
   - Similar philosophy to "Zone + 5% Buffer" for underlying

5. STOP_30PCT - 30% Loss Stop
   - Stop triggers when option loses 30% from entry
   - Wider stop for volatile options

6. STOP_50PCT - 50% Loss Stop
   - Stop triggers when option loses 50% from entry
   - Very wide stop, "let it ride" approach

ALTERNATIVE CONSIDERATION:
--------------------------
- ATR-based stops using options ATR (if available)
- Delta-adjusted stops (e.g., 1 ATR of underlying * delta)

================================================================================
FILE STRUCTURE
================================================================================

Location: C:\XIIITradingSystems\Epoch\02_zone_system\12_system_analysis\
          calculations\options\op_stop_analysis\

Files to Create:
----------------
op_stop_analysis/
    __init__.py              # Package exports
    stop_types.py            # Stop type definitions and constants
    stop_calculator.py       # Calculate stop prices for each type
    outcome_simulator.py     # Simulate outcomes (stop hit vs target)
    results_aggregator.py    # Aggregate results by stop type
    ui_components.py         # Streamlit rendering functions

================================================================================
DETAILED FILE SPECIFICATIONS
================================================================================

-----------------------------------------------------------------------------
FILE: __init__.py
-----------------------------------------------------------------------------
Purpose: Package initialization and exports

```python
"""
Options Stop Type Analysis (CALC-O09)
Analyzes different stop placement methods for options trades.
"""

from .stop_types import (
    OPTIONS_STOP_TYPES,
    DEFAULT_OPTIONS_STOP_TYPE,
    get_stop_type_display_name
)
from .stop_calculator import calculate_option_stop_price
from .outcome_simulator import simulate_option_outcomes
from .results_aggregator import (
    aggregate_by_stop_type,
    aggregate_by_model_contract,
    find_best_stop_type
)
from .ui_components import (
    render_op_stop_analysis_section,
    render_op_stop_summary_cards,
    render_op_stop_comparison_table
)

__all__ = [
    'OPTIONS_STOP_TYPES',
    'DEFAULT_OPTIONS_STOP_TYPE',
    'get_stop_type_display_name',
    'calculate_option_stop_price',
    'simulate_option_outcomes',
    'aggregate_by_stop_type',
    'aggregate_by_model_contract',
    'find_best_stop_type',
    'render_op_stop_analysis_section',
    'render_op_stop_summary_cards',
    'render_op_stop_comparison_table'
]
```

-----------------------------------------------------------------------------
FILE: stop_types.py
-----------------------------------------------------------------------------
Purpose: Define stop type constants and metadata

```python
"""
Options Stop Type Definitions

Defines the stop types available for options analysis.
All stops are percentage-based from option entry price.
"""

from typing import Dict, Any

# Stop type definitions
# Key: internal identifier
# Value: metadata about the stop
OPTIONS_STOP_TYPES: Dict[str, Dict[str, Any]] = {
    "stop_10pct": {
        "display_name": "10% Stop",
        "short_name": "10%",
        "loss_pct": 10.0,
        "description": "Stop at 10% loss from entry",
        "risk_level": "tight"
    },
    "stop_15pct": {
        "display_name": "15% Stop",
        "short_name": "15%",
        "loss_pct": 15.0,
        "description": "Stop at 15% loss from entry",
        "risk_level": "tight"
    },
    "stop_20pct": {
        "display_name": "20% Stop",
        "short_name": "20%",
        "loss_pct": 20.0,
        "description": "Stop at 20% loss from entry",
        "risk_level": "moderate"
    },
    "stop_25pct": {
        "display_name": "25% Stop",
        "short_name": "25%",
        "loss_pct": 25.0,
        "description": "Stop at 25% loss from entry (recommended)",
        "risk_level": "moderate"
    },
    "stop_30pct": {
        "display_name": "30% Stop",
        "short_name": "30%",
        "loss_pct": 30.0,
        "description": "Stop at 30% loss from entry",
        "risk_level": "wide"
    },
    "stop_50pct": {
        "display_name": "50% Stop",
        "short_name": "50%",
        "loss_pct": 50.0,
        "description": "Stop at 50% loss from entry",
        "risk_level": "very_wide"
    }
}

# Default stop type (used for Monte AI prompt)
DEFAULT_OPTIONS_STOP_TYPE = "stop_25pct"

# Ordered list for display
STOP_TYPE_ORDER = [
    "stop_10pct",
    "stop_15pct",
    "stop_20pct",
    "stop_25pct",
    "stop_30pct",
    "stop_50pct"
]


def get_stop_type_display_name(stop_type: str, short: bool = False) -> str:
    """Get display name for a stop type."""
    if stop_type not in OPTIONS_STOP_TYPES:
        return stop_type

    key = "short_name" if short else "display_name"
    return OPTIONS_STOP_TYPES[stop_type][key]


def get_stop_loss_pct(stop_type: str) -> float:
    """Get the loss percentage for a stop type."""
    if stop_type not in OPTIONS_STOP_TYPES:
        return 25.0  # Default
    return OPTIONS_STOP_TYPES[stop_type]["loss_pct"]
```

-----------------------------------------------------------------------------
FILE: stop_calculator.py
-----------------------------------------------------------------------------
Purpose: Calculate stop prices and determine if stops were hit

```python
"""
Options Stop Price Calculator

Calculates stop prices for each stop type and determines
whether the stop would have been triggered based on MAE.
"""

from typing import Dict, Any, Optional, List
from decimal import Decimal

from .stop_types import OPTIONS_STOP_TYPES, get_stop_loss_pct


def _safe_float(value, default: float = None) -> Optional[float]:
    """Safely convert value to float."""
    if value is None:
        return default
    try:
        if isinstance(value, Decimal):
            return float(value)
        return float(value)
    except (ValueError, TypeError):
        return default


def calculate_option_stop_price(
    entry_price: float,
    stop_type: str
) -> float:
    """
    Calculate the stop price for an option trade.

    Parameters:
    -----------
    entry_price : float
        Option entry price (e.g., $5.00)
    stop_type : str
        Stop type key (e.g., "stop_25pct")

    Returns:
    --------
    float
        Stop price (e.g., $3.75 for 25% stop on $5.00 entry)
    """
    loss_pct = get_stop_loss_pct(stop_type)
    return entry_price * (1 - loss_pct / 100)


def calculate_all_stop_prices(entry_price: float) -> Dict[str, float]:
    """
    Calculate stop prices for all stop types.

    Returns dict of {stop_type: stop_price}
    """
    return {
        stop_type: calculate_option_stop_price(entry_price, stop_type)
        for stop_type in OPTIONS_STOP_TYPES
    }


def check_stop_hit(
    entry_price: float,
    mae_price: float,
    stop_type: str
) -> bool:
    """
    Check if a stop would have been hit based on MAE.

    Options always go LONG (you buy the option), so adverse movement
    is always the option price going DOWN.

    Parameters:
    -----------
    entry_price : float
        Option entry price
    mae_price : float
        Minimum price reached (max adverse excursion)
    stop_type : str
        Stop type to check

    Returns:
    --------
    bool
        True if stop was hit, False otherwise
    """
    stop_price = calculate_option_stop_price(entry_price, stop_type)

    # Stop is hit if price dropped to or below stop level
    return mae_price <= stop_price


def calculate_stop_distance_pct(
    entry_price: float,
    stop_type: str
) -> float:
    """
    Calculate stop distance as percentage of entry.
    This is simply the loss_pct for the stop type.
    """
    return get_stop_loss_pct(stop_type)
```

-----------------------------------------------------------------------------
FILE: outcome_simulator.py
-----------------------------------------------------------------------------
Purpose: Simulate outcomes for each trade at each stop level

```python
"""
Options Outcome Simulator

Simulates trade outcomes for each stop type.
Determines win/loss based on whether target was reached before stop.
"""

from typing import Dict, Any, List, Optional
from decimal import Decimal

from .stop_types import OPTIONS_STOP_TYPES, STOP_TYPE_ORDER
from .stop_calculator import (
    calculate_option_stop_price,
    check_stop_hit,
    calculate_stop_distance_pct
)


def _safe_float(value, default: float = None) -> Optional[float]:
    """Safely convert value to float."""
    if value is None:
        return default
    try:
        if isinstance(value, Decimal):
            return float(value)
        return float(value)
    except (ValueError, TypeError):
        return default


def simulate_single_trade(
    trade: Dict[str, Any],
    target_pct: float = 50.0
) -> Dict[str, Dict[str, Any]]:
    """
    Simulate outcomes for a single trade across all stop types.

    Parameters:
    -----------
    trade : Dict
        Trade data with keys:
        - option_entry_price: Entry price of option
        - mfe_pct: Maximum favorable excursion (% gain)
        - mae_pct: Maximum adverse excursion (% loss, positive value)
        - exit_pct: Final exit (% gain/loss)
        - mfe_time: When MFE occurred
        - mae_time: When MAE occurred
        - model: EPCH01-04
        - contract_type: CALL or PUT
        - trade_id: Unique identifier
    target_pct : float
        Target profit percentage (default 50%)

    Returns:
    --------
    Dict[str, Dict]
        Results for each stop type
    """
    entry_price = _safe_float(trade.get('option_entry_price'))
    mfe_pct = _safe_float(trade.get('mfe_pct'), 0)
    mae_pct = _safe_float(trade.get('mae_pct'), 0)

    if entry_price is None or entry_price <= 0:
        return {}

    results = {}

    for stop_type in STOP_TYPE_ORDER:
        stop_loss_pct = OPTIONS_STOP_TYPES[stop_type]['loss_pct']

        # Determine if stop was hit
        # mae_pct is stored as positive value (e.g., 25 means -25% move)
        stop_hit = mae_pct >= stop_loss_pct

        # Determine if target was reached
        target_reached = mfe_pct >= target_pct

        # Determine outcome
        # Need to check WHICH happened first using time data
        mfe_time = trade.get('mfe_time')
        mae_time = trade.get('mae_time')

        if stop_hit and target_reached:
            # Both happened - need to check which was first
            # If mfe_time < mae_time, target was hit first (WIN)
            # If mae_time < mfe_time, stop was hit first (LOSS)
            if mfe_time and mae_time:
                # Compare times
                mfe_first = mfe_time < mae_time
                outcome = 'WIN' if mfe_first else 'LOSS'
                r_achieved = (mfe_pct / stop_loss_pct) if mfe_first else -1.0
            else:
                # No time data - assume stop hit first (conservative)
                outcome = 'LOSS'
                r_achieved = -1.0
        elif target_reached and not stop_hit:
            # Target reached, stop never hit
            outcome = 'WIN'
            r_achieved = mfe_pct / stop_loss_pct
        elif stop_hit and not target_reached:
            # Stop hit, target never reached
            outcome = 'LOSS'
            r_achieved = -1.0
        else:
            # Neither hit - partial result
            # Use exit_pct to determine outcome
            exit_pct = _safe_float(trade.get('exit_pct'), 0)
            if exit_pct >= 0:
                outcome = 'PARTIAL_WIN'
                r_achieved = exit_pct / stop_loss_pct
            else:
                outcome = 'PARTIAL_LOSS'
                r_achieved = exit_pct / stop_loss_pct

        results[stop_type] = {
            'trade_id': trade.get('trade_id'),
            'model': trade.get('model'),
            'contract_type': trade.get('contract_type'),
            'direction': trade.get('direction', 'LONG'),
            'stop_type': stop_type,
            'entry_price': entry_price,
            'stop_loss_pct': stop_loss_pct,
            'mfe_pct': mfe_pct,
            'mae_pct': mae_pct,
            'stop_hit': stop_hit,
            'target_reached': target_reached,
            'r_achieved': r_achieved,
            'outcome': outcome
        }

    return results


def simulate_all_outcomes(
    trades_data: List[Dict[str, Any]],
    target_pct: float = 50.0
) -> Dict[str, List[Dict[str, Any]]]:
    """
    Simulate outcomes for all trades across all stop types.

    Returns:
    --------
    Dict[str, List[Dict]]
        Results grouped by stop_type
    """
    results = {stop_type: [] for stop_type in STOP_TYPE_ORDER}

    for trade in trades_data:
        trade_results = simulate_single_trade(trade, target_pct)

        for stop_type, result in trade_results.items():
            results[stop_type].append(result)

    return results
```

-----------------------------------------------------------------------------
FILE: results_aggregator.py
-----------------------------------------------------------------------------
Purpose: Aggregate simulation results into summary statistics

```python
"""
Options Stop Analysis Results Aggregator

Aggregates simulation results by stop type, model, contract type.
"""

import pandas as pd
from typing import Dict, List, Any, Optional

from .stop_types import OPTIONS_STOP_TYPES, STOP_TYPE_ORDER


def aggregate_by_stop_type(
    results: Dict[str, List[Dict[str, Any]]]
) -> pd.DataFrame:
    """
    Aggregate results by stop type.

    Returns DataFrame with columns:
    - Stop Type: Display name
    - n: Trade count
    - Wins: Win count
    - Losses: Loss count
    - Win Rate %: Win percentage
    - Avg R (Win): Average R on winners
    - Avg R (All): Average R overall (expectancy)
    - Stop Hit %: Percentage of trades where stop was hit
    """
    rows = []

    for stop_type in STOP_TYPE_ORDER:
        type_results = results.get(stop_type, [])

        if not type_results:
            continue

        n = len(type_results)

        # Count outcomes
        wins = sum(1 for r in type_results if r['outcome'] in ['WIN', 'PARTIAL_WIN'])
        losses = sum(1 for r in type_results if r['outcome'] in ['LOSS', 'PARTIAL_LOSS'])
        stop_hits = sum(1 for r in type_results if r['stop_hit'])

        # Calculate averages
        r_values = [r['r_achieved'] for r in type_results]
        avg_r_all = sum(r_values) / len(r_values) if r_values else 0

        win_r_values = [r['r_achieved'] for r in type_results
                        if r['outcome'] in ['WIN', 'PARTIAL_WIN']]
        avg_r_win = sum(win_r_values) / len(win_r_values) if win_r_values else 0

        rows.append({
            'Stop Type': OPTIONS_STOP_TYPES[stop_type]['display_name'],
            'stop_type_key': stop_type,
            'Stop %': OPTIONS_STOP_TYPES[stop_type]['loss_pct'],
            'n': n,
            'Wins': wins,
            'Losses': losses,
            'Win Rate %': (wins / n) * 100 if n > 0 else 0,
            'Stop Hit %': (stop_hits / n) * 100 if n > 0 else 0,
            'Avg R (Win)': avg_r_win,
            'Avg R (All)': avg_r_all,
            'Expectancy': avg_r_all
        })

    return pd.DataFrame(rows)


def aggregate_by_model_contract(
    results: Dict[str, List[Dict[str, Any]]]
) -> pd.DataFrame:
    """
    Aggregate results by model and contract type for each stop type.
    """
    rows = []

    for stop_type in STOP_TYPE_ORDER:
        type_results = results.get(stop_type, [])

        if not type_results:
            continue

        # Group by model and contract_type
        df = pd.DataFrame(type_results)

        if 'model' not in df.columns or 'contract_type' not in df.columns:
            continue

        for (model, contract), group in df.groupby(['model', 'contract_type']):
            n = len(group)
            wins = sum(1 for _, r in group.iterrows()
                      if r['outcome'] in ['WIN', 'PARTIAL_WIN'])

            r_values = group['r_achieved'].tolist()
            avg_r = sum(r_values) / len(r_values) if r_values else 0

            rows.append({
                'Stop Type': OPTIONS_STOP_TYPES[stop_type]['short_name'],
                'Model': model,
                'Contract': contract,
                'n': n,
                'Win Rate %': (wins / n) * 100 if n > 0 else 0,
                'Expectancy': avg_r
            })

    return pd.DataFrame(rows)


def find_best_stop_type(
    summary_df: pd.DataFrame,
    metric: str = 'Expectancy'
) -> Dict[str, Any]:
    """
    Find the best performing stop type based on specified metric.
    """
    if summary_df.empty:
        return {'stop_type': 'N/A', 'expectancy': 0}

    # Filter for minimum sample size
    valid_df = summary_df[summary_df['n'] >= 10]

    if valid_df.empty:
        valid_df = summary_df

    best_idx = valid_df[metric].idxmax()
    best_row = valid_df.loc[best_idx]

    return {
        'stop_type': best_row['Stop Type'],
        'stop_type_key': best_row['stop_type_key'],
        'expectancy': best_row['Expectancy'],
        'win_rate': best_row['Win Rate %'],
        'n': best_row['n']
    }
```

-----------------------------------------------------------------------------
FILE: ui_components.py
-----------------------------------------------------------------------------
Purpose: Streamlit UI components for displaying results

```python
"""
Options Stop Analysis UI Components

Streamlit rendering functions for CALC-O09.
"""

import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from typing import Dict, List, Any, Optional

from .stop_types import OPTIONS_STOP_TYPES, DEFAULT_OPTIONS_STOP_TYPE
from .outcome_simulator import simulate_all_outcomes
from .results_aggregator import (
    aggregate_by_stop_type,
    aggregate_by_model_contract,
    find_best_stop_type
)


CHART_COLORS = {
    "win": "#26a69a",
    "loss": "#ef5350",
    "background": "#1a1a2e",
    "paper": "#16213e",
    "text": "#e0e0e0",
    "grid": "#2a2a4e"
}


def render_op_stop_summary_cards(
    summary_df: pd.DataFrame,
    best_stop: Dict[str, Any],
    total_trades: int
) -> None:
    """Render summary metric cards."""
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric(
            label="Best Stop Type",
            value=best_stop.get('stop_type', 'N/A')
        )

    with col2:
        if not summary_df.empty:
            best_wr = summary_df['Win Rate %'].max()
            st.metric(label="Best Win Rate", value=f"{best_wr:.1f}%")
        else:
            st.metric(label="Best Win Rate", value="N/A")

    with col3:
        exp_value = best_stop.get('expectancy', 0)
        st.metric(
            label="Best Expectancy",
            value=f"{exp_value:+.2f}R" if exp_value != 0 else "N/A"
        )

    with col4:
        st.metric(label="Options Analyzed", value=f"{total_trades:,}")


def render_op_stop_comparison_table(summary_df: pd.DataFrame) -> None:
    """Render the stop type comparison table."""
    if summary_df.empty:
        st.info("No options stop analysis data available")
        return

    display_df = summary_df.copy()

    if 'stop_type_key' in display_df.columns:
        display_df = display_df.drop(columns=['stop_type_key'])

    # Format columns
    display_df['Stop %'] = display_df['Stop %'].apply(lambda x: f"{x:.0f}%")
    display_df['Win Rate %'] = display_df['Win Rate %'].apply(lambda x: f"{x:.1f}%")
    display_df['Stop Hit %'] = display_df['Stop Hit %'].apply(lambda x: f"{x:.1f}%")
    display_df['Avg R (Win)'] = display_df['Avg R (Win)'].apply(lambda x: f"{x:+.2f}R")
    display_df['Expectancy'] = display_df['Expectancy'].apply(lambda x: f"{x:+.3f}")

    st.dataframe(display_df, use_container_width=True, hide_index=True)


def render_op_stop_charts(summary_df: pd.DataFrame) -> None:
    """Render win rate and expectancy charts."""
    if summary_df.empty:
        return

    col1, col2 = st.columns(2)

    with col1:
        # Win Rate Chart
        valid_df = summary_df[summary_df['n'] > 0].copy()
        valid_df = valid_df.sort_values('Win Rate %', ascending=True)

        colors = [CHART_COLORS['win'] if x >= 50 else CHART_COLORS['loss']
                  for x in valid_df['Win Rate %']]

        fig = go.Figure()
        fig.add_trace(go.Bar(
            x=valid_df['Win Rate %'],
            y=valid_df['Stop Type'],
            orientation='h',
            marker_color=colors,
            text=valid_df['Win Rate %'].apply(lambda x: f"{x:.1f}%"),
            textposition='auto'
        ))

        fig.add_vline(x=50, line_dash="dash", line_color=CHART_COLORS['text'])

        fig.update_layout(
            title="Win Rate by Stop Type",
            paper_bgcolor=CHART_COLORS['paper'],
            plot_bgcolor=CHART_COLORS['background'],
            font=dict(color=CHART_COLORS['text']),
            height=350
        )

        st.plotly_chart(fig, use_container_width=True)

    with col2:
        # Expectancy Chart
        valid_df = summary_df[summary_df['n'] > 0].copy()
        valid_df = valid_df.sort_values('Expectancy', ascending=True)

        colors = [CHART_COLORS['win'] if x >= 0 else CHART_COLORS['loss']
                  for x in valid_df['Expectancy']]

        fig = go.Figure()
        fig.add_trace(go.Bar(
            x=valid_df['Expectancy'],
            y=valid_df['Stop Type'],
            orientation='h',
            marker_color=colors,
            text=valid_df['Expectancy'].apply(lambda x: f"{x:+.3f}R"),
            textposition='auto'
        ))

        fig.add_vline(x=0, line_dash="dash", line_color=CHART_COLORS['text'])

        fig.update_layout(
            title="Expectancy by Stop Type",
            paper_bgcolor=CHART_COLORS['paper'],
            plot_bgcolor=CHART_COLORS['background'],
            font=dict(color=CHART_COLORS['text']),
            height=350
        )

        st.plotly_chart(fig, use_container_width=True)


def render_op_stop_analysis_section(
    options_data: List[Dict[str, Any]],
    target_pct: float = 50.0
) -> Optional[Dict[str, Any]]:
    """
    Main entry point for options stop analysis UI.

    Renders the complete CALC-O09 section.
    """
    st.subheader("Options Stop Type Analysis")
    st.markdown("*Foundation analysis: Which stop level provides best risk-adjusted returns for options?*")

    if not options_data:
        st.warning("No options MFE/MAE data available for stop analysis")
        return None

    with st.spinner("Analyzing options stop types..."):
        results = simulate_all_outcomes(options_data, target_pct)
        summary_df = aggregate_by_stop_type(results)
        best_stop = find_best_stop_type(summary_df)
        total_trades = len(options_data)

    if summary_df.empty:
        st.warning("No stop analysis results available")
        return None

    # Render UI
    render_op_stop_summary_cards(summary_df, best_stop, total_trades)

    st.markdown("---")

    st.markdown("**Stop Type Comparison**")
    st.caption(f"*Target: {target_pct:.0f}% gain | Win = Target reached before stop*")
    render_op_stop_comparison_table(summary_df)

    st.markdown("---")

    render_op_stop_charts(summary_df)

    # Model-Contract breakdown
    st.markdown("---")
    with st.expander("View by Model and Contract Type"):
        model_df = aggregate_by_model_contract(results)
        if not model_df.empty:
            st.dataframe(model_df, use_container_width=True, hide_index=True)
        else:
            st.info("No model breakdown available")

    return {
        'summary': summary_df,
        'results': results,
        'best_stop': best_stop,
        'total_trades': total_trades
    }
```

================================================================================
TESTING REQUIREMENTS
================================================================================

1. Unit tests for stop_calculator.py:
   - Test stop price calculations for each stop type
   - Test check_stop_hit logic

2. Unit tests for outcome_simulator.py:
   - Test single trade simulation
   - Test edge cases (no data, missing fields)
   - Test outcome determination logic

3. Integration test:
   - Run against sample op_mfe_mae_potential data
   - Verify results match expected outcomes

================================================================================
QUESTIONS FOR REVIEW
================================================================================

1. TARGET PERCENTAGE:
   Current default is 50% gain. Should this be:
   - Configurable by user (slider)?
   - Fixed at 50%?
   - Multiple targets analyzed (25%, 50%, 100%)?

2. OUTCOME DETERMINATION:
   When both stop and target are hit, we check which happened first.
   If time data is missing, we assume stop was hit first (conservative).
   Is this the right approach?

3. PARTIAL OUTCOMES:
   Currently treating partial wins/losses separately.
   Should these count as wins or losses for Win Rate calculation?

================================================================================
