================================================================================
TRADES TABLE STOP-BASED OUTCOME UPSERT PROCESSOR
================================================================================
Project: Epoch Trading System
Module: 09_backtest/processor/secondary_analysis OR 13_database_export
Goal: Add stop-based win/loss outcome column to trades table
Date: 2026-01-23
================================================================================

OBJECTIVE
---------
Create a processor that upserts a stop-based win/loss outcome column to the
trades table, sourced from the stop_analysis table. This allows downstream
consumers (like batch_analyzer) to use the more accurate stop-based win
definition instead of the backtest pnl_dollars > 0 definition.

================================================================================
CURRENT STATE
================================================================================

TRADES TABLE (Current):
-----------------------
- is_winner: BOOLEAN - Based on pnl_dollars > 0 (backtest exit outcome)
- This includes wins from:
  * TARGET exits (3R) - Always profitable
  * CHOCH exits - Variable, could be small profit
  * EOD exits - Variable, could be small profit
  * STOP exits - Always loss (-1R)

PROBLEM:
--------
A trade that exited at EOD with +0.01R is counted as a "win" but this is not
a meaningful win for analysis purposes. The system_analysis module solved this
by using stop_analysis outcomes, but other modules (batch_analyzer, training)
still use the old is_winner column.

STOP_ANALYSIS TABLE (Source of Truth):
--------------------------------------
- outcome: VARCHAR(10) - 'WIN', 'LOSS', 'PARTIAL'
- WIN = MFE reached >= 1R before stop hit
- LOSS = Stop hit before reaching 1R
- PARTIAL = Stop hit after some MFE but < 1R
- Keyed by (trade_id, stop_type)

================================================================================
SOLUTION: ADD STOP-BASED OUTCOME COLUMNS TO TRADES TABLE
================================================================================

OPTION A: Add Single Column (Recommended)
-----------------------------------------
Add one column using the default stop type (zone_buffer):

  stop_outcome VARCHAR(10)  -- 'WIN', 'LOSS', 'PARTIAL' from stop_analysis

Pros:
- Simple, single source of truth
- Easy to query
- Consistent with system_analysis default

Cons:
- Only one stop type available
- Users can't easily compare stop types in trades table

OPTION B: Add Multiple Columns
------------------------------
Add columns for each stop type:

  stop_outcome_zone_buffer VARCHAR(10)
  stop_outcome_prior_m1 VARCHAR(10)
  stop_outcome_prior_m5 VARCHAR(10)
  stop_outcome_m5_atr VARCHAR(10)
  stop_outcome_m15_atr VARCHAR(10)
  stop_outcome_fractal VARCHAR(10)

Pros:
- All stop types available in one query
- Easy comparison

Cons:
- Schema bloat (6 new columns)
- Redundant with stop_analysis table

RECOMMENDATION: Option A (single column with zone_buffer default)
-----------------------------------------------------------------
The stop_analysis table already stores all stop types. Adding a single
column to trades for the default stop type provides convenience without
redundancy. Users needing other stop types can join with stop_analysis.

================================================================================
IMPLEMENTATION PLAN
================================================================================

STEP 1: ALTER TRADES TABLE
--------------------------
Location: Schema migration or manual SQL

```sql
-- Add stop-based outcome column
ALTER TABLE trades
ADD COLUMN IF NOT EXISTS stop_outcome VARCHAR(10);

-- Add index for filtering
CREATE INDEX IF NOT EXISTS idx_trades_stop_outcome
ON trades(stop_outcome);

-- Add constraint
ALTER TABLE trades
ADD CONSTRAINT valid_stop_outcome
CHECK (stop_outcome IS NULL OR stop_outcome IN ('WIN', 'LOSS', 'PARTIAL'));

-- Add comment
COMMENT ON COLUMN trades.stop_outcome IS
'Stop-based outcome from stop_analysis (zone_buffer): WIN (>=1R before stop), LOSS (stopped), PARTIAL (0<R<1)';
```

STEP 2: CREATE UPSERT PROCESSOR
-------------------------------
Location: C:\XIIITradingSystems\Epoch\02_zone_system\09_backtest\processor\secondary_analysis\stop_outcome_upsert\

Files:
  __init__.py
  config.py
  upsert.py
  runner.py

config.py:
```python
"""
Stop Outcome Upsert Configuration
"""
from pathlib import Path

# Database
from credentials import (
    SUPABASE_HOST, SUPABASE_PORT, SUPABASE_DATABASE,
    SUPABASE_USER, SUPABASE_PASSWORD
)

DB_CONFIG = {
    "host": SUPABASE_HOST,
    "port": SUPABASE_PORT,
    "database": SUPABASE_DATABASE,
    "user": SUPABASE_USER,
    "password": SUPABASE_PASSWORD,
    "sslmode": "require"
}

# Default stop type to use for trades.stop_outcome
DEFAULT_STOP_TYPE = "zone_buffer"

# Batch size for updates
BATCH_SIZE = 500

# Tables
TRADES_TABLE = "trades"
STOP_ANALYSIS_TABLE = "stop_analysis"
```

upsert.py:
```python
"""
Stop Outcome Upsert Processor
Updates trades.stop_outcome from stop_analysis table.
"""

import psycopg2
from psycopg2.extras import execute_batch
from datetime import datetime
from typing import Dict, Any, Optional

from config import (
    DB_CONFIG, DEFAULT_STOP_TYPE, BATCH_SIZE,
    TRADES_TABLE, STOP_ANALYSIS_TABLE
)


class StopOutcomeUpserter:
    """
    Updates trades.stop_outcome column from stop_analysis table.

    Uses the default stop type (zone_buffer) as the source of truth.
    """

    def __init__(self, stop_type: str = DEFAULT_STOP_TYPE, verbose: bool = True):
        self.stop_type = stop_type
        self.verbose = verbose
        self.stats = {
            'total_trades': 0,
            'updated': 0,
            'already_current': 0,
            'no_stop_data': 0,
            'errors': []
        }

    def run(self, dry_run: bool = False) -> Dict[str, Any]:
        """
        Run the upsert process.

        Args:
            dry_run: If True, don't commit changes

        Returns:
            Statistics dictionary
        """
        start_time = datetime.now()

        print("=" * 60)
        print(f"STOP OUTCOME UPSERT PROCESSOR")
        print("=" * 60)
        print(f"Stop Type: {self.stop_type}")
        print(f"Dry Run: {dry_run}")
        print()

        conn = None
        try:
            conn = psycopg2.connect(**DB_CONFIG)

            # Step 1: Get trades needing update
            print("[1/3] Finding trades to update...")
            trades_to_update = self._get_trades_needing_update(conn)
            self.stats['total_trades'] = len(trades_to_update)
            print(f"  Found {len(trades_to_update)} trades to update")

            if not trades_to_update:
                print("\n  No trades need updating.")
                return self._build_result(start_time)

            # Step 2: Get stop outcomes
            print("\n[2/3] Fetching stop outcomes...")
            trade_ids = [t['trade_id'] for t in trades_to_update]
            stop_outcomes = self._get_stop_outcomes(conn, trade_ids)
            print(f"  Found stop data for {len(stop_outcomes)} trades")

            # Step 3: Update trades
            print("\n[3/3] Updating trades...")
            self._update_trades(conn, trades_to_update, stop_outcomes, dry_run)

            if not dry_run:
                conn.commit()
                print(f"  Committed {self.stats['updated']} updates")
            else:
                print(f"  [DRY-RUN] Would update {self.stats['updated']} trades")

            return self._build_result(start_time)

        except Exception as e:
            self.stats['errors'].append(str(e))
            if conn:
                conn.rollback()
            raise
        finally:
            if conn:
                conn.close()

    def _get_trades_needing_update(self, conn) -> list:
        """Get trades where stop_outcome is NULL or doesn't match stop_analysis."""
        query = f"""
            SELECT t.trade_id, t.stop_outcome
            FROM {TRADES_TABLE} t
            WHERE EXISTS (
                SELECT 1 FROM {STOP_ANALYSIS_TABLE} sa
                WHERE sa.trade_id = t.trade_id
                  AND sa.stop_type = %s
                  AND sa.outcome IS NOT NULL
            )
            AND (
                t.stop_outcome IS NULL
                OR t.stop_outcome != (
                    SELECT sa.outcome
                    FROM {STOP_ANALYSIS_TABLE} sa
                    WHERE sa.trade_id = t.trade_id
                      AND sa.stop_type = %s
                )
            )
        """

        with conn.cursor() as cur:
            cur.execute(query, (self.stop_type, self.stop_type))
            columns = [desc[0] for desc in cur.description]
            rows = cur.fetchall()

        return [dict(zip(columns, row)) for row in rows]

    def _get_stop_outcomes(self, conn, trade_ids: list) -> Dict[str, str]:
        """Get stop outcomes for specified trades."""
        if not trade_ids:
            return {}

        placeholders = ','.join(['%s'] * len(trade_ids))
        query = f"""
            SELECT trade_id, outcome
            FROM {STOP_ANALYSIS_TABLE}
            WHERE trade_id IN ({placeholders})
              AND stop_type = %s
              AND outcome IS NOT NULL
        """

        with conn.cursor() as cur:
            cur.execute(query, tuple(trade_ids) + (self.stop_type,))
            rows = cur.fetchall()

        return {row[0]: row[1] for row in rows}

    def _update_trades(self, conn, trades: list, stop_outcomes: Dict[str, str], dry_run: bool):
        """Update trades with stop outcomes."""
        updates = []

        for trade in trades:
            trade_id = trade['trade_id']

            if trade_id not in stop_outcomes:
                self.stats['no_stop_data'] += 1
                continue

            outcome = stop_outcomes[trade_id]
            updates.append((outcome, trade_id))

        if not updates:
            return

        if dry_run:
            self.stats['updated'] = len(updates)
            return

        query = f"UPDATE {TRADES_TABLE} SET stop_outcome = %s WHERE trade_id = %s"

        with conn.cursor() as cur:
            execute_batch(cur, query, updates, page_size=BATCH_SIZE)

        self.stats['updated'] = len(updates)

    def _build_result(self, start_time: datetime) -> Dict[str, Any]:
        """Build result dictionary."""
        elapsed = (datetime.now() - start_time).total_seconds()

        result = {
            'stop_type': self.stop_type,
            'total_trades': self.stats['total_trades'],
            'updated': self.stats['updated'],
            'no_stop_data': self.stats['no_stop_data'],
            'errors': self.stats['errors'],
            'execution_time_seconds': round(elapsed, 2)
        }

        print("\n" + "=" * 60)
        print("COMPLETE")
        print("=" * 60)
        for key, value in result.items():
            print(f"  {key}: {value}")

        return result
```

runner.py:
```python
"""
Runner script for stop outcome upsert.
"""

import argparse
from upsert import StopOutcomeUpserter
from config import DEFAULT_STOP_TYPE


def main():
    parser = argparse.ArgumentParser(description='Upsert stop outcomes to trades table')
    parser.add_argument('--stop-type', default=DEFAULT_STOP_TYPE,
                        help=f'Stop type to use (default: {DEFAULT_STOP_TYPE})')
    parser.add_argument('--dry-run', action='store_true',
                        help='Run without committing changes')
    args = parser.parse_args()

    upserter = StopOutcomeUpserter(stop_type=args.stop_type)
    upserter.run(dry_run=args.dry_run)


if __name__ == '__main__':
    main()
```

STEP 3: INTEGRATE INTO BATCH WORKFLOW
-------------------------------------
Add to the secondary analysis run_all.py or create a standalone script that
runs after stop_analysis is populated.

Order of operations:
1. Run backtest (populates trades table)
2. Run stop_analysis calculator (populates stop_analysis table)
3. Run stop_outcome_upsert (updates trades.stop_outcome from stop_analysis)

================================================================================
DOWNSTREAM UPDATES
================================================================================

BATCH_ANALYZER (04_dow_ai/batch_analyzer):
------------------------------------------
Update trade_loader.py to use stop_outcome:

```python
# In load_trades() query, change:
t.is_winner,

# To:
t.is_winner,
t.stop_outcome,
CASE WHEN t.stop_outcome = 'WIN' THEN TRUE
     WHEN t.stop_outcome IN ('LOSS', 'PARTIAL') THEN FALSE
     ELSE t.is_winner  -- fallback if no stop data
END as is_winner_stop,
```

Or simpler - just use stop_outcome directly in accuracy calculations.

TRAINING MODULE (02_zone_system/10_training):
---------------------------------------------
Similar updates to use stop_outcome for win/loss statistics.

================================================================================
VERIFICATION QUERIES
================================================================================

-- Check distribution after upsert
SELECT
    stop_outcome,
    COUNT(*) as count,
    ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER(), 1) as pct
FROM trades
WHERE stop_outcome IS NOT NULL
GROUP BY stop_outcome;

-- Compare is_winner vs stop_outcome
SELECT
    is_winner,
    stop_outcome,
    COUNT(*) as count
FROM trades
WHERE stop_outcome IS NOT NULL
GROUP BY is_winner, stop_outcome
ORDER BY is_winner, stop_outcome;

-- Find trades where backtest said WIN but stop-based said LOSS
SELECT
    trade_id, ticker, date, model, direction,
    is_winner as backtest_win,
    stop_outcome as stop_based,
    pnl_r
FROM trades
WHERE is_winner = TRUE
  AND stop_outcome = 'LOSS'
ORDER BY date DESC
LIMIT 20;

================================================================================
EXPECTED RESULTS
================================================================================

After running the upsert:

1. All trades with stop_analysis data will have stop_outcome populated
2. Win rate using stop_outcome will be LOWER than is_winner because:
   - CHoCH exits with small profit will now be LOSS (didn't reach 1R)
   - EOD exits with small profit will now be LOSS (didn't reach 1R)
3. This provides a more conservative and realistic win rate

Example expected shift:
- is_winner win rate: ~45%
- stop_outcome win rate: ~35-40%

The difference represents trades that technically profited but didn't achieve
meaningful R-multiple before the trade structure broke down.

================================================================================
NOTES
================================================================================

1. This is a one-way sync: stop_analysis -> trades
2. Re-running is safe (idempotent) - only updates where values differ
3. The column defaults to NULL for trades without stop_analysis data
4. Downstream code should handle NULL gracefully with fallback to is_winner

================================================================================
