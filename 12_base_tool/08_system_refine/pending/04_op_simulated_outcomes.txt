================================================================================
OPTIONS SIMULATED OUTCOMES (CALC-O05)
================================================================================
File: 04_op_simulated_outcomes.txt
Purpose: Implement grid simulation for options stop/target optimization
Mirrors: CALC-004 (Simulated Outcome Analysis) from Metrics Overview
================================================================================

OVERVIEW
--------
Create a new calculation that simulates options trade outcomes across a grid of
stop and target combinations. This helps identify optimal stop/target parameters
for options trading.

Unlike CALC-O09 which compares stops at a single target, this analysis varies
BOTH stop and target levels to find the optimal combination.

================================================================================
REFERENCE: UNDERLYING IMPLEMENTATION
================================================================================

Location: calculations/trade_management/simulated_outcomes.py

Key Functions:
- calculate_simulated_stats(data, stop_pct, target_r)
- calculate_simulated_by_model(data, stop_pct, target_r)
- generate_stop_target_grid(data, stop_range, target_range)
- find_optimal_parameters(grid_results)
- render_simulated_outcomes_section(data)

The underlying version uses:
- Stop as % of entry price
- Target as R multiple (1R = stop distance)

For options, we'll use:
- Stop as % loss from entry (10%, 15%, 20%, etc.)
- Target as % gain from entry (25%, 50%, 75%, 100%, etc.)

================================================================================
FILE SPECIFICATION
================================================================================

Location: C:\XIIITradingSystems\Epoch\02_zone_system\12_system_analysis\
          calculations\options\op_simulated_outcomes.py

-----------------------------------------------------------------------------
FILE: op_simulated_outcomes.py
-----------------------------------------------------------------------------

```python
"""
================================================================================
EPOCH TRADING SYSTEM - MODULE 12: INDICATOR ANALYSIS
Calculation: Options Simulated Outcomes (CALC-O05)
XIII Trading LLC
================================================================================

PURPOSE:
    Simulate options trade outcomes across a grid of stop/target combinations.
    Identifies optimal parameters for options trading.

DATA SOURCE:
    Uses the `op_mfe_mae_potential` table EXCLUSIVELY.

    Key columns needed:
    - option_entry_price: Entry price of option
    - mfe_pct: Maximum favorable excursion (% gain)
    - mae_pct: Maximum adverse excursion (% loss)
    - mfe_time: When MFE occurred
    - mae_time: When MAE occurred
    - model: EPCH01-04
    - contract_type: CALL or PUT

METRICS CALCULATED:
    - Win rate at each stop/target combination
    - Expectancy (avg R) at each combination
    - Optimal stop/target parameters
    - Sensitivity analysis

================================================================================
"""

import pandas as pd
import numpy as np
from typing import List, Dict, Any, Tuple, Optional
from decimal import Decimal
import streamlit as st
import plotly.graph_objects as go
import plotly.express as px


# =============================================================================
# CONFIGURATION
# =============================================================================
MODELS = ["EPCH01", "EPCH02", "EPCH03", "EPCH04"]

# Default ranges for grid search
DEFAULT_STOP_RANGE = [10, 15, 20, 25, 30, 40, 50]  # % loss from entry
DEFAULT_TARGET_RANGE = [25, 50, 75, 100, 150, 200]  # % gain from entry

CHART_COLORS = {
    "win": "#26a69a",
    "loss": "#ef5350",
    "optimal": "#ffc107",
    "background": "#1a1a2e",
    "paper": "#16213e",
    "text": "#e0e0e0",
    "grid": "#2a2a4e"
}


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================
def _safe_float(value, default: float = None) -> Optional[float]:
    """Safely convert value to float."""
    if value is None:
        return default
    try:
        if isinstance(value, Decimal):
            return float(value)
        return float(value)
    except (ValueError, TypeError):
        return default


def _normalize_model(model_name: str) -> str:
    """Convert EPCH1 -> EPCH01, etc."""
    if model_name is None:
        return None
    if model_name in MODELS:
        return model_name
    model_map = {
        "EPCH1": "EPCH01", "EPCH2": "EPCH02",
        "EPCH3": "EPCH03", "EPCH4": "EPCH04"
    }
    return model_map.get(model_name, model_name)


# =============================================================================
# CORE CALCULATION FUNCTIONS
# =============================================================================
def simulate_options_outcome(
    mfe_pct: float,
    mae_pct: float,
    stop_pct: float,
    target_pct: float,
    mfe_first: bool = None
) -> Dict[str, Any]:
    """
    Simulate outcome for a single trade at given stop/target.

    Parameters:
    -----------
    mfe_pct : float
        Maximum favorable excursion (% gain, positive)
    mae_pct : float
        Maximum adverse excursion (% loss, positive value)
    stop_pct : float
        Stop level (% loss from entry)
    target_pct : float
        Target level (% gain from entry)
    mfe_first : bool, optional
        Whether MFE occurred before MAE. If None, assume stop hit first when both trigger.

    Returns:
    --------
    Dict with keys: outcome, r_achieved, stop_hit, target_reached
    """
    stop_hit = mae_pct >= stop_pct
    target_reached = mfe_pct >= target_pct

    if target_reached and not stop_hit:
        # Target reached, stop never hit - WIN
        outcome = 'WIN'
        r_achieved = target_pct / stop_pct  # R = target / risk
    elif stop_hit and not target_reached:
        # Stop hit, target never reached - LOSS
        outcome = 'LOSS'
        r_achieved = -1.0
    elif target_reached and stop_hit:
        # Both triggered - need to determine which was first
        if mfe_first is True:
            outcome = 'WIN'
            r_achieved = target_pct / stop_pct
        elif mfe_first is False:
            outcome = 'LOSS'
            r_achieved = -1.0
        else:
            # Unknown order - conservative assumption: stop hit first
            outcome = 'LOSS'
            r_achieved = -1.0
    else:
        # Neither triggered - trade still open at 15:30
        # Use actual exit for R calculation
        outcome = 'PARTIAL'
        r_achieved = 0  # Will be calculated from exit data if available

    return {
        'outcome': outcome,
        'r_achieved': r_achieved,
        'stop_hit': stop_hit,
        'target_reached': target_reached
    }


def calculate_simulated_stats(
    data: List[Dict[str, Any]],
    stop_pct: float,
    target_pct: float
) -> Dict[str, Any]:
    """
    Calculate win rate and expectancy at a specific stop/target combination.

    Parameters:
    -----------
    data : List[Dict]
        Options MFE/MAE data from op_mfe_mae_potential
    stop_pct : float
        Stop level (% loss)
    target_pct : float
        Target level (% gain)

    Returns:
    --------
    Dict with: n, wins, losses, win_rate, avg_r, expectancy
    """
    if not data:
        return {
            'n': 0, 'wins': 0, 'losses': 0,
            'win_rate': 0.0, 'avg_r': 0.0, 'expectancy': 0.0
        }

    results = []

    for trade in data:
        mfe_pct = _safe_float(trade.get('mfe_pct'), 0)
        mae_pct = _safe_float(trade.get('mae_pct'), 0)

        # Determine if MFE was first
        mfe_time = trade.get('mfe_time')
        mae_time = trade.get('mae_time')
        mfe_first = None
        if mfe_time and mae_time:
            mfe_first = mfe_time < mae_time

        outcome = simulate_options_outcome(mfe_pct, mae_pct, stop_pct, target_pct, mfe_first)
        results.append(outcome)

    n = len(results)
    wins = sum(1 for r in results if r['outcome'] == 'WIN')
    losses = sum(1 for r in results if r['outcome'] == 'LOSS')
    r_values = [r['r_achieved'] for r in results]

    win_rate = (wins / n) * 100 if n > 0 else 0
    avg_r = sum(r_values) / n if n > 0 else 0

    # Expectancy = (Win% * AvgWin) - (Loss% * AvgLoss)
    # For our case: AvgWin = target_pct/stop_pct, AvgLoss = 1.0
    # Expectancy = (wins/n * R) - (losses/n * 1) = avg_r
    expectancy = avg_r

    return {
        'n': n,
        'wins': wins,
        'losses': losses,
        'win_rate': win_rate,
        'avg_r': avg_r,
        'expectancy': expectancy,
        'stop_pct': stop_pct,
        'target_pct': target_pct
    }


def calculate_simulated_by_model(
    data: List[Dict[str, Any]],
    stop_pct: float,
    target_pct: float
) -> pd.DataFrame:
    """
    Calculate simulated stats grouped by model.
    """
    if not data:
        return pd.DataFrame()

    df = pd.DataFrame(data)

    if 'model' not in df.columns:
        return pd.DataFrame()

    df['model'] = df['model'].apply(_normalize_model)

    results = []
    for model in MODELS:
        model_data = [d for d in data if _normalize_model(d.get('model')) == model]
        if not model_data:
            continue

        stats = calculate_simulated_stats(model_data, stop_pct, target_pct)
        stats['model'] = model
        results.append(stats)

    return pd.DataFrame(results)


def generate_stop_target_grid(
    data: List[Dict[str, Any]],
    stop_range: List[float] = None,
    target_range: List[float] = None
) -> pd.DataFrame:
    """
    Generate a grid of results across stop/target combinations.

    Parameters:
    -----------
    data : List[Dict]
        Options MFE/MAE data
    stop_range : List[float]
        List of stop percentages to test
    target_range : List[float]
        List of target percentages to test

    Returns:
    --------
    pd.DataFrame with columns: stop_pct, target_pct, n, wins, losses, win_rate, expectancy, r_ratio
    """
    if stop_range is None:
        stop_range = DEFAULT_STOP_RANGE
    if target_range is None:
        target_range = DEFAULT_TARGET_RANGE

    results = []

    for stop_pct in stop_range:
        for target_pct in target_range:
            stats = calculate_simulated_stats(data, stop_pct, target_pct)
            stats['r_ratio'] = target_pct / stop_pct  # Risk:Reward ratio
            results.append(stats)

    return pd.DataFrame(results)


def find_optimal_parameters(
    grid_df: pd.DataFrame,
    metric: str = 'expectancy',
    min_trades: int = 50
) -> Dict[str, Any]:
    """
    Find optimal stop/target parameters from grid results.

    Parameters:
    -----------
    grid_df : pd.DataFrame
        Output from generate_stop_target_grid()
    metric : str
        Metric to optimize: 'expectancy', 'win_rate', or 'sharpe'
    min_trades : int
        Minimum trades required for consideration

    Returns:
    --------
    Dict with optimal parameters and statistics
    """
    if grid_df.empty:
        return {
            'stop_pct': 25,
            'target_pct': 50,
            'expectancy': 0,
            'win_rate': 0,
            'n': 0,
            'found': False
        }

    # Filter for minimum trades
    valid_df = grid_df[grid_df['n'] >= min_trades]

    if valid_df.empty:
        valid_df = grid_df  # Use all if none meet threshold

    # Find optimal by metric
    if metric == 'expectancy':
        best_idx = valid_df['expectancy'].idxmax()
    elif metric == 'win_rate':
        best_idx = valid_df['win_rate'].idxmax()
    else:
        # Sharpe-like: expectancy / std of R (not implemented, use expectancy)
        best_idx = valid_df['expectancy'].idxmax()

    best_row = valid_df.loc[best_idx]

    return {
        'stop_pct': best_row['stop_pct'],
        'target_pct': best_row['target_pct'],
        'expectancy': best_row['expectancy'],
        'win_rate': best_row['win_rate'],
        'n': best_row['n'],
        'r_ratio': best_row['r_ratio'],
        'found': True
    }


# =============================================================================
# STREAMLIT DISPLAY FUNCTIONS
# =============================================================================
def render_optimal_summary_cards(optimal: Dict[str, Any]) -> None:
    """Render summary cards for optimal parameters."""
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric(
            "Optimal Stop",
            f"{optimal.get('stop_pct', 0):.0f}%",
            help="Optimal stop loss percentage"
        )

    with col2:
        st.metric(
            "Optimal Target",
            f"{optimal.get('target_pct', 0):.0f}%",
            help="Optimal profit target percentage"
        )

    with col3:
        st.metric(
            "Win Rate",
            f"{optimal.get('win_rate', 0):.1f}%",
            help="Win rate at optimal parameters"
        )

    with col4:
        exp = optimal.get('expectancy', 0)
        st.metric(
            "Expectancy",
            f"{exp:+.2f}R",
            help="Expected R per trade at optimal parameters"
        )


def render_heatmap(grid_df: pd.DataFrame, metric: str = 'expectancy') -> None:
    """Render heatmap of stop/target grid."""
    if grid_df.empty:
        st.warning("No grid data available")
        return

    # Pivot for heatmap
    pivot = grid_df.pivot(index='stop_pct', columns='target_pct', values=metric)

    # Reverse rows so smaller stops at bottom
    pivot = pivot.iloc[::-1]

    # Create heatmap
    fig = go.Figure(data=go.Heatmap(
        z=pivot.values,
        x=pivot.columns,
        y=pivot.index,
        colorscale='RdYlGn' if metric in ['expectancy', 'win_rate'] else 'Viridis',
        text=[[f"{v:.2f}" for v in row] for row in pivot.values],
        texttemplate="%{text}",
        textfont={"size": 10},
        hovertemplate=(
            f"Stop: %{{y}}%<br>"
            f"Target: %{{x}}%<br>"
            f"{metric.title()}: %{{z:.2f}}<extra></extra>"
        )
    ))

    title_map = {
        'expectancy': 'Expectancy (R)',
        'win_rate': 'Win Rate (%)',
        'avg_r': 'Average R'
    }

    fig.update_layout(
        title=f"Stop/Target Grid - {title_map.get(metric, metric)}",
        xaxis_title="Target (%)",
        yaxis_title="Stop (%)",
        paper_bgcolor=CHART_COLORS['paper'],
        plot_bgcolor=CHART_COLORS['background'],
        font=dict(color=CHART_COLORS['text']),
        height=450
    )

    st.plotly_chart(fig, use_container_width=True)


def render_sensitivity_chart(grid_df: pd.DataFrame, fixed_stop: float = 25) -> None:
    """Render sensitivity chart showing expectancy vs target at fixed stop."""
    if grid_df.empty:
        return

    # Filter for fixed stop
    subset = grid_df[grid_df['stop_pct'] == fixed_stop].copy()

    if subset.empty:
        # Find closest stop
        available_stops = grid_df['stop_pct'].unique()
        fixed_stop = min(available_stops, key=lambda x: abs(x - 25))
        subset = grid_df[grid_df['stop_pct'] == fixed_stop].copy()

    subset = subset.sort_values('target_pct')

    fig = go.Figure()

    # Expectancy line
    fig.add_trace(go.Scatter(
        x=subset['target_pct'],
        y=subset['expectancy'],
        mode='lines+markers',
        name='Expectancy',
        line=dict(color=CHART_COLORS['win'], width=2),
        marker=dict(size=8)
    ))

    # Win rate on secondary y-axis
    fig.add_trace(go.Scatter(
        x=subset['target_pct'],
        y=subset['win_rate'],
        mode='lines+markers',
        name='Win Rate',
        line=dict(color=CHART_COLORS['optimal'], width=2, dash='dash'),
        marker=dict(size=8),
        yaxis='y2'
    ))

    fig.update_layout(
        title=f"Target Sensitivity at {fixed_stop:.0f}% Stop",
        xaxis_title="Target (%)",
        yaxis_title="Expectancy (R)",
        yaxis2=dict(
            title="Win Rate (%)",
            overlaying='y',
            side='right',
            showgrid=False
        ),
        paper_bgcolor=CHART_COLORS['paper'],
        plot_bgcolor=CHART_COLORS['background'],
        font=dict(color=CHART_COLORS['text']),
        height=400,
        legend=dict(orientation="h", yanchor="bottom", y=1.02)
    )

    st.plotly_chart(fig, use_container_width=True)


def render_simulated_outcomes_section(
    data: List[Dict[str, Any]],
    stop_range: List[float] = None,
    target_range: List[float] = None
) -> Dict[str, Any]:
    """
    Main entry point for CALC-O05 section.

    Parameters:
    -----------
    data : List[Dict]
        Options MFE/MAE data from op_mfe_mae_potential

    Returns:
    --------
    Dict with optimal parameters and grid results
    """
    st.subheader("Options Simulated Outcomes")
    st.markdown("*Find optimal stop/target combination for options*")

    if not data:
        st.warning("No options data available for simulation")
        return {}

    # User controls
    st.markdown("#### Simulation Parameters")

    col1, col2 = st.columns(2)

    with col1:
        default_stops = [10, 15, 20, 25, 30, 40, 50]
        stop_range = st.multiselect(
            "Stop Levels to Test (%)",
            options=[5, 10, 15, 20, 25, 30, 35, 40, 50, 60, 75],
            default=default_stops,
            help="Stop loss percentages to simulate"
        )

    with col2:
        default_targets = [25, 50, 75, 100, 150, 200]
        target_range = st.multiselect(
            "Target Levels to Test (%)",
            options=[10, 25, 50, 75, 100, 125, 150, 200, 250, 300],
            default=default_targets,
            help="Profit target percentages to simulate"
        )

    if not stop_range or not target_range:
        st.warning("Please select at least one stop and one target level")
        return {}

    # Run simulation
    with st.spinner("Running simulation..."):
        grid_df = generate_stop_target_grid(data, stop_range, target_range)
        optimal = find_optimal_parameters(grid_df)

    st.markdown("---")

    # Optimal parameters summary
    st.markdown("#### Optimal Parameters")
    render_optimal_summary_cards(optimal)

    st.markdown("---")

    # Heatmap
    st.markdown("#### Stop/Target Grid")

    metric = st.selectbox(
        "Heatmap Metric",
        options=['expectancy', 'win_rate'],
        format_func=lambda x: 'Expectancy (R)' if x == 'expectancy' else 'Win Rate (%)'
    )

    render_heatmap(grid_df, metric)

    st.markdown("---")

    # Sensitivity chart
    st.markdown("#### Sensitivity Analysis")

    fixed_stop = st.select_slider(
        "Fixed Stop for Sensitivity",
        options=sorted(stop_range),
        value=25 if 25 in stop_range else stop_range[len(stop_range)//2]
    )

    render_sensitivity_chart(grid_df, fixed_stop)

    st.markdown("---")

    # Full grid table
    with st.expander("View Full Grid Results"):
        display_df = grid_df.copy()
        display_df['win_rate'] = display_df['win_rate'].apply(lambda x: f"{x:.1f}%")
        display_df['expectancy'] = display_df['expectancy'].apply(lambda x: f"{x:+.3f}R")
        display_df['r_ratio'] = display_df['r_ratio'].apply(lambda x: f"{x:.1f}:1")
        st.dataframe(display_df, use_container_width=True, hide_index=True)

    return {
        'grid': grid_df,
        'optimal': optimal,
        'stop_range': stop_range,
        'target_range': target_range
    }


# =============================================================================
# EXAMPLE USAGE
# =============================================================================
if __name__ == "__main__":
    # Sample data
    sample_data = [
        {"mfe_pct": 45.0, "mae_pct": 12.0, "model": "EPCH02"},
        {"mfe_pct": 22.0, "mae_pct": 35.0, "model": "EPCH02"},
        {"mfe_pct": 80.0, "mae_pct": 8.0, "model": "EPCH04"},
        {"mfe_pct": 15.0, "mae_pct": 28.0, "model": "EPCH01"},
        {"mfe_pct": 55.0, "mae_pct": 18.0, "model": "EPCH03"},
    ]

    print("\nSimulated Stats at 25% Stop, 50% Target:")
    stats = calculate_simulated_stats(sample_data, 25, 50)
    print(f"  Trades: {stats['n']}")
    print(f"  Win Rate: {stats['win_rate']:.1f}%")
    print(f"  Expectancy: {stats['expectancy']:+.2f}R")

    print("\n\nGrid Search Results:")
    grid = generate_stop_target_grid(sample_data, [20, 25, 30], [50, 75, 100])
    print(grid.to_string(index=False))

    print("\n\nOptimal Parameters:")
    optimal = find_optimal_parameters(grid, min_trades=1)
    print(f"  Stop: {optimal['stop_pct']}%")
    print(f"  Target: {optimal['target_pct']}%")
    print(f"  Expectancy: {optimal['expectancy']:+.2f}R")
```

================================================================================
INTEGRATION WITH EXISTING TABS
================================================================================

The simulated outcomes section should be placed AFTER CALC-O03 (Sequence Analysis)
and BEFORE the Monte AI section.

This mirrors the Metrics Overview layout where CALC-004 comes after CALC-003.

================================================================================
OUTPUT FOR MONTE AI
================================================================================

The function returns a dict that can be used in the Monte AI prompt:

```python
simulated_results = render_simulated_outcomes_section(options_data)

# Use in Monte AI prompt:
optimal = simulated_results.get('optimal', {})
prompt_section = f"""
## Simulated Outcomes Analysis
- Optimal Stop: {optimal.get('stop_pct')}%
- Optimal Target: {optimal.get('target_pct')}%
- Win Rate at Optimal: {optimal.get('win_rate'):.1f}%
- Expectancy at Optimal: {optimal.get('expectancy'):+.2f}R
"""
```

================================================================================
QUESTIONS FOR REVIEW
================================================================================

1. DEFAULT RANGES:
   Currently testing stops: 10-50% and targets: 25-200%
   Are these ranges appropriate for your options trading?

2. OPTIMIZATION METRIC:
   Currently optimizing for expectancy.
   Should we offer win_rate optimization as an option?

3. MODEL BREAKDOWN:
   Should we show optimal parameters BY MODEL?
   E.g., EPCH02 might have different optimal than EPCH04

4. CONTRACT TYPE:
   Should CALLs and PUTs have separate optimization?
   They might behave differently.

================================================================================
