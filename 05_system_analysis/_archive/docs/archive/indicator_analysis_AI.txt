================================================================================
EPOCH TRADING SYSTEM - INDICATOR ANALYSIS APPLICATION
AI-READABLE DOCUMENTATION FOR MONTE AI INTEGRATION
XIII Trading LLC
Generated: 2026-01-08
================================================================================

PURPOSE:
This document provides a comprehensive technical reference for the Epoch Indicator
Analysis Streamlit application. It is designed for AI consumption (Monte AI) to
validate calculation logic, identify potential issues, and provide optimization
recommendations.

================================================================================
SECTION 1: APPLICATION ARCHITECTURE
================================================================================

1.1 TECHNOLOGY STACK
--------------------
- Framework: Streamlit (Python web framework)
- Database: PostgreSQL (Supabase-hosted)
- Visualization: Plotly (interactive charts)
- Statistics: SciPy, NumPy, Pandas
- Port: 8502 (streamlit run app.py --server.port 8502)

1.2 DATA LAYER
--------------
Primary Data Source: Supabase PostgreSQL
Caching: Streamlit @st.cache_data with TTL=300 seconds (5 minutes)

Core Tables:
- trades: Raw trade records
- mfe_mae_potential: Entry-to-15:30 price movements (POTENTIAL not REALIZED)
- op_mfe_mae_potential: Options entry-to-15:30 movements
- entry_indicators: Entry point indicator snapshots with outcomes
- m5_trade_bars_with_outcomes: 5-minute bar data with trade outcomes
- optimal_trade: Indicator values at ENTRY/MFE/MAE/EXIT events

1.3 APPLICATION STRUCTURE
-------------------------
Main Entry: app.py (1,264 lines)
Configuration: config.py (centralized settings)

Directory Structure:
/calculations/
    /model/ - CALC-001: Win rate by model
    /trade_management/ - CALC-002, 003, 004: MFE/MAE analysis
    /options/ - CALC-O01 through O04: Options analysis
    /indicator_analysis/ - CALC-005 through 008: Indicator correlation

/components/
    summary_cards.py - Metric display cards
    charts.py - Plotly chart rendering
    filters.py - Sidebar filter components

/analysis/
    trade_stats.py - Trade statistics calculations
    indicator_stats.py - Indicator analysis functions

/monte_ai/
    ui.py - Monte AI prompt interface
    prompts.py - Prompt generation functions


================================================================================
SECTION 2: TAB STRUCTURE AND NAVIGATION
================================================================================

The application has FOUR main tabs:

TAB 1: METRICS OVERVIEW
-----------------------
Purpose: Primary analysis sandbox for equity/share trades
Contains: Summary cards + CALC-001 through CALC-004 + Monte AI
Data Source: mfe_mae_potential table

TAB 2: OPTIONS ANALYSIS
-----------------------
Purpose: Options contract analysis
Contains: CALC-O01 through CALC-O04
Data Source: op_mfe_mae_potential table

TAB 3: INDICATOR ANALYSIS
-------------------------
Purpose: Entry indicator correlation with outcomes
Contains: CALC-005 through CALC-008 (4 sub-tabs)
Data Source: entry_indicators, m5_trade_bars_with_outcomes

TAB 4: ARCHIVED ANALYSIS
------------------------
Purpose: Legacy analysis preserved for reference
Contains: 6 sub-tabs (Overview, Continuation, Rejection, Indicators, Health, Data)
Data Source: trades, optimal_trade tables


================================================================================
SECTION 3: WIN CONDITION DEFINITIONS
================================================================================

CRITICAL: The application uses TWO different win conditions depending on context:

3.1 POTENTIAL WIN (Used in Metrics Overview Tab)
------------------------------------------------
Definition: MFE occurs before MAE within the trading day
Formula: mfe_potential_time < mae_potential_time
Applies to: Summary cards, CALC-001, CALC-002, CALC-003, CALC-005-008

Logic:
  IF mfe_potential_time < mae_potential_time:
      trade_outcome = WIN
  ELSE:
      trade_outcome = LOSS

Rationale: A trade is considered favorable if the price reaches the maximum
favorable excursion (MFE) before reaching the maximum adverse excursion (MAE).
This represents "could have been profitable if managed correctly."

3.2 OPTIONS WIN (Used in Options Analysis Tab)
----------------------------------------------
Definition: Option price higher at 15:30 than at entry
Formula: exit_pct > 0
Applies to: CALC-O01 through CALC-O04

Logic:
  IF exit_pct > 0:
      option_outcome = WIN
  ELSE:
      option_outcome = LOSS

exit_pct = (exit_price - entry_price) / entry_price * 100

3.3 ARCHIVED WIN (Legacy, used in Archived Tab)
-----------------------------------------------
Definition: is_winner flag from trades table or win=1 from optimal_trade
Applies to: Archived Analysis tab only


================================================================================
SECTION 4: CALCULATION SPECIFICATIONS
================================================================================

=== TAB 1: METRICS OVERVIEW ===

--------------------------------------------------------------------------------
SUMMARY CARDS (Top of Tab)
--------------------------------------------------------------------------------
Location: components/summary_cards.py
Data Source: mfe_mae_potential table via get_trade_statistics()

CARD 1: Total Trades
  Formula: COUNT(*)
  Display: Integer with comma separator

CARD 2: Win Rate
  Formula: (COUNT(WHERE mfe_potential_time < mae_potential_time) / COUNT(*)) * 100
  Display: XX.X%

CARD 3: Wins / Losses
  Formula:
    wins = COUNT(WHERE mfe_potential_time < mae_potential_time)
    losses = COUNT(*) - wins
  Display: "XXX / XXX"

CARD 4: Avg Points
  Formula:
    For each trade:
      IF mfe_potential_time < mae_potential_time:
        points = abs(mfe_potential_price - entry_price)
      ELSE:
        points = -abs(mae_potential_price - entry_price)
    avg_points = SUM(points) / COUNT(*)
  Display: +X.XX or -X.XX

CARD 5: Total Points
  Formula: SUM(all_trade_points)
  Display: +X.XX or -X.XX

--------------------------------------------------------------------------------
CALC-001: WIN RATE BY MODEL
--------------------------------------------------------------------------------
Location: calculations/model/win_rate_by_model.py
Data Source: mfe_mae_potential table

PURPOSE:
Calculate win/loss statistics for each entry model (EPCH01-04).

WIN CONDITION:
  is_winner = mfe_potential_time < mae_potential_time

AGGREGATION BY MODEL:
  FOR each model IN [EPCH01, EPCH02, EPCH03, EPCH04]:
      wins = COUNT(WHERE is_winner = TRUE AND model = current_model)
      losses = COUNT(WHERE is_winner = FALSE AND model = current_model)
      total = wins + losses
      win_rate = (wins / total) * 100
      avg_points = AVG(points) WHERE model = current_model

OUTPUT COLUMNS:
  - Model (EPCH01, EPCH02, EPCH03, EPCH04)
  - Wins (integer)
  - Losses (integer)
  - Win% (float, 1 decimal)
  - Avg Points (float, 2 decimals)

VISUALIZATIONS:
  1. Summary Table: Transposed (models as columns, metrics as rows)
  2. Grouped Bar Chart: Win bars (green #26a69a) and Loss bars (red #ef5350)

--------------------------------------------------------------------------------
CALC-002: MFE/MAE DISTRIBUTION ANALYSIS (Trade Management Efficiency)
--------------------------------------------------------------------------------
Location: calculations/trade_management/mfe_mae_stats.py
Data Source: mfe_mae_potential table

PURPOSE:
Analyze the distribution of MFE% and MAE% to understand trade management potential.

MFE/MAE PERCENTAGE CALCULATIONS:
  FOR LONG trades:
      mfe_pct = (mfe_potential_price - entry_price) / entry_price * 100
      mae_pct = (entry_price - mae_potential_price) / entry_price * 100

  FOR SHORT trades:
      mfe_pct = (entry_price - mfe_potential_price) / entry_price * 100
      mae_pct = (mae_potential_price - entry_price) / entry_price * 100

  NOTE: Both MFE% and MAE% are expressed as POSITIVE values
        (how much price moved favorably/adversely as percentage)

SUMMARY STATISTICS:
  - Median MFE%: 50th percentile of all MFE percentages
  - Median MAE%: 50th percentile of all MAE percentages
  - Overall Ratio: Median MFE% / Median MAE%
  - Percentiles: 25th, 50th, 75th for distribution analysis

VISUALIZATIONS:
  1. Summary Cards: MFE stats, MAE stats, Overall ratio
  2. MFE Histogram: Distribution of favorable movements (25 bins)
  3. MAE Histogram: Distribution of adverse movements (25 bins)
  4. MFE vs MAE Scatter Plot:
     - X-axis: MAE%
     - Y-axis: MFE%
     - Diagonal line: Above = favorable (MFE > MAE), Below = unfavorable
     - Color by direction (LONG/SHORT)
  5. Model-Direction Breakdown Table: Stats grouped by model and direction

--------------------------------------------------------------------------------
CALC-003: MFE/MAE SEQUENCE ANALYSIS (Monte Carlo Baseline)
--------------------------------------------------------------------------------
Location: calculations/trade_management/mfe_mae_sequence.py
Data Source: mfe_mae_potential table

PURPOSE:
Establish probability of MFE occurring before MAE for Monte Carlo simulations.
Answers: "What's the baseline probability that price moves favorably first?"

TIME-BASED CALCULATIONS:
  entry_time: Time trade was entered
  mfe_potential_time: Time maximum favorable excursion occurred
  mae_potential_time: Time maximum adverse excursion occurred

  time_to_mfe = mfe_potential_time - entry_time (in minutes)
  time_to_mae = mae_potential_time - entry_time (in minutes)
  time_delta = time_to_mae - time_to_mfe

PROBABILITY CALCULATION:
  P(MFE First) = COUNT(time_to_mfe < time_to_mae) / COUNT(*) * 100

CONFIDENCE RATING:
  IF total_trades >= 100: confidence = "HIGH"
  ELIF total_trades >= 50: confidence = "MEDIUM"
  ELIF total_trades >= 30: confidence = "LOW"
  ELSE: confidence = "INSUFFICIENT"

MONTE CARLO PARAMETERS OUTPUT:
  For each model-direction combination:
    - p_mfe_first: Probability MFE occurs before MAE (0 to 1)
    - avg_time_to_mfe: Average minutes from entry to MFE
    - avg_time_to_mae: Average minutes from entry to MAE
    - std_time_to_mfe: Standard deviation of time to MFE
    - std_time_to_mae: Standard deviation of time to MAE
    - sample_size: Number of trades in sample
    - confidence: Confidence rating string

VISUALIZATIONS:
  1. Summary Table: P(MFE First) by model-direction with confidence
  2. Time to MFE histogram
  3. Time to MAE histogram
  4. Time delta distribution

--------------------------------------------------------------------------------
CALC-004: SIMULATED OUTCOME ANALYSIS (Stop/Target Simulation)
--------------------------------------------------------------------------------
Location: calculations/trade_management/simulated_outcomes.py
Data Source: mfe_mae_potential table + m1_bars (1-minute OHLC)

PURPOSE:
Simulate trade outcomes at configurable stop and target levels.
Independent validation of win rates regardless of actual exit data quality.

SIMULATION LOGIC:
  INPUT: stop_pct (e.g., 0.5%), target_pct (e.g., 1.0%)

  FOR each trade:
      entry_price = trade.entry_price

      IF direction == "LONG":
          stop_price = entry_price * (1 - stop_pct/100)
          target_price = entry_price * (1 + target_pct/100)
      ELSE (SHORT):
          stop_price = entry_price * (1 + stop_pct/100)
          target_price = entry_price * (1 - target_pct/100)

      # Walk M1 bars chronologically from entry_time to 15:30 ET
      FOR each bar in m1_bars_from_entry_to_1530:
          IF direction == "LONG":
              IF bar.low <= stop_price:
                  outcome = "LOSS" (stop hit first)
                  BREAK
              IF bar.high >= target_price:
                  outcome = "WIN" (target hit first)
                  BREAK
          ELSE (SHORT):
              IF bar.high >= stop_price:
                  outcome = "LOSS" (stop hit first)
                  BREAK
              IF bar.low <= target_price:
                  outcome = "WIN" (target hit first)
                  BREAK

      IF neither stop nor target hit by 15:30:
          outcome = "EOD_EXIT"

GRID ANALYSIS:
  Generate stop/target combinations:
    stops: [0.25%, 0.50%, 0.75%, 1.00%, 1.50%, 2.00%]
    targets: [0.50%, 1.00%, 1.50%, 2.00%, 3.00%, 4.00%]

  For each combination, calculate:
    - Simulated win rate
    - Win count, loss count, EOD count
    - Expectancy (avg outcome)

OPTIMAL PARAMETERS:
  Find stop/target combination that maximizes:
    expectancy = (win_rate * avg_win) - (loss_rate * avg_loss)

OUTPUT:
  - Grid table with win rates at each stop/target combination
  - Optimal parameters recommendation
  - Heatmap visualization


=== TAB 2: OPTIONS ANALYSIS ===

--------------------------------------------------------------------------------
CALC-O01: OPTIONS WIN RATE BY MODEL
--------------------------------------------------------------------------------
Location: calculations/options/op_win_rate_by_model.py
Data Source: op_mfe_mae_potential table

PURPOSE:
Calculate win/loss statistics for options trades by model.

WIN CONDITION:
  is_winner = (exit_pct > 0)

  WHERE exit_pct = (exit_price - entry_price) / entry_price * 100
  (Option price at 15:30 vs entry price)

AGGREGATION:
  Same structure as CALC-001 but using exit_pct > 0 as win condition

OUTPUT COLUMNS:
  - Model (EPCH01, EPCH02, EPCH03, EPCH04)
  - Wins (integer)
  - Losses (integer)
  - Win% (float)
  - Avg Exit% (float) - average percentage change at exit

ADDITIONAL BREAKDOWN:
  By Model AND Contract Type (CALL/PUT)

--------------------------------------------------------------------------------
CALC-O02: OPTIONS MFE/MAE DISTRIBUTION
--------------------------------------------------------------------------------
Location: calculations/options/op_mfe_mae_stats.py
Data Source: op_mfe_mae_potential table

PURPOSE:
Analyze options price movements from entry to 15:30 ET.

CALCULATIONS:
  mfe_pct = (mfe_potential_price - entry_price) / entry_price * 100
  mae_pct = (entry_price - mae_potential_price) / entry_price * 100

  NOTE: Options always have same direction calculation since we're measuring
        price movement of the option contract itself.

VISUALIZATIONS:
  Same structure as CALC-002:
  - Summary cards
  - MFE/MAE histograms
  - Scatter plot
  - Model + Contract Type breakdown

--------------------------------------------------------------------------------
CALC-O03: OPTIONS MFE/MAE SEQUENCE ANALYSIS
--------------------------------------------------------------------------------
Location: calculations/options/op_mfe_mae_sequence.py
Data Source: op_mfe_mae_potential table

PURPOSE:
Establish P(MFE First) probability for options contracts.

CALCULATIONS:
  Same methodology as CALC-003:
  - P(MFE First) = proportion where MFE time < MAE time
  - Time to MFE/MAE distributions
  - Monte Carlo parameters by model and contract type

--------------------------------------------------------------------------------
CALC-O04: OPTIONS VS UNDERLYING COMPARISON
--------------------------------------------------------------------------------
Location: calculations/options/op_vs_underlying.py
Data Source: op_mfe_mae_potential table (contains underlying data)

PURPOSE:
Compare options leverage vs underlying share movements.

CALCULATIONS:
  leverage_ratio = options_move_pct / underlying_move_pct

  For each trade:
    - Options MFE% vs Underlying MFE%
    - Options MAE% vs Underlying MAE%
    - Leverage amplification factor

ANALYSIS:
  - Do options amplify MFE more than MAE?
  - Which model-direction combinations have best leverage characteristics?


=== TAB 3: INDICATOR ANALYSIS ===

--------------------------------------------------------------------------------
CALC-005: HEALTH SCORE CORRELATION ANALYSIS
--------------------------------------------------------------------------------
Location: calculations/indicator_analysis/health_correlation.py
Data Source: entry_indicators table

PURPOSE:
Validate whether Health Score (0-10) at entry predicts trade outcomes.
Core Question: "If DOW AI sees Health Score 8+ at entry, should it
recommend the trade more confidently?"

HEALTH SCORE BUCKETS:
  CRITICAL: 0-3
  WEAK: 4-5
  MODERATE: 6-7
  STRONG: 8-10

WIN CONDITION:
  is_winner from entry_indicators table (populated via join with mfe_mae_potential)
  Win = mfe_potential_time < mae_potential_time

CORRELATION CALCULATION:
  Uses Pearson correlation coefficient (scipy.stats.pearsonr)

  correlation, p_value = pearsonr(health_score, is_winner)

  Interpretation:
    r > 0.1 with p < 0.05: Positive correlation, Health Score has predictive value
    r < 0.1: Weak/no correlation
    p >= 0.05: Not statistically significant

WILSON CONFIDENCE INTERVALS:
  More accurate than normal approximation for small samples or extreme proportions.

  Formula:
    z = norm.ppf(1 - (1 - confidence) / 2)  # z-score for confidence level
    p = wins / total  # proportion

    denominator = 1 + z^2 / total
    center = (p + z^2 / (2 * total)) / denominator
    margin = z * sqrt((p * (1-p) + z^2 / (4*total)) / total) / denominator

    ci_lower = max(0, center - margin) * 100
    ci_upper = min(1, center + margin) * 100

WIN RATE BY SCORE (0-10):
  FOR each score in range(0, 11):
      score_trades = trades WHERE health_score == score
      wins = COUNT(is_winner == TRUE)
      losses = COUNT(is_winner == FALSE)
      win_rate = (wins / total) * 100
      ci_lower, ci_upper = wilson_confidence_interval(wins, total)

WIN RATE BY BUCKET:
  FOR each bucket in [CRITICAL, WEAK, MODERATE, STRONG]:
      bucket_trades = trades WHERE health_score BETWEEN bucket.min AND bucket.max
      wins = COUNT(is_winner == TRUE)
      win_rate = (wins / total) * 100
      lift = win_rate - overall_win_rate
      ci_lower, ci_upper = wilson_confidence_interval(wins, total)

MODEL-DIRECTION BREAKDOWN:
  Nested grouping by model, direction, then health bucket
  Calculate win rate and lift for each combination

THRESHOLD ANALYSIS:
  FOR each threshold in range(0, 11):
      above_threshold = trades WHERE health_score >= threshold
      trades_above = COUNT(above_threshold)
      wins_above = COUNT(is_winner == TRUE) in above_threshold
      win_rate_above = (wins_above / trades_above) * 100
      lift = win_rate_above - baseline_win_rate
      pct_excluded = ((total - trades_above) / total) * 100

  OPTIMAL THRESHOLD:
      Find threshold that maximizes lift while:
        - Maintaining statistical validity (>= 30 trades)
        - Not excluding more than 50% of trades

VISUALIZATIONS:
  1. Summary Cards: Total trades, Baseline win rate, Correlation (r), Optimal threshold
  2. Win Rate by Score Curve: Line chart with confidence bands
  3. Win Rate by Bucket: Bar chart with baseline reference line
  4. Model-Direction Heatmap: Win rate by model-direction vs health bucket
  5. Threshold Analysis: Dual-axis chart (win rate vs % excluded)
  6. Lift Table: Detailed bucket statistics

KEY FINDINGS GENERATION:
  Auto-generated findings based on:
  - Correlation coefficient interpretation
  - STRONG vs CRITICAL spread
  - Optimal threshold lift value

--------------------------------------------------------------------------------
CALC-006: FACTOR IMPORTANCE ANALYSIS
--------------------------------------------------------------------------------
Location: calculations/indicator_analysis/factor_importance.py
Data Source: entry_indicators table

PURPOSE:
Determine which of the 10 Health Score factors have independent predictive power.
Core Question: "Of the 10 Health Score factors, which ones actually matter?"

THE 10 HEALTH SCORE FACTORS:
  Structure Group:
    - h4_structure_healthy: H4 timeframe trend alignment
    - h1_structure_healthy: H1 timeframe trend alignment
    - m15_structure_healthy: M15 timeframe trend alignment
    - m5_structure_healthy: M5 timeframe trend alignment

  Volume Group:
    - vol_roc_healthy: Volume above 20% of baseline
    - vol_delta_healthy: Delta aligned with trade direction
    - cvd_slope_healthy: Cumulative volume delta trend

  Price Group:
    - sma_alignment_healthy: SMA9 vs SMA21 position
    - sma_momentum_healthy: SMA spread widening
    - vwap_healthy: Price vs VWAP alignment

SINGLE FACTOR ANALYSIS:
  FOR each factor in factors:
      healthy_trades = trades WHERE factor == TRUE
      unhealthy_trades = trades WHERE factor == FALSE

      healthy_wins = COUNT(is_winner == TRUE in healthy_trades)
      unhealthy_wins = COUNT(is_winner == TRUE in unhealthy_trades)

      healthy_win_rate = (healthy_wins / healthy_total) * 100
      unhealthy_win_rate = (unhealthy_wins / unhealthy_total) * 100

      lift = healthy_win_rate - unhealthy_win_rate

      # Pearson correlation
      correlation = pearsonr(factor_as_int, is_winner_as_int)

      # Prevalence (how often factor is healthy)
      prevalence = (healthy_total / total_trades) * 100

INFORMATION GAIN (Entropy Reduction):
  Measures how much a factor reduces uncertainty about outcome.

  entropy(p) = -p * log2(p) - (1-p) * log2(1-p)  where p = win_rate

  H_overall = entropy(total_wins / total_trades)
  H_healthy = entropy(healthy_wins / healthy_total)
  H_unhealthy = entropy(unhealthy_wins / unhealthy_total)

  H_after = (healthy_total/total) * H_healthy + (unhealthy_total/total) * H_unhealthy

  information_gain = H_overall - H_after  (0 to 1, higher is better)

FACTOR CORRELATION MATRIX:
  Calculate pairwise Pearson correlation between all factors
  Identifies multicollinearity and redundant factors

GROUP SUMMARY:
  FOR each group in [structure, volume, price]:
      group_factors = factors in group
      avg_lift = MEAN(lift for factors in group)
      max_lift = MAX(lift for factors in group)
      best_factor = factor with max lift

TOP/DEAD FACTOR IDENTIFICATION:
  top_factors = factors WHERE lift > 5pp AND statistically significant
  dead_factors = factors WHERE |lift| < 2pp AND statistically significant

VISUALIZATIONS:
  1. Summary Cards: Total trades, Baseline, Factors analyzed, Top factor
  2. Factor Importance Ranking: Horizontal bar chart sorted by lift
  3. Healthy vs Unhealthy Comparison: Grouped bar chart
  4. Factor Correlation Heatmap: Identifies redundant factors
  5. Group Performance: Average lift by factor group
  6. Detailed Table: All factor statistics

DOW AI RECOMMENDATIONS:
  - Weight 2x: Top 3 factors by lift
  - Consider Removing: Dead factors with minimal predictive value

--------------------------------------------------------------------------------
CALC-007: INDICATOR PROGRESSION ANALYSIS
--------------------------------------------------------------------------------
Location: calculations/indicator_analysis/indicator_progression.py
Data Source: m5_trade_bars_with_outcomes table

PURPOSE:
Analyze how indicators change from ENTRY to MFE/MAE.
Identify early warning signals for failing trades.
Core Question: "What indicator changes signal that a trade is working vs failing?"

TRACKED INDICATORS:
  - health_score (0-10)
  - structure_score (0-4)
  - volume_score (0-3)
  - price_score (0-3)
  - cvd_slope
  - vol_delta
  - vol_roc
  - sma_spread
  - sma_momentum_ratio

EVENT TYPES IN DATA:
  - ENTRY: First bar of trade
  - MFE: Bar where maximum favorable excursion occurred
  - MAE: Bar where maximum adverse excursion occurred
  - MFE_MAE: When MFE and MAE occur on same bar

EVENT SNAPSHOT CALCULATION:
  FOR each event_type, outcome:
      subset = bars WHERE event_type matches AND is_winner matches

      avg_health_score = MEAN(health_score)
      std_health_score = STD(health_score)
      avg_structure_score = MEAN(structure_score)
      avg_volume_score = MEAN(volume_score)
      avg_price_score = MEAN(price_score)
      avg_bars_from_entry = MEAN(bars_from_entry)
      trade_count = COUNT(DISTINCT trade_id)

PROGRESSION PATH CALCULATION:
  FOR winners:
      entry_snapshot = snapshot at ENTRY for winners
      peak_snapshot = snapshot at MFE for winners

      health_delta = peak_health - entry_health
      structure_delta = peak_structure - entry_structure
      ...
      avg_bars_to_peak = avg bars_from_entry at MFE

  FOR losers:
      entry_snapshot = snapshot at ENTRY for losers
      peak_snapshot = snapshot at MAE for losers

      health_delta = peak_health - entry_health
      ...
      avg_bars_to_peak = avg bars_from_entry at MAE

BAR-BY-BAR PROGRESSION:
  FOR bars_from_entry in range(0, 30):
      FOR is_winner in [TRUE, FALSE]:
          subset = bars WHERE bars_from_entry matches AND is_winner matches
          IF COUNT(subset) >= 5:
              Calculate avg_health_score, std_health_score, etc.

EARLY WARNING SIGNAL DETECTION:
  FOR each indicator in [health_score, cvd_slope, structure_score, volume_score]:
      FOR each window in [3, 5, 10, 15]:  # bars from entry
          # Get entry values
          entry_vals = value at bars_from_entry == 0, grouped by trade_id

          # Get values at N bars from entry
          window_vals = value at bars_from_entry == window, grouped by trade_id

          # Calculate change
          changes = window_vals - entry_vals

          # Get outcomes
          outcomes = is_winner for each trade

          # Test thresholds
          FOR each threshold in indicator-specific thresholds:
              loser_hits = COUNT(changes <= threshold in losers) / COUNT(losers) * 100
              winner_hits = COUNT(changes <= threshold in winners) / COUNT(winners) * 100

              lift = loser_hits - winner_hits
              predictive_power = lift / loser_hits

              IF lift > 5:  # Only significant signals
                  Record EarlyWarningSignal

FACTOR DEGRADATION ANALYSIS (Losers Only):
  FOR each health factor:
      # Get state at entry
      entry_healthy = factor value at ENTRY for losers

      # Get state at MAE
      mae_healthy = factor value at MAE for losers

      # Get state at bar 5 (early check)
      bar5_healthy = factor value at bars_from_entry==5 for losers

      healthy_at_entry_pct = MEAN(entry_healthy) * 100
      healthy_at_mae_pct = MEAN(mae_healthy) * 100
      degradation_rate = healthy_at_entry_pct - healthy_at_mae_pct

      # Flip rate: was healthy at entry, unhealthy at MAE
      flip_rate = COUNT(entry_healthy==TRUE AND mae_healthy==FALSE) / total * 100

      # Early flip: flipped by bar 5
      early_flip_rate = COUNT(entry_healthy==TRUE AND bar5_healthy==FALSE) / total * 100

VISUALIZATIONS:
  1. Summary Cards: Total trades, Winners, Losers, Best warning signal
  2. Health Score Progression: Line chart ENTRY -> MFE (winners) vs ENTRY -> MAE (losers)
  3. Score Components: Stacked bar chart of structure/volume/price components
  4. Bar-by-Bar Chart: Line chart with confidence bands
  5. Indicator Deltas: Grouped bar comparing winner vs loser deltas
  6. Early Warning Table: Top 10 signals by lift
  7. Factor Degradation Table: How factors degrade for losers

KEY FINDINGS:
  - Winners start with higher/lower health score than losers
  - Divergent paths (winners improve, losers degrade)
  - Timing (bars to MFE vs MAE)
  - Best early warning signal

DOW AI RECOMMENDATIONS:
  - Exit Signal: If indicator drops X within Y bars
  - Stay in Winners: Health score improving = trade working
  - Cut Losers Early: Rapid health degradation signals failure

--------------------------------------------------------------------------------
CALC-008: REJECTION DYNAMICS ANALYSIS
--------------------------------------------------------------------------------
Location: calculations/indicator_analysis/rejection_dynamics.py
Data Source: entry_indicators + mfe_mae_potential tables

PURPOSE:
Determine if rejection trades (EPCH02/04) require different indicators than
continuation trades (EPCH01/03).

MODEL TYPE CLASSIFICATION:
  continuation: [EPCH01, EPCH03] - through the zone
  rejection: [EPCH02, EPCH04] - from the zone (reversal)

--- CALC-008A: TIME-TO-MFE ANALYSIS ---

PURPOSE: Do rejection trades reach MFE faster?

CALCULATION:
  FOR each model_type in [continuation, rejection]:
      type_trades = trades WHERE model in model_type_list

      FOR each trade:
          entry_time = trade.entry_time (converted to minutes from midnight)
          mfe_time = trade.mfe_potential_time (converted to minutes)
          minutes_to_mfe = mfe_time - entry_time

      median_minutes = MEDIAN(minutes_to_mfe)
      mean_minutes = MEAN(minutes_to_mfe)
      pct_within_5min = COUNT(minutes_to_mfe <= 5) / total * 100
      pct_within_15min = COUNT(minutes_to_mfe <= 15) / total * 100
      pct_within_30min = COUNT(minutes_to_mfe <= 30) / total * 100

      # Distribution buckets
      buckets = [0-5, 5-10, 10-15, 15-20, 20-30, 30-45, 45-60, 60-120, 120+]

VISUALIZATION: Side-by-side histograms comparing distributions

--- CALC-008B: HEALTH SCORE INVERSION TEST ---

PURPOSE: Is Health Score negatively correlated for rejection trades?

CALCULATION:
  FOR each model_type:
      type_trades = entry_indicators WHERE model in model_type_list

      correlation, p_value = pearsonr(health_score, is_winner)

      strong_trades = trades WHERE health_score BETWEEN 8 AND 10
      critical_trades = trades WHERE health_score BETWEEN 0 AND 3

      strong_win_rate = (strong_wins / strong_total) * 100
      critical_win_rate = (critical_wins / critical_total) * 100

      is_inverted = (critical_win_rate > strong_win_rate)
      inversion_magnitude = critical_win_rate - strong_win_rate

VISUALIZATION:
  - Correlation and win rate metrics for each model type
  - Heatmap of win rate by model and health bucket

--- CALC-008C: FACTOR INVERSION ANALYSIS ---

PURPOSE: Which factors have inverted meaning for rejection trades?

CALCULATION:
  FOR each factor:
      # Continuation lift
      cont_trades = entry_indicators WHERE model in continuation
      cont_healthy_wr = win_rate WHERE factor == TRUE
      cont_unhealthy_wr = win_rate WHERE factor == FALSE
      cont_lift = cont_healthy_wr - cont_unhealthy_wr

      # Rejection lift
      rej_trades = entry_indicators WHERE model in rejection
      rej_healthy_wr = win_rate WHERE factor == TRUE
      rej_unhealthy_wr = win_rate WHERE factor == FALSE
      rej_lift = rej_healthy_wr - rej_unhealthy_wr

      # Is inverted if signs differ
      is_inverted = (cont_lift > 0 AND rej_lift < 0) OR (cont_lift < 0 AND rej_lift > 0)

      # Inversion strength
      diff = abs(cont_lift - rej_lift)
      IF diff > 15: strength = "STRONG"
      ELIF diff > 8: strength = "MODERATE"
      ELIF diff > 3: strength = "WEAK"
      ELSE: strength = "NONE", is_inverted = FALSE

VISUALIZATION: Grouped bar chart comparing continuation vs rejection lift

--- CALC-008D: EXHAUSTION INDICATOR DISCOVERY ---

PURPOSE: Do extreme indicator values predict rejection success?

CALCULATION:
  FOR each indicator in [cvd_slope, vol_delta, vol_roc, sma_spread]:
      rej_trades = entry_indicators WHERE model in rejection

      # Create quintiles (5 equal groups)
      quintiles = pd.qcut(indicator_values, q=5, labels=[1,2,3,4,5])

      median_win_rate = overall win rate for rejection

      FOR each quintile in [1, 2, 3, 4, 5]:
          q_trades = trades in quintile
          q_win_rate = win rate for q_trades
          lift_vs_median = q_win_rate - median_win_rate

          is_extreme_better = (quintile in [1, 5]) AND (lift > 5)

VISUALIZATION: Table showing quintile win rates by indicator

SUMMARY VERDICT:
  rejection_requires_different_scoring = TRUE IF:
      - rejection Health Score is inverted, OR
      - 2+ factors show inversion, OR
      - rejection reaches MFE 10%+ faster than continuation


=== TAB 4: ARCHIVED ANALYSIS ===

--------------------------------------------------------------------------------
ARCHIVED: OVERVIEW
--------------------------------------------------------------------------------
Uses legacy trades and optimal_trade tables with original win condition.
Shows model comparison, continuation vs rejection breakdown.

--------------------------------------------------------------------------------
ARCHIVED: CONTINUATION
--------------------------------------------------------------------------------
EPCH1 and EPCH3 trades only.
Direction stats, exit reason stats, indicator comparisons.

--------------------------------------------------------------------------------
ARCHIVED: REJECTION
--------------------------------------------------------------------------------
EPCH2 and EPCH4 trades only.
Same structure as continuation.

--------------------------------------------------------------------------------
ARCHIVED: INDICATORS
--------------------------------------------------------------------------------
Deep dive into individual indicators.
Distribution by outcome, value by event type, continuation vs rejection.

--------------------------------------------------------------------------------
ARCHIVED: HEALTH
--------------------------------------------------------------------------------
Health score analysis using optimal_trade table.
Heatmap, distribution, threshold analysis.

--------------------------------------------------------------------------------
ARCHIVED: DATA
--------------------------------------------------------------------------------
Raw data explorer with CSV export.


================================================================================
SECTION 5: DATA RELATIONSHIPS AND JOINS
================================================================================

5.1 ENTRY INDICATORS POPULATION
-------------------------------
The entry_indicators table is populated by joining:
  - trades table (for trade_id, model, direction, ticker)
  - mfe_mae_potential table (for is_winner calculation: mfe_time < mae_time)
  - Indicator calculations at entry time

5.2 MFE/MAE POTENTIAL VS OPTIMAL TRADE
--------------------------------------
CRITICAL DISTINCTION:
  - mfe_mae_potential: POTENTIAL MFE/MAE (entry to 15:30 ET)
    "What was the maximum move available if you held until market close?"

  - optimal_trade: REALIZED MFE/MAE (entry to exit)
    "What was the maximum move during the actual trade duration?"

The Metrics Overview tab uses POTENTIAL (mfe_mae_potential).
The Archived tab uses REALIZED (optimal_trade).


================================================================================
SECTION 6: CONFIGURATION PARAMETERS
================================================================================

6.1 HEALTH SCORE BUCKETS
------------------------
CRITICAL: (0, 3)
WEAK: (4, 5)
MODERATE: (6, 7)
STRONG: (8, 10)

6.2 MINIMUM SAMPLE SIZE
------------------------
min_trades_for_analysis = 30
(Used for statistical validity checks)

6.3 CONFIDENCE INTERVAL
-----------------------
confidence_interval = 0.95 (95% Wilson CI)

6.4 TIME-TO-MFE BUCKETS
-----------------------
FAST: (0, 5) minutes
QUICK: (5, 15) minutes
NORMAL: (15, 30) minutes
SLOW: (30, 999) minutes

6.5 CHART COLORS
----------------
win_color: #26a69a (teal green)
loss_color: #ef5350 (red)
continuation_color: #2196F3 (blue)
rejection_color: #FF9800 (orange)
background_color: #1a1a2e (dark blue)
paper_color: #16213e (slightly lighter blue)
text_color: #e0e0e0 (light gray)


================================================================================
SECTION 7: VALIDATION QUESTIONS FOR MONTE AI
================================================================================

When analyzing this system, Monte AI should consider:

1. WIN CONDITION CONSISTENCY
   - Is the MFE < MAE win condition appropriate for all contexts?
   - Should options use same win condition or exit_pct > 0?

2. STATISTICAL VALIDITY
   - Are sample sizes sufficient for each analysis?
   - Are confidence intervals properly calculated?
   - Is Pearson correlation appropriate for binary outcomes?

3. CALCULATION ACCURACY
   - Are MFE/MAE percentages calculated correctly for LONG vs SHORT?
   - Are time conversions handled correctly?
   - Is information gain calculated correctly?

4. EARLY WARNING SIGNALS
   - Are the threshold values appropriate?
   - Is the lift calculation meaningful?
   - What is the false positive rate?

5. FACTOR IMPORTANCE
   - Are factors truly independent or highly correlated?
   - Should factor weights be adjusted based on lift?
   - Are dead factors actually dead or just need context?

6. REJECTION VS CONTINUATION
   - Is there statistical evidence for different scoring?
   - Which factors should be inverted for rejection?
   - Should a separate "Exhaustion Score" be built?


================================================================================
END OF AI-READABLE DOCUMENTATION
================================================================================
