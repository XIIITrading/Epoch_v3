================================================================================
EPOCH TRADING SYSTEM v2.0 - INDICATOR EDGE TESTING APPLICATION
System Specifications
XIII Trading LLC
================================================================================

1. IMPLEMENTATION OVERVIEW
================================================================================

The Indicator Edge Testing module is a PyQt6 desktop application that performs
rigorous statistical analysis of seven trading indicators against historical
trade outcomes to identify actionable edges for the Epoch zone-based trading
system. For each indicator, the system fetches completed trade records from
the Supabase trades table joined with M1-timeframe indicator snapshots from
the m1_indicator_bars table and multi-timeframe structure snapshots from the
entry_indicators table -- using the PRIOR completed M1 bar relative to each
trade's S15 entry time to avoid look-ahead bias. Two statistical tests drive
edge validation: the Chi-square test of independence for categorical
groupings (e.g., ALIGNED vs MISALIGNED, ABSORPTION vs NORMAL) and the
Spearman rank correlation for ordinal quintile distributions. An edge is
confirmed only when three conditions are simultaneously met: statistical
significance (p-value < 0.05), practical significance (effect size > 3.0
percentage points), and sufficient sample size (minimum 30 trades per group
for MEDIUM confidence, 100+ for HIGH). Each indicator is tested across nine
segments -- ALL trades, LONG, SHORT, CONTINUATION (EPCH1+EPCH3), REJECTION
(EPCH2+EPCH4), and the four individual entry models EPCH1-4 -- producing a
comprehensive matrix of up to 75+ individual statistical tests per run.
Results are displayed in a color-coded terminal GUI, tracked via progress bar,
and optionally exported to timestamped Markdown reports in the results/
directory. The module consumes trade data produced by 03_backtest and outcome
classifications from the stop_analysis table, feeding validated edge findings
into the 02_dow_ai trading assistant context files, thereby closing the
Epoch system's indicator refinement feedback loop.


2. HIGH-LEVEL TECHNICAL SPECIFICATIONS
================================================================================

2.1 APPLICATION FRAMEWORK
--------------------------------------------------------------------------------
- Runtime:          Python 3.12+
- UI Framework:     PyQt6 desktop application
- Window Size:      Minimum 900 x 700, default 1000 x 800
- Theme:            Dark mode (custom stylesheet, #1e1e1e background)
- Version:          Indicator Edge Testing v1.0
- Execution:        QProcess subprocess for CLI script isolation

2.2 DATA SOURCES
--------------------------------------------------------------------------------
- Trade Data:       Supabase PostgreSQL via psycopg2 + SSL
                    - Table: trades (trade records with entry times)
                    - Table: stop_analysis (WIN/LOSS outcomes by stop type)
- Indicator Data:   Supabase PostgreSQL via psycopg2 + SSL
                    - Table: m1_indicator_bars (M1 bar snapshots with indicators)
                    - Table: entry_indicators (multi-timeframe structure snapshots)
- Connection:       Direct psycopg2 with sslmode=require
- Query Pattern:    Single complex SQL join with parameterized filters

2.3 LOOK-AHEAD BIAS PREVENTION
--------------------------------------------------------------------------------

  The system prevents look-ahead bias through prior-bar alignment:

  Problem:
  - Trade entries occur on S15 (15-second) bars
  - M1 indicator bars represent 1-minute completed candles
  - Using the current M1 bar would include future data after entry

  Solution:
  - Entry at S15 timestamp -> use PRIOR completed M1 bar
  - Example: Entry at 09:35:15 -> use M1 bar at 09:34:00
  - SQL implementation:
    (date_trunc('minute', entry_time) - INTERVAL '1 minute')::time

  This ensures all indicator values were fully known before the trade entry.

2.4 DATA JOIN ARCHITECTURE
--------------------------------------------------------------------------------

  The master query constructs a four-table join:

  CTE: trade_with_prior_bar
  - Source: trades table
  - Calculates prior_bar_time for each trade entry
  - Filters: entry_time IS NOT NULL

  Main JOIN:
  1. trade_with_prior_bar (CTE)
     LEFT JOIN m1_indicator_bars ON (ticker, bar_date, bar_time=prior_bar_time)
     LEFT JOIN entry_indicators ON (trade_id)
     INNER JOIN stop_analysis ON (trade_id, stop_type)

  Filter: stop_analysis.stop_price IS NOT NULL

  Optional Filters (parameterized):
  - model (ANY array match)
  - direction (ANY array match)
  - date_from (>= date)
  - date_to (<= date)

  Columns Retrieved:
  - Trade: trade_id, date, ticker, model, direction, entry_price, entry_time
  - M1 Indicators: vol_delta, vol_roc, cvd_slope, vwap, sma9, sma21,
                    sma_spread, sma_momentum_label, health_score,
                    bar_open, bar_high, bar_low, bar_close
  - Structure: h4_structure, h1_structure, m15_structure, m5_structure
  - Outcome: is_winner (boolean), outcome_detail, r_achieved


3. INDICATOR SPECIFICATIONS
================================================================================

  Seven indicators are tested, each with multiple sub-tests.
  Indicators are ordered by historical edge strength.

3.1 CANDLE RANGE (Strongest - 18-29pp historical edge)
--------------------------------------------------------------------------------

  Source Data: M1 bar OHLC (bar_open, bar_high, bar_low)

  Calculation:
    candle_range_pct = (bar_high - bar_low) / bar_open * 100

  Threshold Categories:
    ABSORPTION:  candle_range_pct < 0.12%  (low volatility, skip zone)
    LOW:         0.12% <= candle_range_pct < 0.15%
    NORMAL:      0.15% <= candle_range_pct < 0.20%  (momentum present, take)
    HIGH:        candle_range_pct >= 0.20%  (strong signal)

  Quintile Bucketing:
    pd.qcut into 5 equal-frequency bins:
    Q1_Smallest, Q2, Q3, Q4, Q5_Largest

  Tests:
  1. Threshold Categories - Chi-square on ABSORPTION/LOW/NORMAL/HIGH
  2. Magnitude Quintiles - Spearman correlation on Q1-Q5 vs win rate
  3. Absorption Zone Filter - Chi-square on ABSORPTION vs NORMAL

  Key Finding: Absorption zone (< 0.12%) = ~33% WR -> universal skip filter

3.2 MARKET STRUCTURE (Strong - 24-54pp historical edge on H1)
--------------------------------------------------------------------------------

  Source Data: entry_indicators table (h1_structure, m15_structure, m5_structure)

  Value Standardization:
    Raw values -> uppercase -> mapped:
      'NEUT' -> 'NEUTRAL'
      'BULL' -> 'BULLISH'
      'BEAR' -> 'BEARISH'
    Missing values -> 'UNKNOWN'

  Multi-Timeframe Alignment Check:
    Examines H1, M15, M5 structures (excluding NEUTRAL and UNKNOWN):
    - ALIGNED: All non-neutral timeframes have same direction
    - NOT_ALIGNED: Timeframes disagree on direction
    - NEUTRAL: Fewer than 2 non-neutral timeframes to compare

  Confluence Score:
    Weighted score across timeframes:
      H1 weight: 1.5 (highest timeframe, most significant)
      M15 weight: 1.0
      M5 weight: 0.5 (lowest timeframe, least significant)

    Calculation:
      For each timeframe:
        BULLISH -> +weight
        BEARISH -> -weight
        NEUTRAL -> 0
      Range: -3.0 (max bearish) to +3.0 (max bullish)

  Tests:
  1. H1 Structure Direction - Chi-square on BULLISH/BEARISH/NEUTRAL
  2. M15 Structure Direction - Chi-square on BULLISH/BEARISH/NEUTRAL
  3. M5 Structure Direction - Chi-square on BULLISH/BEARISH/NEUTRAL
  4. MTF Alignment - Chi-square on ALIGNED/NOT_ALIGNED/NEUTRAL
  5. Confluence - Chi-square on confluence score categories

  Key Finding: NEUTRAL H1 structure paradoxically beats BULL/BEAR

3.3 CVD SLOPE (Strong for SHORT - 15-27pp historical edge)
--------------------------------------------------------------------------------

  Source Data: m1_indicator_bars.cvd_slope

  Direction Classification:
    RISING:   cvd_slope > 0.1  (threshold from CVD_CONFIG)
    FALLING:  cvd_slope < -0.1
    FLAT:     -0.1 <= cvd_slope <= 0.1

  Alignment (with trade direction):
    ALIGNED:
      (direction == LONG AND cvd_slope > 0) OR
      (direction == SHORT AND cvd_slope < 0)
    MISALIGNED: opposite of above

  Category by Magnitude:
    abs_slope computed, then percentile-based:
    EXTREME:   abs_slope >= 75th percentile
    MODERATE:  abs_slope >= median
    WEAK:      abs_slope < median

  Tests:
  1. CVD Direction - Chi-square on RISING/FALLING/FLAT
  2. CVD Alignment - Chi-square on ALIGNED/MISALIGNED

  Configuration:
    window: 15 bars
    rising_threshold: 0.1
    falling_threshold: -0.1

3.4 VOLUME DELTA (Good - 10-20pp historical edge)
--------------------------------------------------------------------------------

  Source Data: m1_indicator_bars.vol_delta

  Sign Classification:
    POSITIVE: vol_delta >= 0
    NEGATIVE: vol_delta < 0

  Absolute Value:
    vol_delta_abs = abs(vol_delta)

  Alignment (with trade direction):
    ALIGNED:
      (direction == LONG AND vol_delta > 0) OR
      (direction == SHORT AND vol_delta < 0)
    MISALIGNED: opposite of above

  Magnitude Quintiles:
    pd.qcut on vol_delta_abs into 5 bins:
    Q1_Smallest, Q2, Q3, Q4, Q5_Largest

  Tests:
  1. Sign (Pos/Neg) - Chi-square on POSITIVE/NEGATIVE
  2. Alignment - Chi-square on ALIGNED/MISALIGNED
  3. Magnitude Quintiles - Spearman correlation on Q1-Q5 vs win rate

  Key Finding: MISALIGNED delta beats ALIGNED by 5-21pp
               (trading against order flow captures exhaustion/reversals)

  Configuration:
    rolling_period: 5
    magnitude_threshold: 100000

3.5 SMA ANALYSIS (Good - 19-25pp historical edge)
--------------------------------------------------------------------------------

  Source Data: m1_indicator_bars.sma9, sma21, sma_spread

  SMA Spread Calculation:
    sma_spread = sma9 - sma21  (if not already in data)

  Spread Direction:
    BULLISH: sma_spread > 0  (fast SMA above slow)
    BEARISH: sma_spread < 0  (fast SMA below slow)

  Spread Magnitude:
    sma_spread_abs = abs(sma_spread)
    Wide Spread: sma_spread_abs >= 0.15 (from SMA_CONFIG)

  Price Position (relative to both SMAs):
    ABOVE_BOTH:  bar_close > sma9 AND bar_close > sma21
    BELOW_BOTH:  bar_close < sma9 AND bar_close < sma21
    BETWEEN:     price between the two SMAs

  Tests:
  1. Spread Direction - Chi-square on BULLISH/BEARISH
  2. Price Position - Chi-square on ABOVE_BOTH/BELOW_BOTH/BETWEEN

  Configuration:
    fast_period: 9
    slow_period: 21
    wide_spread_threshold: 0.15

3.6 VOLUME ROC (Moderate edge)
--------------------------------------------------------------------------------

  Source Data: m1_indicator_bars.vol_roc

  Threshold Categories:
    HIGH:      vol_roc >= 50  (high volume)
    ELEVATED:  30 <= vol_roc < 50  (elevated volume)
    NORMAL:    vol_roc < 30  (baseline volume)

  Elevated Flag:
    vol_roc_elevated = vol_roc >= 30

  Quintile Bucketing:
    pd.qcut into 5 bins:
    Q1_Lowest, Q2, Q3, Q4, Q5_Highest

  Tests:
  1. Category - Chi-square on NORMAL/ELEVATED/HIGH
  2. Magnitude Quintiles - Spearman correlation on Q1-Q5 vs win rate

  Configuration:
    baseline_period: 20
    elevated_threshold: 30
    high_threshold: 50

3.7 VWAP SIMPLE (Paradoxical - on hold)
--------------------------------------------------------------------------------

  Source Data: m1_indicator_bars.vwap

  Note: Listed in the indicator registry but NO test functions are
  implemented in edge_tests.py. The VWAP indicator is registered in
  config.py with two planned tests (position, alignment) but the
  ALL_TESTS registry in edge_tests.py does not include a 'vwap_simple'
  entry. This indicator is currently on hold due to paradoxical findings
  in early testing.


4. STATISTICAL TESTING FRAMEWORK
================================================================================

4.1 CHI-SQUARE TEST OF INDEPENDENCE
--------------------------------------------------------------------------------

  Purpose: Tests whether the distribution of wins/losses is independent
           of the categorical grouping variable.

  Implementation:
  - Constructs a contingency table: pd.crosstab(group_col, outcome_col)
  - Requires at least 2 groups and both outcome values (True/False)
  - Calls scipy.stats.chi2_contingency(contingency)
  - Returns: chi2 statistic, p-value, effect_size

  Effect Size Calculation:
    effect_size = max(group_win_rates) - min(group_win_rates)
    Measured in percentage points (pp)

  Usage: All categorical tests (threshold categories, sign, alignment,
         direction, structure categories)

4.2 SPEARMAN RANK CORRELATION
--------------------------------------------------------------------------------

  Purpose: Tests for monotonic relationship between ordered buckets
           (quintiles) and win rate.

  Implementation:
  - Calculates win rate per quintile bucket
  - Filters to only buckets that exist in data
  - Requires at least 3 buckets for valid test
  - Calls scipy.stats.spearmanr(positions, rates)
  - Returns: correlation coefficient, p-value, effect_size

  Effect Size Calculation:
    effect_size = abs(last_bucket_win_rate - first_bucket_win_rate)

  Usage: All quintile/ordinal tests (range quintiles, volume delta
         magnitude, volume ROC magnitude)

4.3 EDGE DETERMINATION LOGIC
--------------------------------------------------------------------------------

  Three conditions must ALL be met for a validated edge:

  Condition 1: Statistical Significance
    p_value < P_VALUE_THRESHOLD (0.05)

  Condition 2: Practical Significance
    effect_size > EFFECT_SIZE_THRESHOLD (3.0 percentage points)

  Condition 3: Sufficient Sample Size
    confidence != "LOW"
    (minimum group size >= 30 for MEDIUM, >= 100 for HIGH)

  Confidence Levels:
    HIGH:   min_group_size >= 100 (reliable conclusions)
    MEDIUM: min_group_size >= 30  (usable with caution)
    LOW:    min_group_size < 30   (insufficient for conclusions)

  Outcome:
    If all three conditions met -> has_edge = True
    If LOW confidence -> "INSUFFICIENT DATA"
    If p >= 0.05 -> "NO EDGE - Not statistically significant"
    If effect < 3pp -> "NO EDGE - Effect too small"


5. SEGMENT TESTING ARCHITECTURE
================================================================================

  Each indicator test is executed across multiple trade segments to identify
  where edges are strongest and most actionable.

5.1 SEGMENT DEFINITIONS
--------------------------------------------------------------------------------

  Name              Filter                          Category
  ----              ------                          --------
  ALL               No filter                       Overall
  LONG              direction == 'LONG'             Direction
  SHORT             direction == 'SHORT'            Direction
  CONTINUATION      model IN ('EPCH1', 'EPCH3')    Trade Type
  REJECTION         model IN ('EPCH2', 'EPCH4')    Trade Type
  EPCH1             model == 'EPCH1'                Model
  EPCH2             model == 'EPCH2'                Model
  EPCH3             model == 'EPCH3'                Model
  EPCH4             model == 'EPCH4'                Model

  Note: The CLI runner uses 5 segments (ALL, LONG, SHORT, CONTINUATION,
  REJECTION) by default. The config.py SEGMENTS list includes all 9
  segments including individual EPCH1-4 models.

5.2 SEGMENT FILTERING
--------------------------------------------------------------------------------

  Filters are applied before each test function call:
  - Direction filter: df[df['direction'] == value]
  - Models filter: df[df['model'].isin(model_list)]
  - Model filter: df[df['model'] == value]
  - Minimum 30 trades required per segment (skipped if below)

5.3 TEST MATRIX
--------------------------------------------------------------------------------

  7 indicators x variable tests x 5-9 segments = 75+ individual tests

  Per-indicator test counts:
    Candle Range:     3 tests x 5 segments = 15 tests
    Volume Delta:     3 tests x 5 segments = 15 tests
    Volume ROC:       2 tests x 5 segments = 10 tests
    CVD Slope:        2 tests x 5 segments = 10 tests
    SMA Analysis:     2 tests x 5 segments = 10 tests
    Market Structure: 3 tests x 5 segments = 15 tests
    VWAP Simple:      0 tests (not implemented)
    -------------------------------------------------
    Total:            15 sub-tests x 5 segments = 75 tests


6. STOP TYPE SUPPORT
================================================================================

  The module supports multiple stop type definitions for outcome
  classification. The stop_type parameter determines which row from the
  stop_analysis table defines the WIN/LOSS outcome for each trade.

6.1 AVAILABLE STOP TYPES
--------------------------------------------------------------------------------
  - zone_buffer     (default) - Zone boundary + 5% buffer
  - fractal         - Fractal-based stop level
  - m5_atr          - M5 ATR-based stop
  - m15_atr         - M15 ATR-based stop
  - prior_m1        - Prior M1 bar high/low
  - prior_m5        - Prior M5 bar high/low

6.2 DIAGNOSTIC SUPPORT
--------------------------------------------------------------------------------
  When no data is returned, the system queries stop_analysis for
  available stop_type values and reports which types exist in the
  database, helping diagnose configuration mismatches.


7. USER INTERFACE
================================================================================

7.1 WINDOW LAYOUT
--------------------------------------------------------------------------------

  Header:
  - Title: "EPOCH INDICATOR EDGE TESTING" (14px bold, #26a69a)
  - Subtitle: "Statistical Edge Analysis for M1 Bar Indicators" (11px, gray)

  Control Panel (three column groups):
  - Left: Indicator Selection (multi-select QListWidget, max 150px height)
    - All 7 indicators listed in DEFAULT_INDICATOR_ORDER
    - All selected by default
    - Select All / Select None buttons
    - Tooltips show indicator descriptions

  - Middle: Filters
    - Stop Type: QComboBox (6 options)
    - Date Range: QCheckBox toggle + QDateEdit from/to with calendar popup
    - Verbose Output: QCheckBox (unchecked by default)
    - Export Results to Markdown: QCheckBox (unchecked by default)

  - Right: Action Buttons
    - RUN TESTS: Green (#26a69a), minimum 40px height
    - STOP: Red (#ef5350), disabled until running
    - CLEAR: Orange (#ff9800)

  Progress Bar:
  - 0-100% with percentage text
  - Tracks via [X/N] pattern parsing from subprocess stdout

  Terminal Output (expandable, takes remaining space):
  - Font: Consolas 10pt, read-only QTextEdit
  - Background: #0d0d0d (near-black)
  - Color coding:
    - Red (#ef5350): ERROR, FAILED, Traceback
    - Green (#26a69a): EDGE DETECTED, EDGE, [+], SUCCESS
    - Orange (#ff9800): WARNING, NO_EDGE, LOW_DATA, [~]
    - Gray (#808080): Section dividers (=== and ---)
    - White (#e8e8e8): Default output

  Status Bar:
  - Background: #252526
  - Shows: "Ready", "Running tests...", completion status

7.2 PROCESS MANAGEMENT
--------------------------------------------------------------------------------
  - Tests run as QProcess subprocess (run_edge_tests.py)
  - Merged stdout/stderr channels
  - Real-time output streaming line by line
  - Kill support for immediate process termination
  - UI state management: Run/Stop button enable/disable
  - Close event kills running process

7.3 DARK THEME
--------------------------------------------------------------------------------
  Comprehensive QSS stylesheet covering all widgets:
  - QMainWindow, QWidget: #1e1e1e background
  - QPushButton: #2d2d2d with #404040 border, hover/pressed states
  - QTextEdit: #0d0d0d terminal background
  - QComboBox, QDateEdit: #2d2d2d with dropdown styling
  - QCheckBox: Custom indicator with #26a69a checked state
  - QProgressBar: #26a69a chunk on #2d2d2d background
  - QGroupBox: #404040 border with #26a69a title
  - QListWidget: #2d2d2d with #26a69a selected items
  - QScrollBar: Custom minimal scrollbars
  - QCalendarWidget: Full dark theme for date picker
  - QStatusBar: #252526 with #808080 text


8. CLI INTERFACE
================================================================================

  Script: scripts/run_edge_tests.py

  Usage:
    python run_edge_tests.py                                    # All tests
    python run_edge_tests.py --indicators candle_range,volume_delta
    python run_edge_tests.py --date-from 2026-01-01 --verbose
    python run_edge_tests.py --stop-type m5_atr
    python run_edge_tests.py --export edge_results.md

  Arguments:
    --indicators    Comma-separated indicator keys (default: all)
    --date-from     Start date filter YYYY-MM-DD (default: none)
    --date-to       End date filter YYYY-MM-DD (default: none)
    --stop-type     Stop type for outcome (default: zone_buffer)
    --export        Export to markdown file (default: none)
    --verbose       Show detailed output per test

  Workflow:
    [1/3] Connect to Supabase and fetch joined trade+indicator data
    [2/3] Report data summary (trade count, date range, baseline WR)
    [3/3] Report indicator data availability per column
    [1/N]-[N/N] Run each indicator's tests across segments
    Print results summary (edges sorted by effect size descending)
    Optionally print detailed results per indicator per test
    Optionally export markdown report

  Exit Codes:
    0 - Success
    1 - Unknown indicator, data fetch failure, or empty data


9. DATA MODELS
================================================================================

  EdgeTestResult (dataclass):
    indicator:          str     - Indicator name (e.g., "Volume Delta")
    test_name:          str     - Test name (e.g., "Vol Delta Sign")
    segment:            str     - Segment (e.g., "ALL", "LONG", "SHORT")
    has_edge:           bool    - True if all three edge conditions met
    p_value:            float   - From chi-square or spearman test
    effect_size:        float   - Win rate difference in percentage points
    groups:             Dict    - {group_name: {trades: n, wins: n, win_rate: pct}}
    baseline_win_rate:  float   - Overall win rate for comparison
    confidence:         str     - "HIGH", "MEDIUM", or "LOW"
    test_type:          str     - "chi_square", "spearman", or "none"
    recommendation:     str     - Action recommendation string
    total_trades:       int     - Total trades in segment (default 0)

  Methods:
    to_dict() -> Dict   - Serialization to dictionary

  Win Rate Group Structure:
    {
        'GROUP_NAME': {
            'trades': int,      # Total trades in group
            'wins': int,        # Winning trades in group
            'win_rate': float   # Win percentage (0-100)
        }
    }


10. MARKDOWN REPORT FORMAT
================================================================================

  Reports are exported to: 04_indicators/results/edge_results_{timestamp}.md

  Filename Pattern: edge_results_YYYYMMDD_HHMMSS.md

  Report Structure:
    1. Header with metadata (timestamp, trade count, baseline WR, stop type)
    2. Summary section (edges detected count, total tests)
    3. Validated Edges table (sorted by effect size descending)
       Columns: Indicator, Test, Segment, Effect, p-value, Confidence
    4. Detailed Results by Indicator
       - Each indicator as H3 heading
       - Each test result: EDGE / NO EDGE / LOW DATA
       - Edge results include effect size and p-value


11. CONFIGURATION SUMMARY
================================================================================

  Statistical Thresholds:
  - P_VALUE_THRESHOLD:          0.05 (statistical significance)
  - EFFECT_SIZE_THRESHOLD:      3.0 percentage points (practical significance)
  - MIN_SAMPLE_SIZE_HIGH:       100 trades per group (HIGH confidence)
  - MIN_SAMPLE_SIZE_MEDIUM:     30 trades per group (MEDIUM confidence)

  Candle Range:
  - absorption_threshold:       0.12% (below = absorption zone, skip)
  - normal_threshold:           0.15% (above = momentum, take)
  - high_threshold:             0.20% (strong signal)

  Volume Delta:
  - rolling_period:             5 bars
  - magnitude_threshold:        100,000

  Volume ROC:
  - baseline_period:            20 bars
  - elevated_threshold:         30 (elevated volume)
  - high_threshold:             50 (high volume)

  CVD Slope:
  - window:                     15 bars
  - rising_threshold:           0.1
  - falling_threshold:          -0.1

  SMA:
  - fast_period:                9 bars (SMA9)
  - slow_period:                21 bars (SMA21)
  - wide_spread_threshold:      0.15

  Structure:
  - lookback:                   5 bars
  - fractal_length:             5

  Health Score:
  - max_score:                  10
  - STRONG:                     8-10
  - MODERATE:                   6-7
  - WEAK:                       4-5
  - CRITICAL:                   0-3

  Default Indicator Run Order (strongest edges first):
  1. candle_range                (18-29pp historical edge)
  2. structure_edge              (24-54pp edge on H1)
  3. cvd_slope                   (15-27pp edge for SHORT)
  4. volume_delta                (10-20pp edge)
  5. sma_edge                    (19-25pp edge)
  6. volume_roc                  (moderate edge)
  7. vwap_simple                 (paradoxical - on hold)


12. DATABASE TABLES
================================================================================

12.1 INPUT TABLES
--------------------------------------------------------------------------------

  trades:
  - Trade records with entry times generated by 03_backtest
  - Key fields: trade_id, date, ticker, model, direction, entry_price,
                entry_time

  m1_indicator_bars:
  - M1 (1-minute) bar snapshots with pre-calculated indicator values
  - Key fields: ticker, bar_date, bar_time, vol_delta, vol_roc,
                cvd_slope, vwap, sma9, sma21, sma_spread,
                sma_momentum_label, health_score, open, high, low, close

  entry_indicators:
  - Multi-timeframe structure snapshots at trade entry time
  - Key fields: trade_id, h4_structure, h1_structure, m15_structure,
                m5_structure

  stop_analysis:
  - Win/loss outcome classification by stop type
  - Key fields: trade_id, stop_type, stop_price, outcome (WIN/LOSS),
                r_achieved
  - Multiple rows per trade (one per stop_type)

12.2 JOIN RELATIONSHIPS
--------------------------------------------------------------------------------

  trades (1) --[trade_id]--> (1) entry_indicators
  trades (1) --[trade_id]--> (N) stop_analysis (filtered by stop_type)
  trades (1) --[ticker,date,prior_bar_time]--> (1) m1_indicator_bars


13. INDICATOR EDGE TEST REGISTRY
================================================================================

  ALL_TESTS dictionary maps indicator keys to test function lists:

  candle_range:
    1. ('Threshold Categories',  test_candle_range_threshold)
    2. ('Magnitude Quintiles',   test_candle_range_quintile)
    3. ('Absorption Filter',     test_candle_range_absorption)

  volume_delta:
    1. ('Sign (Pos/Neg)',        test_vol_delta_sign)
    2. ('Alignment',             test_vol_delta_alignment)
    3. ('Magnitude Quintiles',   test_vol_delta_magnitude)

  volume_roc:
    1. ('Category',              test_vol_roc_category)
    2. ('Magnitude Quintiles',   test_vol_roc_quintile)

  cvd_slope:
    1. ('Direction',             test_cvd_slope_direction)
    2. ('Alignment',             test_cvd_slope_alignment)

  sma_edge:
    1. ('Spread Direction',      test_sma_spread_direction)
    2. ('Price Position',        test_sma_price_position)

  structure_edge:
    1. ('H1 Structure',          test_h1_structure)
    2. ('M15 Structure',         test_m15_structure)
    3. ('MTF Alignment',         test_structure_alignment)


14. PROCESSING PIPELINE
================================================================================

  Step 1: Data Acquisition
  -------------------------
  1. Parse CLI arguments (indicators, filters, stop type)
  2. Connect to Supabase PostgreSQL
  3. Execute master join query with parameterized filters
  4. Return DataFrame with all indicator columns

  Step 2: Per-Indicator Testing Loop
  -----------------------------------
  For each selected indicator (in priority order):
    For each registered test function:
      For each segment (ALL, LONG, SHORT, CONTINUATION, REJECTION):
        1. Apply segment filter to DataFrame
        2. Check minimum sample size (>= 30 trades)
        3. Calculate indicator-specific metrics (categories, quintiles)
        4. Compute win rates per group
        5. Run statistical test (chi-square or spearman)
        6. Determine edge (p-value + effect size + confidence)
        7. Create EdgeTestResult with full context
        8. Append to results list

  Step 3: Results Aggregation
  ----------------------------
  1. Separate results into: edges_found, no_edge, insufficient_data
  2. Sort edges by effect size descending
  3. Print summary with group-level win rates
  4. Optionally print detailed per-test results
  5. Optionally export to markdown file

  Data Flow Diagram:
  Supabase -> DataFrame -> Segment Filter -> Metric Calculation ->
  Statistical Test -> Edge Determination -> EdgeTestResult ->
  Summary / Export


15. RELATIONSHIP TO EPOCH SYSTEM
================================================================================

  The Indicator Edge Testing module is the fourth module in the Epoch
  closed-loop system. It sits downstream of 03_backtest and the indicator
  calculation pipeline, consuming completed trade records and their
  associated indicator snapshots to statistically validate which indicators
  provide actionable trading edges.

  Upstream Dependencies:
  - 01_application: Zone Analysis pipeline identifies trading zones
  - 03_backtest: Backtest Runner simulates trades against zones
  - stop_analysis table: Secondary processors classify outcomes by stop type
  - m1_indicator_bars: Pre-calculated M1 indicator snapshots
  - entry_indicators: Multi-timeframe structure snapshots at entry

  Downstream Consumers:
  - 02_dow_ai: AI trading assistant uses validated edges for live-session
    recommendations (indicator_edges.json context file)
  - 06_training: Training module incorporates edge findings for education
  - Manual: Trader uses edge findings to refine entry/exit criteria

  Feedback Loop:
  Zone Identification (01) -> Backtesting (03) -> Edge Testing (04) ->
  AI Recommendations (02) -> Refinement -> Zone Identification (01)

  Launch Methods:
  - GUI:     python app.py
  - CLI:     python scripts/run_edge_tests.py
  - Master:  Via Epoch launcher (launcher.py)


16. EXTERNAL DEPENDENCIES
================================================================================

  Python Packages:
  - PyQt6           (GUI framework - windows, widgets, process management)
  - psycopg2        (PostgreSQL database driver with SSL)
  - pandas          (DataFrame manipulation, groupby, qcut, crosstab)
  - numpy           (Numerical operations, conditional classification)
  - scipy           (Statistical tests - chi2_contingency, spearmanr)
  - argparse        (CLI argument parsing - stdlib)
  - pathlib          (Path manipulation - stdlib)
  - dataclasses     (Data structures - stdlib)
  - datetime        (Timestamps - stdlib)
  - re              (Regex for progress parsing - stdlib)
  - traceback       (Error reporting - stdlib)

  External Services:
  - Supabase PostgreSQL (db.pdbmcskznoaiybdiobje.supabase.co:5432)
    - SSL required
    - Direct psycopg2 connection (not via shared data layer)


17. FILE INVENTORY
================================================================================

  04_indicators/
  ├── __init__.py                         Module package marker
  ├── app.py                              Application entry point (45 lines)
  ├── config.py                           Centralized configuration (182 lines)
  ├── CLAUDE.md                           AI context documentation
  ├── edge_testing/
  │   ├── __init__.py                     Package exports (10 lines)
  │   ├── base_tester.py                  Database, stats, metrics (566 lines)
  │   └── edge_tests.py                   Test functions + registry (617 lines)
  ├── indicator_gui/
  │   ├── __init__.py                     Package marker
  │   ├── main.py                         Alternate GUI entry point (34 lines)
  │   ├── main_window.py                  IndicatorEdgeWindow class (376 lines)
  │   └── styles.py                       DARK_THEME QSS stylesheet (322 lines)
  ├── scripts/
  │   ├── __init__.py                     Package marker
  │   └── run_edge_tests.py               CLI runner + report gen (400 lines)
  └── results/
      ├── .gitkeep                        Directory placeholder
      └── edge_results_*.md               Generated markdown reports


18. ARCHITECTURAL NOTES
================================================================================

  Module Independence:
  - This module connects directly to Supabase via psycopg2 rather than
    using the shared data layer (00_shared/data/supabase.py)
  - Database credentials are duplicated in config.py rather than imported
    from shared.config.credentials
  - This is noted as a V1-to-V2 migration item (module 04 is pending)

  V2 Migration Status:
  - Module is listed as "Pending" in the Epoch CLAUDE.md migration tracker
  - Current implementation works standalone but does not follow the V2
    centralized import pattern (from shared.config import ...)

  Design Patterns:
  - Follows the same GUI+CLI dual-mode pattern as 03_backtest
  - Uses QProcess subprocess isolation (same as 03_backtest)
  - Terminal-style output with color coding (same UI pattern)
  - Progress tracking via [X/N] stdout pattern parsing

  No VWAP Tests:
  - VWAP is registered in config.py INDICATORS dict with tests=['position',
    'alignment'] but no test functions exist in edge_tests.py and no entry
    exists in ALL_TESTS. The DEFAULT_INDICATOR_ORDER comment notes it as
    "Paradoxical - on hold".


================================================================================
Document generated for XIII Trading LLC - Epoch Trading System v2.0
================================================================================
